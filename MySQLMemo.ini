MySQL Memo

# SQL 예약어

SELECT * FROM memberTBL ;
SELECT memberName, memberAddress FROM memberTBL ;
SELECT * FROM memberTBL WHERE memberName = '지운이' ;

select NickName, Mobile FROM membertbl ;
SELECT * FROM membertbl WHERE NickName = '관리자' ;



# 테이블 생성하기
CREATE TABLE `my TestTBL` (id INT);
-- 백틱(backtick)사용 `
-- 테이블 생성 이후 Refresh ALL 을 해야 나타난다.



# 테이블 삭제하기
DROP TABLE `my TestTBL` ;



# index 생성하기
create table indexTBL (first_name varchar(14), last_name varchar(16), hire_date date);
INSERT INTO indexTBL
	select first_name, last_name, hire_date
    FROM employees.employees
    LIMIT 500;
select * from indexTBL;



# VIEW 생성하기
create view uv_memberTBL
AS
	select NickName, Mobile FROM memberTBL ;
    
select * from uv_memberTBL ;

-- select [테이블에 있는 항목]

-- uv_memberTBL 이름의 뷰를 생성하고, 호출시 닉네임과 핸드폰 항목을 보여준다.



# 스토어드 프로시저
DELIMITER //
CREATE procedure myProc()
begin
	select * from memberTBL where memberName = '당탕이' ;
    select * from priductTBL where productName = '냉장고' ;
END //
DELIMITER ;



# 트리거
* 데이터 입력
INSERT INTO memberTBL VALUES ('Figure', '연아', '경기도 김포시 당정동');

-- 한글 좌우로 '' 따옴표 사용

* 데이터 변경
UPDATE memberTBL SET memberAddress = '서울 강남구 역삼동' WHERE memberName = '연아';
-- memberName 한글로 적용시 에러 발생 (안전모드 해제후 실행 안전모드 실행)

UPDATE memberTBL SET memberAddress = '서울 강남구 역삼동' WHERE memberID = 'Figure';

* 데이터 삭제
-- 회원 탈퇴시 데이터 삭제
DELETE FROM memberTBL WHERE memberName = '연아';




[안전모드 해제]

10:05:33	UPDATE memberTBL SET memberAddress = '서울 강남구 역삼동' WHERE memberName = '연아'	Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column.  To disable safe mode, toggle the option in Preferences -> SQL Editor and reconnect.	0.000 sec

SET SQL_SAFE_UPDATES = 0;
UPDATE memberTBL SET memberAddress = '경기도 광주시 고불로87' WHERE memberName = '연아';
SET SQL_SAFE_UPDATES = 1;

-- 안전모드 해제 후 적용
-- 적용 후에는 다시 안전모드로 변경 해야 함.

MySQL Workbench와 같은 도구를 사용하는 경우 환경 설정에서 안전 모드를 비활성화할 수 있습니다:
Edit 메뉴를 클릭하고 Preferences를 선택합니다.
SQL Editor 섹션으로 이동합니다.
Safe Updates (rejects UPDATEs and DELETEs with no keys in WHERE clause) 옵션의 체크를 해제합니다.
변경 사항을 저장하고 데이터베이스에 다시 연결합니다.



# 삭제한 데이터 보관 테이블 생성
create table deletedMemberTBL (
	memberID CHAR(8) ,
    memberName Char(5) ,
    memberAddress CHAR(20),
    deleteDate DATE -- 삭제한 날짜
) ;


# 데이터 이동 보관 트리거

DELIMITER //
CREATE TRIGGER trg_deletedMemberTBL -- 트리거 이름
	after delete -- 삭제 후에 작동하게 지정
    on memberTBL -- 트리거를 부착할 테이블
    for each row -- 각 행마다 적용시킴
begin
	-- OLD 테이블의 내용을 백업 테이블에 삽입
    INSERT INTO deletedMemberTBL
		values (OLD.memberID, OLD.memberName, OLD.memberAddress, CURDATE() );
END //
DELIMITER ;


# 뷰 재생성
-- 뷰를 드롭하고 다시 생성하여 문제를 해결할 수 있습니다. 뷰를 삭제하고 다시 생성하려면 다음 명령어를 사용합니다.

DROP VIEW IF EXISTS pubgharu.uv_membertbl;
CREATE VIEW pubgharu.uv_membertbl AS
SELECT * FROM memberTBL; -- 적절한 SELECT 문으로 대체하세요



삭제 보관 테이블 생성
create table deletedproductTBL (
	productName CHAR(10) ,
    cost Char(5) ,
    makeDate DATE,
    amount INT,
    deleteDate DATE -- 삭제한 날짜
) ;






DELIMITER //
CREATE TRIGGER trg_deletedproductTBL
	after delete
    on productName
    for each row
begin
    INSERT INTO deletedproductTBL
		values (OLD.productName, OLD.cost, OLD.makeDate, OLD.amount CURDATE() );
END //
DELIMITER ;




SELECT * FROM memberTBL;  -- 멤버 테이블 선택

DELETE FROM memberTBL WHERE memberName = '당탕이';  -- 당탕이 데이터 삭제

SELECT * FROM deletedMemberTBL;  -- 삭제 된 데이터 확인




# 백업 및 복원

Reverse Engineer : 다른 데이터베이스 모델을 가져온다.

Forward Engineer : 모델링 파일을 실제 데이터베이스에 적용

Place a Relationship Using Existing column : 1:N 관계를 맺어준다.



# SQL문을 자동으로 생성

1. 데이터베이스 테이블 선택
2. 마우스 우측 버튼 클릭
3. Send to SQL Editor >> Create Statement

CREATE TABLE `membertbl` (
  `memberID` char(8) NOT NULL,
  `memberName` char(5) NOT NULL,
  `memberAddress` char(20) DEFAULT NULL,
  PRIMARY KEY (`memberID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;



CREATE TABLE indexTBL (first_name varchar(14), last_name varchar(16), hire_date date);
INSERT INTO indexTBL
	SELECT first_name, last_name, hire_date
    FROM employees.employees
    LIMIT 500;
SELECT * FROM indexTBL;



# 조회
SELECT * FROM indexTBL WHERE first_name = 'Mary';



MySQL 사이트

## https://dev.mysql.com/doc/employee/en




## 샘플 데이터베이스 설치 중 오류 해결

'mysql'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다 >>> 해결 방법!
프로파일

MySQL을 처음 설치하고 나서 드디어 실행하려는 순간, 문제에 부딪혔다. 

-u root -p 가 안 먹히는 것이다. 원래는 패스워드 입력하라고 나와야 하는데..흑흑.
시스템 -> 고급 시스템 설정 -> 고급 -> 환경변수 ->시스템변수의 Path 클릭 -> 편집 
에서 잘 입력하란 대로 입력했는데! 
고치고 고치다 보니 내가 바보같은 실수를 몇 개 한 게 있었다.

1. 책에 나온대로 하다보니 원래 내 꺼는 server 5.7 이었는데 5.6으로 입력했다
2. 원래 있던 path 값 뒤에 ;C:\Program Files\MySQL\MySQL server 5.7\bin을 입력하고자 했으나 무슨 연유인지 작동이 안 되어서 기존의 path값을 고쳐서 원래 path 값 뭐였는지 기억이 가물가물해짐.
3. -uroot가 아니라 -u root로 치는 것을 발견..(책에는 -uroot라고 나와있었는데..)
4. 걍 입력하는 걸 틀림
_ 물론 이 모든 실수를 다 고쳐도 여전히 "'mysql'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다" 라고만 뜨는 창..


답답한 마음에 Path 편집 창을 계속 바라보고 있다가 해결책을 발견했다. 

여러가지 환경 변수들이 있는데 그건 걍 냅두고
1) 새로 만들기를 누른다.
2) 그 다음 찾아보기를 누른다. 
3) 그 다음 해당하는 폴더에 들어간다 ( 내 PC -> Local disk (C:) -> Program Files -> MySQL -> MySQL server 5.7 -> bin ) 
그러면 저절로 경로가 추가된다.
4) 파란 화살표로 내가 표시한 저 '위로 이동'을 클릭해서 새로 추가한 경로를 맨 위로 보낸다. 

확인을 누르고, 실행하면 된다.

이렇게 했는데도 안되면, 
사용자 변수에 Path를 추가하고 c:\windows\system32 을 집어넣어보면 된다. 



# index 생성

create index idx_indexTBL_firstname ON indexTBL(first_name);



CREATE VIEW uv_memberTBL
AS
	SELECT memberName, memberAddress FROM memberTBL ;
    


SELECT * FROM uv_membertbl ;


# 두가지 조건 검색

SELECT * FROM membertbl where memberName = '당탕이';
SELECT * FROM producttbl where productName = '냉장고';


# 스토어프로시저 생성
DELIMITER //
CREATE PROCEDURE myProc()
BEGIN
    SELECT * FROM membertbl where memberName = '당탕이';
    SELECT * FROM producttbl where productName = '냉장고';
END //
DELIMITER ;


# 스토어프로시저 삭제
DROP procedure myProc;

## 실행 후 결과값이 제대로 안 나올 경우 SCHEMAS에서 삭제후 재생성 하면 올바르게 작동한다.



### 데이터베이스 이름 변경 & 다른 데이터 베이스로 테이블 이동
create database ShopDB;

rename table pubgharu.indextbl to ShopDB.indextbl ;
rename table pubgharu.deletedmembertbl to ShopDB.deletedmembertbl ;
rename table pubgharu.deletedproducttbl to ShopDB.deletedproducttbl ;
rename table pubgharu.membertbl to ShopDB.membertbl ;
rename table pubgharu.producttbl to ShopDB.producttbl ;
rename table pubgharu.pubgmembertbl to ShopDB.pubgmembertbl ;



# 회원 테이블에 새로운 회원 입력
INSERT INTo memberTBL VALUES ('Tomboy', '꼬마', '부산광역시 사하구 괴정동');


# 


https://dev.mysql.com/downloads/connector/odbc/

win + R
c:\windows\SysWOW64\odbcad32.exe


### web form 안될 경우
2022 버전에서 웹폼을 사용하기 위해서는 설치할 때, 다음 기능을 추가해야 합니다.

이미 설치되어 있는 경우는 “Visual Studio Installer”에서 추가하면 됩니다.

[도구] 메뉴 -> [도구 및 기능 가져오기]

#
ASP.NET 및 웹 개발 [체크]
.NET Framework 프로젝트 및 항목 템플릿 [체크]
추가 프로젝트 템플릿(이전 버전) [체크]



# 문제 해결

 

데이터 소스 구성, 데이터 소스 사양, 사용자 또는 시스템 데이터 소스 이름 사용에서 항목이 없음

c:\windows\SysWOW64\odbcad32.exe

### 
생성한 ODBC 데이터베이스(MysqlODBC) 항목이 나타나지 않으면 직접 작성해서 연결



### MySQL 설정
## 자동완성 대문자 설정
Edit > Preferences > SQL Editor > Query Editor > USE UPPERCASE keywords on completion


Query > Stop Script Execution on Errors 해제 : SQL문에서 오류가 발생 할 경우 오류가 난 구문을 무시하고 뒤의 명령어를 실행 한다.(권장하지 않는다.)
( 기본적으로 체크가 되어 있어야 한다. )



#
USE ShopDB;
CREATE TABLE test (id INT);
INSERT INTO test VALUES(1);


# Filter Rows에서 검색해서 나온 결과를 Export 하더라도 기존의 1000개의 파일 전부가 Export 된다.
(보여지는 것이 내보내기 되는게 아니다.)


# SELECT 열 이름 FROM 테이블이름 WHERE 조건



USE employees ;
USE shopdb ;


SELECT * FROM titles;
SELECT * FROM employees.titles;

SELECT title FROM titles;

SELECT first_name FROM employees;
SELECT first_name, last_name, gender FROM employees;



create database sampleDB;
drop DATABASE sampledb;


SHOW TABLE STATUS;
-- 테이블의 이름만 간단히 보려면 SHOW TABLES; 쿼리문을 사용하면 된다.


DESCRIBE employees;
DESC employees;
-- 테이블의 열이 무엇이 있는지 확인



SELECT first_name AS 이름 ,  gender 성별, hire_date '회사 입사일'
FROM employees;


-- 중간에 공백이 있으면 '' 를 붙여준다.




## slqDB 데이터베이스 초기화
#### 테이블 생성 ( sqlDB 가져오기 )

DROP DATABASE IF EXISTS sqldb;
create DATABASE sqldb;

use sqldb;
CREATE TABLE usertbl
( userID	char(8) not null primary key,
name	VARCHAR(10) NOT NULL,
birthYear	INT NOT NULL,
addr 	CHAR(2) NOT NULL,
mobile1	CHAR(3),
mobile2 CHAR(8),
height	SMALLINT,
mDate	DATE);
CREATE TABLE buytbl
( num	INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
userID CHAR(8) NOT NULL,
prodName CHAR(6) NOT NULL,
groupName	CHAR(4),
price	INT NOT NULL,
amount	INT NOT NULL,
FOREIGN KEY (userID) REFERENCES usertbl(userID)
);




### -- 데이터 추가 입력

INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울', '011', '1111111', 182, '2008-8-8');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남', '011', '2222222', 173, '2012-4-4');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남', '019', '3333333', 177, '2007-7-7');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기', '011', '4444444', 166, '2009-4-4');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울', NULL, NULL, 186, '2013-12-12');
INSERT INTO usertbl VALUES('LJB', '임재범', 1963, '서울', '016', '6666666', 182, '2009-9-9');
INSERT INTO usertbl VALUES('YJS', '윤종신', 1969, '경남', NULL, NULL, 170, '2005-5-5');
INSERT INTO usertbl VALUES('EJW', '은지원', 1972, '경북', '011', '8888888', 174, '2014-3-3');
INSERT INTO usertbl VALUES('JKW', '조관우', 1965, '경기', '018', '9999999', 172, '2010-10-10');
INSERT INTO usertbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');

INSERT INTO buytbl VALUES(NULL, 'KBS', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buytbl VALUES(NULL, 'JYP', '모니터', '전자', 200, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200, 5);
INSERT INTO buytbl VALUES(NULL, 'KBS', '청바지', '의류', 50, 3);
INSERT INTO buytbl VALUES(NULL, 'BBK', '메모리', '전자', 80, 10);
INSERT INTO buytbl VALUES(NULL, 'SSK', '책', '서적', 15, 5);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '청바지', '의류', 50, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);




#
SELECT 필드이름 FROM 테이블이름 WHERE 조건식;

SELECT * FROM usertbl WHERE name = '김경호';

SELECT userID, Name FROM usertbl WHERE birthYear >= 1970 AND height >= 182;
-- AND

SELECT userID, Name FROM usertbl WHERE birthYear >= 1970 OR height >= 182;
-- OR

SELECT Name, height FROM usertbl WHERE height BETWEEN 180 AND 183;
--BETWEEN AND

SELECT Name, addr FROM usertbl WHERE addr='경남' OR addr='전남' OR addr='경북';
-- OR OR OR

SELECT Name, addr FROM usertbl WHERE addr IN ('경남', '전남', '경북');
-- IN ()

SELECT Name, height FROM usertbl WHERE name LIKE '김%';
-- 김 이후 아무 여러 문자

SELECT Name, height FROM usertbl WHERE name LIKE '_종신';
-- 앞에 한 글자 다음 종신이 있는 문자

SELECT Name, height FROM usertbl WHERE name LIKE '_용%';
-- 앞에 한 글자 용 다음 아무 여러 문자

# _ 또는 %를 사용할 경우 인덱스가 있다고 해도 전체를 검색하기 때문에 아주 비효율적인 결과를 보여준다.



#
ANY/ALL/SOME 그리고 서브쿼리(SubQuery, 하위쿼리)

SELECT Name, height FROM usertbl WHERE height > 177 ;

김경호의 키를 직접 입력하는게 아니라 하위쿼리를 작성해서 키 데이터 값을 입력한다.

SELECT Name, height FROM usertbl 
	WHERE height > (SELECT height FROM usertbl WHERE Name = '김경호');


# ANY -- 두개의 조건값에 해당하는 모든 값을 출력함
SELECT Name, height FROM usertbl 
	WHERE height >= ANY (SELECT height FROM usertbl WHERE addr = '경남');    

-- ANY를 빼고 실행하면 두개의 값이 있으므로 오류가 발생하지만, ANY를 써주면 173,170에 대한 값을 모두 출력함. 170과 같거나 높은 결과값을 보여줌

# ALL -- 두개의 조건값을 모두 충족하는 값을 출력함
-- ALL 이라고 입력하면, 170과 같거나 큰 사람, 또 173과 같거나 큰사람 이기에 결과값은 173과 같거나 큰사람만 출력한다.


SELECT Name, height FROM usertbl 
	WHERE height = ANY (SELECT height FROM usertbl WHERE addr = '경남');

-- 173, 170의 조건값과 동일한 두명만 출력한다.


= ANY는 다음과 동일한 구문이다. '=ANY'는 'IN'와 동일한 의미이다.

SELECT Name, height FROM usertbl 
	WHERE height IN (SELECT height FROM usertbl WHERE addr = '경남');




오름차순 ASCENDING
내림차순 DESCENDING

SELECT name, mDate FROM usertbl ORDER BY mDate;

SELECT name, mDate FROM usertbl ORDER BY mDate DESC;

SELECT name, mDate FROM usertbl ORDER BY mDate DESC, name ASC;

-- ORDER BY절은 SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY 중에서 제일 뒤에 와야 한다.



중복된 것을 하나만 남기는 DISTINCT


SELECT addr FROM usertbl; -- 전체를 출력
SELECT addr FROM usertbl ORDER BY addr; -- 중복된 것들을 내림차순으로 정렬 후 출력
SELECT DISTINCT addr FROM usertbl; -- 중복된 것을 한개씩만 출력

SELECT DISTINCT addr FROM usertbl ORDER BY addr; -- 중복된 것을 한개씩만 출력하고 내림차순으로 정렬




USE employees;

SELECT emp_no, hire_date FROM employees
	ORDER BY hire_date ASC;


SELECT first_name, emp_no, hire_date FROM employees
	ORDER BY hire_date ASC
    LIMIT 0, 5;


# 테이블을 복사하는 CREATE TABLE ... SELECT

CREATE TABLE 새로운테이블 (SELECT 복사할열 FROM 기존테이블)

use sqldb;

CREATE TABLE buytbl2 (SELECT * FROM buytbl); -- 전체 복사 생성
SELECT * FROM buytbl2;

CREATE TABLE buytbl3 (SELECT userID, prodName FROM buytbl); -- 특정 열만 복사 생성
SELECT * FROM buytbl3;


# GROUP BY 및 HAVING 그리고 집계 함수


GROUP BY절

SELECT select_expr
	[FROM table_references]
    [WHERE where_condition]
    [GROUP BY {col_name : expr : position}]
    [HAVING where_condition]
    [ORDER BY {col_name : expr : position}]


SELECT userID, amount FROM buytbl ORDER BY userID;

SELECT userID, SUM(amount) FROM buytbl GROUP BY userID;
-- amount 항목을 합산하여 그룹화 해준다.

SELECT userID AS '사용자 아이디', SUM(price * amount) AS '총 구매액' 
    FROM buytbl GROUP BY userID;
-- 구매액과 총 구매수를 곱해서 총 구매액을 산출한다.



## 집계 함수
AVG() -- 평균을 구한다.
MIN() -- 최소값을 구한다.
MAX() -- 최대값을 구한다.
COUNT() -- 행의 개수를 센다.
COUNT(DISTINCT) -- 행의 개수를 센다(중복은 1개만 인정)
STDEV() -- 표준편차를 구한다.
VAR_SAMP() -- 분산을 구한다.


SELECT AVG(amount) AS '평균 구매 개수' FROM buytbl ;

SELECT userID, AVG(amount) AS '평균 구매 개수' FROM buytbl GROUP BY userID;


SELECT name, MAX(height), MIN(height) FROM usertbl ;
-- 틀림
SELECT name, MAX(height), MIN(height) FROM usertbl GROUP BY Name;
-- 틀림
SELECT name, height
	FROM usertbl
    WHERE height = (SELECT MAX(height) FROM usertbl)
    OR height = (SELECT MIN(height) FROM usertbl) ;

-- 정답 : 조용필 166, 성시경 186


SELECT count(*) FROM usertbl;

SELECT COUNT(mobile1) AS '휴대폰이 있는 사용자' FROM usertbl ;


# HAVING 절
SELECT userID AS '사용자 아이디', SUM(price * amount) AS '총 구매액' 
    FROM buytbl 
    GROUP BY userID;


SELECT userID AS '사용자 아이디', SUM(price * amount) AS '총 구매액' 
    FROM buytbl 
    GROUP BY userID
    HAVING SUM(price * amount) > 1000 ;

-- 총구매액이 1000 이상인 유저를 출력한다.

SELECT userID AS '사용자 아이디', SUM(price * amount) AS '총 구매액' 
    FROM buytbl 
    GROUP BY userID
    HAVING SUM(price * amount) > 1000 
    ORDER BY SUM(price*amount) ;

-- 총 구매액이 적은 사용자부터 출력



# ROLLUP 
-- 분류별로 합계 및 그 총합

SELECT num, groupName, SUM(price * amount) AS '비용' 
    FROM buytbl 
    GROUP BY groupName, num
    WITH ROLLUP;


SELECT groupName, SUM(price * amount) AS '비용' 
    FROM buytbl 
    GROUP BY groupName
    WITH ROLLUP;



###
SELECT select_expr
    [FROM table_references]
    [WHERE where_condition]
    [GROUP BY {col_name : expr : position}]
    [HAVING where_condition]
    [ORDER BY {col_name : expr : position}]




DML : SELECT, INSERT, UPDATE, DELETE
DDL : CREATE, DROP, ALTER
DCL : GRANT, REVOKE, DENY



INSERT [INTO] 테이블[(열1, 열2, ...)] VALUES (값1, 값2, ...)

USE sqldb;
CREATE TABLE testTbl1 (id int, userName char(3), age int);
INSERT INTO testTbl1 VALUES (1, '홍길동', 25);

SELECT * FROM testtbl1;


INSERT INTO testTbl1(id, userName, age) VALUES (2, '설현', 26);



CREATE TABLE testTbl2
	(id int AUTO_INCREMENT PRIMARY KEY,
    userName char(3),
    age int );
INSERT INTO testtbl2 VALUES (NULL, '지민', 25);
INSERT INTO testtbl2 VALUES (NULL, '유나', 22);
INSERT INTO testtbl2 VALUES (NULL, '유경', 21);
SELECT * FROM testTbl2;



ALTER TABLE testTbl2 AUTO_INCREMENT=100;
INSERT INTO testTbl2 VALUES (NULL, '찬미', 23);
SELECT * FROM testTbl2;



CREATE TABLE testTbl3
	(id int AUTO_INCREMENT PRIMARY KEY,
    userName char(3),
    age int );
ALTER TABLE testtbl3 AUTO_INCREMENT=1000;
SET @@auto_increment_increment=3;
INSERT INTO testtbl3 VALUES (NULL, '나연', 20);
INSERT INTO testtbl3 VALUES (NULL, '정연', 18);
INSERT INTO testtbl3 VALUES (NULL, '모모', 19);
SELECT * FROM testTbl3;




-- 아래와 같이 3건의 데이터를 한줄로 입력도 가능하다.
INSERT INTO testtbl3 VALUES (NULL, '나연', 20), (NULL, '정연', 18), (NULL, '모모', 19);


형식:
INSERT INTO 테이블이름 (열 이름1, 열 이름2, ...)
    SELECT문 ;



USE sqldb;
CREATE TABLE testTbl4 (id int, Fname varchar(50), Lname varchar(50));
INSERT INTO testTbl4
    SELECT emp_no, first_name, last_name
        FROM employees.employees ;
SELECT * FROM sqldb.testtbl4;



CREATE TABLE testTbl5
	(SELECT emp_no, first_name, last_name FROM employees.employees) ;
SELECT * FROM sqldb.testtbl5;



# 데이터의 수정 : UPDATE
UPDATE 테이블이름
    SET 열1=값1, 열2=값2 ...
    WHERE 조건;



UPDATE testTbl4
	SET Lname = '없음'
    WHERE Fname = 'Kyoichi';


SELECT * FROM testTbl4 WHERE Fname = 'Kyoichi';
SELECT * FROM sqldb.testtbl4;



-- 모든 상품의 가격이 1.5배 인상 했을때 변경
UPDATE buytbl SET price = price * 1.5 ;
SELECT * FROM sqldb.buytbl;



# 데이터의 삭제 : DELETE FROM
DELETE FROM 테이블이름 WHERE 조건;

WHERE문이 생략되면 전체 데이터를 삭제한다.

DELETE FROM testTbl4 WHERE Fname = 'Aamer' ;
-- Aamer 228건 삭제

DELETE FROM testTbl4 WHERE Fname = 'Aamer' LIMIT 5;
-- 상위 5건만 삭제



CREATE TABLE bigTbl1 (SELECT * FROM employees.employees);
CREATE TABLE bigTbl2 (SELECT * FROM employees.employees);
CREATE TABLE bigTbl3 (SELECT * FROM employees.employees);

DELETE FROM bigTbl1;
-- DML문 : 트랜잭션 로그를 기록하는 작업 떄문에 삭제가 오래 걸린다.

DROP TABLE bigTbl2;
-- 테이블 자체를 삭제한다. 그리고 DDL은 트랜잭션을 발생시키지 않는다.

TRUNCATE TABLE bigtbl3;
-- DDL문 : 효과는 DELETE와 동일하지만, 트랜잭션 로그를 기록하지 않아서 속도가 무척 빠르다.


# 테이블 자체가 필요 없을 경우 DROP, 테이블 구조는 남겨놓고 싶다면 TRUNCATE로 삭제하는 것이 효율적이다.


# 오류 발생시 오류문 이후 실행
CREATE TABLE memberTBL (SELECT userID, name, addr FROM usertbl LIMIT 3);
ALTER TABLE memberTBL
	ADD CONSTRAINT pk_memberTBL PRIMARY KEY (userID);
SELECT * FROM memberTBL;


INSERT INTO memberTBL VALUES('BBK', '비비코', '미국');
INSERT INTO memberTBL VALUES('SJH', '서장훈', '서울');
INSERT INTO memberTBL VALUES('HJY', '현주엽', '경기');
SELECT * FROM memberTBL;

INSERT IGNORE INTO memberTBL VALUES('BBK', '비비코', '미국');
INSERT IGNORE INTO memberTBL VALUES('SJH', '서장훈', '서울');
INSERT IGNORE INTO memberTBL VALUES('HJY', '현주엽', '경기');
SELECT * FROM memberTBL;

## 에러 발생 체크 해보기
INSERT INTO memberTBL VALUES('BBK', '비비코', '미국');
	ON DUPLICATE KEY UPDATE name='비비코', addr='미국';
INSERT INTO memberTBL VALUES('DJM', '동짜몽', '일본');
	ON DUPLICATE KEY UPDATE name='동짜몽', addr='일본';
SELECT * FROM memberTBL;




## WITH절과 CTE

WITH  CTE_테이블이름(열 이름)
AS
(
    <쿼리문>
)
SELECT 열 이름 FROM CTE_테이블이름 ;






SELECT userID AS '사용자 아이디', SUM(price * amount) AS '총 구매액' 
    FROM buytbl GROUP BY userID;


SELECT * FROM abc ORDER BY 총구매액 DESC


-- 총구매액이 큰 테이터부터 정렬

WITH abc(userid, total)
AS
(SELECT userid, SUM(price*amount)
	FROM buytbl GROUP BY userid )
SELECT * FROM abc ORDER BY total DESC ;


# 1
SELECT addr, MAX(height) FROM usertbl GROUP BY addr

# 2
WITH cte_userTBL(addr, maxHeight)
AS
	( SELECT addr, MAX(height) FROM usertbl GROUP BY addr)
    
# 3
SELECT AVG(키) FROM CTE_테이블이름

# 2+3
WITH cte_userTBL(addr, maxHeight)
AS
	( SELECT addr, MAX(height) FROM usertbl GROUP BY addr)
SELECT AVG(maxHeight*1.0) AS '각 지역별 최고키의 평균' FROM cte_usertbl;




###
WITH
AAA (컬럼들)
AS ( AAA의 쿼리문 ),
    BBB (컬럼들)
    AS ( BBB의 쿼리문 ),
        CCC (컬럼들)
        AS ( CCC의 쿼리문 )
SELECT * FROM [AAA 또는 BBB 또는 CCC]



### 숫자 데이터 형식

데이터형식 / 바이트 수 / 숫자 범위 / 설명
SMALLINT / 2 / -32768 ~ 32767 / 정수
INT INTEGER / 4 / 약-21억 ~ +21억 / 정수
BIGINT / 8 / 약 -900경~ +900경 / 정수
FLOAT / 4 / -3.40E+38 ~ -1.79E-38 / 소수점 아래 7자리까지 표현
DECIMAL(m.[d]) / 5~17 / -10^38+1 ~ +10^30-1 / 전체 자릴수(m)와 소수점 이하 자릴수(d)를 가진 숫자형
NUMERIC(m.[d]) 예) decimal(5.2)는 전체 자릴수를 5자리로 하되, 그 중 소수점 이하를 2자리로 하겠다는 의미이다



### 문자 데이터 형식
데이터 형식 / 바이트 수 / 설명
CHAR(n) / 1~255 / 고정길이 문자형 n을 1부터 255까지 지정 character의 약자. 
VARCHAR(n) / 1~65535 / 가변길이 문자형. n을 사용하면 1부터 65535까지 지정. Variable character의 약자.
LONGTEXT / 1~4294967295 / 최대 4GB 크기의 TEXT 데이터 값
LONGBLOB / 1~4294967295 / 최대 4GB 크기의 BLOB 데이터 값



### 날짜와 시간 데이터 형식

데이터형식 / 바이트 수 / 설명
DATE / 3 / 날짜는 1001-01-01 ~ 999-12-31까지 저장되며 날짜 형식만 사용 'YYYY-MM-DD'형식으로 사용
DATETIME / 8 / 날짜는 1001-01-01 00:00:00 ~ 9999-12-31 23:59:59까지 저장되며 형식은 'YYYY-MM-DD HH:MM:SS'형식으로 사용 time_zone 시스템 변수와 관련이 있으며 UTC 시간대 변화하여 저장


SELECT CAST('2020-10-29 12:35:29.123' AS DATE) AS 'DATE' ;
SELECT CAST('2020-10-29 12:35:29.123' AS TIME) AS 'TIME' ;
SELECT CAST('2020-10-29 12:35:29.123' AS DATETIME) AS 'DATETIME' ;



### 기타 데이터 형식
GEOMETRY / N/A / 공간 데이터 형식으로 선, 점 및 다각형 같은 공간 데이터 개체를 저장하고 조작
JSON / 8 / JSON(JavaScript Object Notation) 문서를 저장


USE sqldb;

SET @myVar1 = 5 ;
SET @myVar2 = 3 ;
SET @myVar3 = 4.25 ;
SET @myVar4 = '가수 이름==>' ;

SELECT @myVar1 ;
SELECT @myVar2 + @myVar3 ;

SELECT @myVar4 , Name FROM usertbl WHERE height > 180 ;






SET @myVar1 = 3 ;
PREPARE myQuery
	FROM 'SELECT Name, height FROM usertbl ORDER BY height LIMIT ?' ;
EXECUTE myQuery USING @myVar1 ;


PREPARE 쿼리이름 FROM '쿼리문'은 쿼리이름에 '쿼리문'을 준비만 해놓고 실행하지 않는다.
EXECUTE 쿼리이름을 만나는 순간 실행한다.

EXECUTE는 USING @변수를 이용해서 '쿼리문'에서 ?으로 처리해 놓은 부분에 대입된다.
결국  LIMIT @변수 형식으로 사용된 것과 동일한 효과를 갖는다.



### 데이터 형식과 형 변환
## 데이터 형식 변환 함수

CAST(), CONVERT()

CAST ( expression AS 데이터형식 [ (길이) ] )
CONVERT ( expression, 데이터형식 [ (길이) ] )


# 가능한 데이터 형식
BINARY, CHAR, DATE, DATETIME, DECIMAL, JSON, SIGNED INTEGER, TIME, USINGNED INTEGER

USE sqldb ;
SELECT AVG(amount) AS '평균 구매 개수' FROM buytbl ;



SELECT CAST(AVG(amount) AS SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl ;
또는
SELECT CONVERT(AVG(amount) , SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl ;


SELECT num, CONCAT(CAST(price AS CHAR(10)), 'X' , CAST(amount AS CHAR(4)) , '=' ) AS '단가X수량',
        price*amount AS '구매액'
    FROM buytbl ;




### MySQL 내장 함수
## 제어 흐름 함수

IF(수식, 참, 거짓)
수식이 참 또는 거짓인지 결과에 따라서 2중 분기한다.
SELECT IF (100>200, '참이다', '거짓이다');

IFNULL(수식1, 수식2)
수식1이 NULL이 아니면 수식1이 반환되고, 수식1이 NULL이면 수식2가 반환된다.
SELECT IFNULL(NULL, '널이군요'), IFNULL(100, '널이군요');

NULLIF(수식1, 수식2)
수식1과 수식2가 같으면 NULL을 반환하고, 다르면 수식1을 반환한다.
SELECT NULLIF(100,100), NULLIF(200,100);


### CASE ~ WHEN ~ ELSE ~ END
SELECT CASE 10
        WHEN 1 THEN '일'
        WHEN 2 THEN '오'
        WHEN 10 THEN '십'
        ELSE '모름'
    END AS 'CASE연습' ;



### 문자열 함수

## ASCII(아스키 코드), CHAR(숫자)
문자의 아스키 코드값을 돌려주거나 숫자의 아스키 코드값에 해당하는 문자를 돌려준다.

SELECT ASCII('A'), CHAR(65);
-- 65와 A를 돌려준다.


BIT_LENGTH(문자열), CHAR_LENGTH(문자열), LENGTH(문자열)

SELECT BIT_LENGTH('abc'), CHAR_LENGTH('abc'), LENGTH('abc');
SELECT BIT_LENGTH('가나다'), CHAR_LENGTH('가나다'), LENGTH('가나다');

-- 영문 3Byte, 한글 3*3=9Byte


CONCAT(문자열1, 문자열2, ...), CONCAT_WS(구분자, 문자열1, 문자열2, ...)

SELECT CONCAT_WS('/', '2025', '01', '01');

-- 2025/01/01


###
ELT(위치, 문자열1, 문자열2, ···), FIELD(찾을 문자열, 문자열1, 문자열2, ···), 
FIND_IN_SET(찾을 문자열, 문자열 리스트), INSTR(기준 문자열, 부분 문자열), 
LOCATE(부분 문자열, 기준 문자열)



SELECT ELT(2, '하나', '둘', '셋'), FIELD('둘', '하나', '둘', '셋'), 
FIND_IN_SET('둘', '하나,둘,셋'), INSTR('하나둘셋', '둘'), 
LOCATE('둘', '하나둘셋')



## FORMAT(숫자, 소수점 자릿수)
숫자를 소수점 아래 자릿수까지 표현한다.
또한 1000 단위마다 콤마(,)를 표시해 준다.

SELECT FORMAT(123456.123456, 4);


## BIN(숫자), HEX(숫자), OCT(숫자)
2진수, 16진수, 8진수의 값을 반환한다.

SELECT BIN(31), HEX(31), OCT(31);


## INSERT(기준 문자열, 위치, 길이, 삽입할 문자열)
기준 문자열의 위치부터 길이만큼을 지우고 삽입할 문자열을 끼워 넣는다.

SELECT INSERT('abcdefghi', 3, 4, '@@@@'), INSERT('abcedfghi', 3, 2, '@@@@');


## LEFT(문자열, 길이), RIGHT(문자열, 길이)
왼쪽 또는 오른쪽에서 문자열의 길이만큼 반환한다.

SELECT LEFT('abcdefghi', 3), RIGHT('abcedfghi', 3);


## UPPER(문자열), LOWER(문자열)
소문자를 대문자로, 대문자를 소문자로 변경한다.

SELECT LOWER('abcdEFGH), UPPER(abcdEFGH);

## LPAD(문자열, 길이, 채울 문자열), RPAD(문자열, 길이, 채울 문자열)
문자열을 길이만큼 늘린 후에, 빈 곳을 채울 문자열로 채운다.

SELECT LPAD('이것이', S, '##'), RPAD('이것이', S, '##');


## LTRIM(문자열), RTRIM(문자열)
문자열의 왼쪽/오른쪽 공백을 제거한다. 중간의 공백은 제거되지 않는다.

SELECT LTRIM('    이것이'), RTRIM('이것이     ');

## TRIM(문자열), TRIM(방향 자를_문자열 FROM 문자열)
TRIM(문자열)은 문자열의 앞뒤 공백을 모두 없앤다. TRIM(방향 자를_문자열 FROM 문자열)에서 방향은 LEADING(앞), BOTH(양쪽), TRAILING(뒤)가 나올 수 있다.

## REPEAT(문자열, 횟수)
문자열을 횟수만큼 반복한다.

SELECT REPEAT('이것이', 3);

## REPLACE(문자열, 원래 문자열, 바꿀 문자열)
문자열에서 원래 문자열을 찾아서 바꿀 문자열로 바꿔 준다.

SELECT REPLACE('이것이 MySQL이다', '이것이', 'This is');

## REVERSE(문자열)
문자열의 순서를 거꾸로 만든다.

SELECT REVERSE ('MySQL');

## SPACE(길이)
길이만큼의 공백을 반환한다.

SELECT CONCAT('이것이', SPACE(10), 'MySQL이다');

## SUBSTRING(문자열, 시작위치, 길이) 또는 SUBSTRING(문자열 FROM 시작위치 FOR 길이)
시작 위치부터 길이만큼 문자를 반환한다. 길이가 생략되면 문자열의 끝까지 반환한다.

SELECT SUBSTRING('대한민국만세', 3, 2);

## SUBSTRING_INDEX(문자열, 구분자, 횟수)
문자열에서 구분자가 왼쪽부터 횟수 번째 나오면 그 이후의 오른쪽은 버린다.
횟수가 음수면 오른쪽부터 세고 왼쪽을 버린다.

SELECT SUBSTRING_INDEX('cafe.naver.com', '.', 2), SUBSTRING_INDEX('cafe.naver.com', '.', -2);
-- 두번재 점 우측 버림, 오른쪽에서 두번째 점 왼쪽 버림






### 수학 함수

## ABS(숫자)
숫자의 절댓값을 계산한다.

SELECT ABS(-100);

## ACOS(숫자), ASIN(숫자), ATAN(숫자), ATAN2(숫자1, 숫자2), SIN(숫자), COS(숫자), TAN(숫자)
삼각 함수와 관련된 함수를 제공한다.

## CEILING(숫자), FLOOR(숫자), ROUND(숫자)
올림, 내림, 반올림을 계산한다.

SELECT CEILING(4.7), FLOOR(4.7), ROUND(4.7);

-- CELING(), CEIL()은 동일한 함수다.

## CONV(숫자, 원래 진수, 변환할 진수)
숫자를 원래 진수에서 변환할 진수로 계산한다.

SELECT CONV('AA', 16, 2), CONV(100, 10, 8);
16진수 AA를 2진수로 변환한 10101010과 100을 8진수로 변환한 144가 반환된다.

## DEGREES(숫자), RADIANS(숫자), PI()
라디안 값을 각도값으로, 각도값을 라디안 값으로 변환한다.
PI()는 파이값인 3.141592를 반환한다.

SELECT DEGREES(PI()), RADIANS(180);
180 / 3.141592653589793


## EXP(X), LN(숫자), LOG(숫자), LOG(밑수, 숫자), LOG2(숫자), LOG10(숫자)
지수, 로그와 관련된 함수를 제공한다.

## MOD(숫자1, 숫자2) 또는 숫자1 % 숫자2 또는 숫자1 MOD 숫자2
숫자1을 숫자2로 나눈 나머지 값을 구한다.

SELECT MOD(157, 10), 157 % 10, 157 MOD 10;
모두 157을 10으로 나눈 나머지 값 7을 반환한다.

## POW(숫자1, 숫자2), SQRT(숫자)
거듭제곱값 및 제곱근을 구한다.

SELECT POW(2,3), SQRT(9);
2의 3제곱과 루트9의 값을 반환한다.

POW()와 POWER()는 동일한 함수다.

## RAND()
RAND()는 0이상 1미만의 실수를 구한다.
만약 'm<= 임의의 정수 <n'를 구하고 싶다면 FLOOR (m + (RAND() * (n-m)))을 사용하면 된다.

SELECT RAND(), FLOOR(1 + (RAND() * (7-1)) );

0~1 미만의 실수와 주사위 숫자를 구한다.


## SIGN(숫자)
숫자가 양수, 0, 음수인지를 구한다. 결과는 1,0,-1 셋중에 하나를 반환한다.

SELECT SIGN(100), SIGN(0), SIGN(-100.123);

## TRUNCATE(숫자, 정수)
숫자를 소수점을 기준으로 정수 위치까지 구하고 나머지는 버린다.

SELECT TRUNCATE(12345.12345, 2), TRUNCATE(12345.12345, -2);

12345.12와 12300을 반환한다.



### 날짜 및 시간 함수

## ADDDATE(날짜, 차이), SUBDATE(날짜, 차이)
날짜를 기준으로 차이를 더하거나 뺀 날짜를 구한다.

SELECT ADDDATE('2025-01-01', INTERVAL 31 DAY), ADDDATE('2025-01-01', INTERVAL 1 MONTH);
SELECT SUBDATE('2025-01-01', INTERVAL 31 DAY), SUBDATE('2025-01-01', INTERVAL 1 MONTH);

# 동일한 함수
ADDDATE() = DATE_ADD()
SUBDATE() = DATE_SUB()


## ADDTIME(날짜/시간, 시간), SUBTIME(날짜/시간, 시간)
SELECT ADDTIME('2025-01-01 23:59:59', '1:1:1'), ADDTIME('15:00:00, '2:10:10');
SELECT SUBTIME('2025-01-01 23:59:59', '1:1:1'), SUBTIME('15:00:00, '2:10:10');

## CURDATE(), CURTIME(), NOW(), SYSDATE()

CURDATE() -- 현재 연-월-일
CURTIME() -- 현재 시:분:초
NOW() -- 현재 연-월-일 시:분:초
SYSDATE() -- 현재 연-월-일 시:분:초


## YEAR(날짜), MONTH(날짜), DAY(날짜), HOUR(시간), MINUTE(시간), SECOND(시간), MICROSECOND(시간)

날짜 또는 시간에서 연,월,일,시,분,초,밀리초를 구한다.

SELECT YEAR(CURDATE()), MONTH(CURDATE()), DAYOFMONTH(CURDATE());
SELECT HOUR(CURTIME()), MINUTE(CURRENT_TIME()), SECOND(CURRENT_TIME), MICROSECOND(CURRENT_TIME);


## DATE(), TIME()

SELECT DATE(NOW()), TIME(NOW());


## DATEDIFF(날짜1, 날짜2), TIMEDIFF(날짜1 또는 시간1, 날짜1 또는 시간2)

SELECT DATEDIFF('2025-01-01', NOW()), TIMEDIFF('23:23:59', '12:11:10');

## DAYOFWEEK(날짜), MONTHNAME(), DAYOFYEAR(날짜)
요일(1:일, 2:월~7:토) 및 1년 중 몇번째 날짜인지를 구한다.

SELECT DAYOFWEEK(CURDATE()), MONTHNAME(CURDATE()), DAYOFYEAR(CURDATE());
4, August, 227

## LAST_DAY(날짜)
주어진 날짜의 마지막 날짜를 구한다. 주로 그 달이 몇 일까지 있는지 확인할 때 사용한다.

SELECT LAST_DAY('2025-02-01');

## MAKEDATE(연도, 정수)
연도에서 정수만큼 지난 날짜를 구한다.

SELECT MAKEDATE(2025, 32);

## MAKETIME(시, 분, 초)
시분초를 이용해서 '시:분:초'의 TIME 형식을 만든다.

SELECT MAKETIME(12, 11, 10);

## PERIOD_ADD(연월, 개월수), PERIOD_DIFF(연월1, 연월2)
연월에서 개월만큼의 개월이 지난 연월을 구한다.
연월1 ~ 연월2의 개월수를 구한다.

SELECT PERIOD_ADD(202501, 11), PERIOD_DIFF(202401, 202312);

## QUARTER(날짜)
날짜가 4분기 중에서 몇 분기인지를 구한다.

SELECT QUARTER('2025-07-07');

## TIME_TO_SEC(시간)
시간을 초 단위로 구한다.

SELECT TIME_TO_SEC('12:11:10');




### 시스템 정보 함수

## USER(), DATABASE()
현재 사용자 및 현재 선택된 데이터베이스를 구한다.

SELECT CURRENT_USER(), DATABASE();

USER(), SESSION_USER(), CURRENT_USER() -- 동일
DATABASE(), SCHEMA() -- 동일


## FOUND_ROWS()

USE sqldb;
SELECT * FORM usertbl;
SELECT FOUND_ROWS();

## ROW_COUNT()
바로 앞의 INSERT, UPDATE, DELETE문에서 입력, 수정, 삭제된 행의 개수를 구한다.
CREATE, DROP문은 0을 반환하고, SELECT문은 -1을 반환한다.

USE sqldb;
UPDATE buytbl SET price=price*2;
SELECT ROW_COUNT();

## VERSION()
현재 MySQL의 버전을 구한다.

SELECT VERSION();

## SLEEP(초)
쿼리의 실행을 잠깐 멈춘다.

SELECT SLEEP(5);
SELECT '5초후에 이게 보여요';


### 7-2

CREATE DATABASE moviedb;

USE moviedb;
CREATE TABLE movietbl
    (movie_id   INT,
    movie_title VARCHAR(30),
    movie_director  VARCHAR(20),
    movie_star  VARCHAR(20),
    movie_script    LONGTEXT,
    movie_film  LONGBLOB
    ) DEFAULT CHARSET=utf8mb4;


INSERT INTO movietbl VALUES ( 1, '쉰들러 리스트', '스필버그', '리암 니슨',
    LOAD_FILE('C:/SQL/Movies/Schindler/txt'), LOAD_FILE('C:/SQL/Movies/Schindler.mp4')
    );


최대 패킷 크기(=최대 파일 크기)가 설정된 시스템 변수인  max_allowed_packet 값을 조회해 보자.

SHOW variables LIKE 'max_allowed_packet';

파일을 업로드/다운로드할 폴더 경로를 별도로 허용해 줘야만 한다.
시스템 변수인 secure_file_priv값을 조회해 보자.

SHOW variables LIKE 'secure_file_priv';



CD %PROGRAMDATA%
CD MySQL
CD "MySQL Server 8.0"
DIR 


## CMD에서 실행
-- 재실행
NET STOP MySQL
NET START MySQL


USE moviedb;
TRUNCATE movietbl;

INSERT INTO movietbl VALUES ( 1, '쉰들러 리스트', '스필버그', '리암 니슨',
    LOAD_FILE('C:/SQL/Movies/Schindler.txt'), LOAD_FILE('C:/SQL/Movies/Schindler.mp4')
);
INSERT INTO movietbl VALUES ( 2, '쇼생크 탈출', '프랭크 다라본트', '팀 로빈스',
    LOAD_FILE('C:/SQL/Movies/Shawshank.txt'), LOAD_FILE('C:/SQL/Movies/Shawshank.mp4')
);
INSERT INTO movietbl VALUES ( 3, '라스트 모히칸', '마이클 만', '다니엘 데이 루이스',
    LOAD_FILE('C:/SQL/Movies/Mohican.txt'), LOAD_FILE('C:/SQL/Movies/Mohican.mp4')
);

SELECT * FROM movietbl;


## 입력된 데이터를 파일로 내려받기 해보자.

LONGTEXT 형식의 영화 대본은 INTO OUTFILE문을 사용하면 텍스트 파일로 내려 받을수 있다.

SELECT movie_script FROM movietbl WHERE movie_id=1
    INTO OUTFILE 'C:/SQL/Movies/Schindler_out.txt'
    LINES TERMINATED BY '\\n';

-- C:/SQL/Movies에 파일이 생성 된다.


## LONGBLOB 형식의 영화 동영상은 INTO DUMPFILE문을 사용하면 바이너리 파일로 내려받을수 있다.

SELECT movie_film FROM movietbl WHERE movie_id=3
    INTO DUMPFILE 'C:/SQL/Movies/Mohican_out.mp4';


### 피벗의 구현

USE sqldb;
CREATE TABLE pivotTest
    ( uName CHAR(3),
    season CHAR(2),
    amount INT );

INSERT INTO pivotTest VALUES
    ('김범수', '겨울', 10), ('윤종신', '여름', 15), ('김범수', '가을', 25), 
    ('김범수', '봄', 3), ('김범수', '봄', 37), ('윤종신', '겨울', 40), 
    ('김범수', '여름', 14), ('김범수', '겨울', 22), ('윤종신', '여름', 64);
SELECT * FROM pivotTest;

SELECT uName,
    SUM(IF(season='봄', amount, 0)) AS '봄',
    SUM(IF(season='여름', amount, 0)) AS '여름',
    SUM(IF(season='가을', amount, 0)) AS '가을',
    SUM(IF(season='겨울', amount, 0)) AS '겨울',
    SUM(amount) AS '합계' FROM pivotTest GROUP BY uName ;




### JSON 데이터

USE sqldb;
SELECT JSON_OBJECT('name', name, 'height', height) AS 'JSON 값'
    FROM usertbl
    WHERE height >= 180;



####

SET @json='{ "usertbl" :
    [
        {"name": "임재범", "height": 182},
        {"name": "이승기", "height": 182},
        {"name": "성시경", "height": 186}
    ]
}' ;

SELECT JSON_VALID(@json) AS JSON_VALID;
SELECT JSON_SEARCH(@json, 'one', '성시경') AS JSON_SEARCH;
SELECT JSON_EXTRACT(@json, '$.usertbl[2].name') AS JSON_EXTRACT;
SELECT JSON_INSERT(@json, '$.usertbl[0].mDate', '2009-09-09') AS JSON_INSERT;
SELECT JSON_REPLACE(@json, '$.usertbl[0].name', '홍길동') AS JSON_REPLACE;
SELECT JSON_REMOVE(@json, '$.usertbl[0]') AS JSON_REMOVE;




### 조인

## INNER JOIN(내부 조인)

SELECT <열 목록>
FROM <첫 번째 테이블>
    INNER JOIN <두 번째 테이블>
    ON <조인될 조건>
[WHERE 검색조건]



USE sqldb;
SELECT *
FROM buytbl
    INNER JOIN usertbl
    ON buytbl.userID = usertbl.userID
WHERE buytbl.userID = 'JYP';

-- WHERE 의 결과값만 보여준다.



USE sqldb;
SELECT *
    FROM buytbl
        INNER JOIN usertbl
        ON buytbl.userID = usertbl.userID
    ORDER BY num;
-- 전체 데이터를 INNER JOIN 해서 보여준다.


SELECT userID, name, prodName, addr, CONCAT(mobile1, mobile2) AS '연락처'
    FROM buytbl
        INNER JOIN usertbl
            ON buytbl.userID = usertbl.userID
    ORDER BY num;

## 오류 발생 : userID >> buytbl.userID 수정

SELECT buytbl.userID, name, prodName, addr, CONCAT(mobile1, mobile2) AS '연락처'
    FROM buytbl
        INNER JOIN usertbl
            ON buytbl.userID = usertbl.userID
    ORDER BY num;



## 테이블에 별칭 주기. -- FROM절에 나오는 테이블의 이름 뒤에 별칭을 붙여준다.(조인에서 적극 사용)

SELECT B.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM buytbl B
        INNER JOIN usertbl U
            ON B.userID = U.userID
    ORDER BY B.num;


## JYP 사용자 
-- buytbl 기준

SELECT B.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM buytbl B
        INNER JOIN usertbl U
            ON B.userID = U.userID
    WHERE B.userID = 'JYP';


-- usrtbl 기준
SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM usertbl U
        INNER JOIN buytbl B
            ON U.userID = B.userID
    WHERE B.userID = 'JYP';



## 회원 전체가 나온다.

SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM usertbl U
        INNER JOIN buytbl B
            ON U.userID = B.userID
    ORDER BY U.userID;


## 구매한 기록이 있는 회원만 나온다.

SELECT DISTINCT U.userID, U.name, U.addr
    FROM usertbl U
        INNER JOIN buytbl B
            ON U.userID = B.userID
    ORDER BY U.userID;



## EXISTS문 사용

SELECT U.userID, U.name, U.addr
    FROM usertbl U
    WHERE EXISTS (
        SELECT *
        FROM buytbl B
        WHERE U.userID = B.userID );



## 세 개 테이블의 조인

USE sqldb;
CREATE TABLE stdTbl
( stdName   VARCHAR(10) NOT NULL PRIMARY KEY,
    addr    CHAR(4) NOT NULL
);
CREATE TABLE clubTbl
( clubName  VARCHAR(10) NOT NULL PRIMARY KEY,
    roomNo    CHAR(4) NOT NULL
);
CREATE TABLE stdclubTbl
( num int AUTO_INCREMENT NOT NULL PRIMARY KEY,
    stdName     VARCHAR(10) NOT NULL,
    clubName    VARCHAR(10) NOT NULL,
    FOREIGN KEY(stdName) REFERENCES stdTbl(stdName),
    FOREIGN KEY(clubName) REFERENCES clubtbl(clubName)
);
INSERT INTO stdtbl VALUES ('김범수', '경남'), ('성시경', '서울'), ('조용필', '경기'), ('은지원', '경북'), ('바비킴', '서울');
INSERT INTO clubtbl VALUES ('수영', '101호'), ('바둑', '102호'), ('축구', '103호'), ('봉사', '104호');
INSERT INTO stdclubtbl VALUES (NULL, '김범수', '바둑'), (NULL, '김범수', '축구'), (NULL, '조용필', '축구'), (NULL, '은지원', '축구'), (NULL, '은지원', '봉사'), (NULL, '바비킴', '봉사');






## 출력

SELECT S.stdName, S.addr, C.clubName, C.roomNo
    FROM stdtbl S
        INNER JOIN stdclubtbl SC
            ON S.stdName = SC.stdName
        INNER JOIN clubtbl C
            ON SC.clubName = C.clubName
    ORDER BY S.stdName;



## 동아리 기준

SELECT C.clubName, C.roomNo, S.stdName, S.addr
    FROM stdtbl S
        INNER JOIN stdclubtbl SC
            ON SC.stdName = S.stdName
        INNER JOIN clubtbl C
            ON SC.clubName = C.clubName
    ORDER BY C.clubName;




### OUTER JOIN (외부 조인)

SELECT <열 목록>
FROM <첫 번째 테이블(LEFT 테이블)>
    <LEFT : RIGHT : FULL> OUTER JOIN <두 번째 테이블(RIGHT 테이블)>
        ON <조인될 조건>
[WHERE 검색조건] ;





## 전체 회원 출력 및 미구매 회원도 함께 출력
-- LEFT OUTER JOIN / LEFT JOIN

SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, mobile2) AS '연락처'
    FROM usertbl U
        LEFT OUTER JOIN buytbl B
            ON U.userID = B.userID
    ORDER BY U.userID;


## RIGHT OUTER JOIN

SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, mobile2) AS '연락처'
    FROM buytbl B
        RIGHT OUTER JOIN usertbl U
            ON U.userID = B.userID
    ORDER BY U.userID;


## 유령회원 출력

SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, mobile2) AS '연락처'
    FROM usertbl U
        LEFT OUTER JOIN buytbl B
            ON U.userID = B.userID
    WHERE B.prodName IS NULL
    ORDER BY U.userID;


## 에러 발생 FULL 다시 수정 할것 ##########################
SELECT U.userID, U.name, B.prodName, U.addr, CONCAT(U.mobile1, mobile2) AS '연락처'
    FROM usertbl U
        FULL OUTER JOIN buytbl B
            ON U.userID = B.userID
    ORDER BY U.userID;


## 

USE sqldb;
SELECT S.stdName, S.addr, C.clubName, C.roomNo
    FROM stdtbl S
        LEFT OUTER JOIN stdclubtbl SC
            ON s.stdName = SC.stdName
        LEFT OUTER JOIN clubtbl C
            ON SC.clubName = C.clubName
    ORDER BY S.stdName;




USE sqldb;
SELECT C.clubName, C.roomNo, S.stdName, S.addr
    FROM stdtbl S
        LEFT OUTER JOIN stdclubtbl SC
            ON SC.stdName = S.stdName
        RIGHT OUTER JOIN clubtbl C
            ON SC.clubName = C.clubName
    ORDER BY C.clubName;




SELECT S.stdName, S.addr, C.clubName, C.roomNo
    FROM stdtbl S
        LEFT OUTER JOIN stdclubtbl SC
            ON s.stdName = SC.stdName
        LEFT OUTER JOIN clubtbl C
            ON SC.clubName = C.clubName
UNION
SELECT C.clubName, C.roomNo, S.stdName, S.addr
    FROM stdtbl S
        LEFT OUTER JOIN stdclubtbl SC
            ON SC.stdName = S.stdName
        RIGHT OUTER JOIN clubtbl C
            ON SC.clubName = C.clubName;



### CROSS JOIN(상호 조인)

USE sqldb;
SELECT *
    FROM buytbl
        CROSS JOIN usertbl;


USE employees;
SELECT COUNT(*) AS '데이터개수'
    FROM employees
        CROSS JOIN titles;



### SELF JOIN(자체 조인)

USE sqldb;
CREATE TABLE empTbl (emp CHAR(3), manager CHAR(3), empTel VARCHAR(8));

INSERT INTO empTbl VALUES('나사장', NULL, '0000');
INSERT INTO empTbl VALUES('김재무', '나사장', '2222');
INSERT INTO empTbl VALUES('김부장', '김재무', '2222-1');
INSERT INTO empTbl VALUES('이부장', '김재무', '2222-2');
INSERT INTO empTbl VALUES('우대리', '이부장', '2222-2-1');
INSERT INTO empTbl VALUES('지사원', '이부장', '2222-2-2');
INSERT INTO empTbl VALUES('이영업', '나사장', '1111');
INSERT INTO empTbl VALUES('한과장', '이영업', '1111-1');
INSERT INTO empTbl VALUES('최정보', '나사장', '3333');
INSERT INTO empTbl VALUES('윤차장', '최정보', '3333-1');
INSERT INTO empTbl VALUES('이주임', '윤차장', '3333-1-1');



SELECT A.emp AS '부하직원' , B.emp AS '직속상관', B.empTel AS '직속상관연락처'
    FROM empTbl A
        INNER JOIN empTbl B
            ON A.manager = B.emp
        WHERE A.emp = '우대리';




### UNION / UNION ALL / NOT IN / IN

-- UNION : 두 쿼리의 결과를 행으로 합친다.

SELECT 문장1
    UNION [ALL]
SELECT 문장2



USE sqldb;
SELECT stdName, addr FROM stdtbl
    UNION ALL
SELECT clubName, roomNo FROM clubtbl;


SELECT name, CONCAT(mobile1, mobile2) AS '전화번호' FROM usertbl
    WHERE name NOT IN ( SELECT name FROM usertbl WHERE mobile1 IS NULL);

-- 전화번호가 없는 사람은 제외하고 출력


SELECT name, CONCAT(mobile1, mobile2) AS '전화번호' FROM usertbl
    WHERE name IN ( SELECT name FROM usertbl WHERE mobile1 IS NULL);

-- 전화번호가 없는 사람만 출력



### SQL 프로그래밍

DELIMITER $$
CREATE PROCEDURE 스토어드 프로시저이름()
BEGIN

    이 부분에 SQL 프로그래밍 코딩...

END $$
DELIMITER ;
CALL 스토어드 프로시저이름();



## IF...ELSE
조건에 따라 분기한다. 한 문장 이상이 처리되어야 할 떄는 BEGIN... END와 함께 묶어줘야만 하며, 습관적으로 실행할 문장이 한 문장이라도 BEGIN...END로 묶어주는 것이 좋다.

형식:
IF <부울 표현식> THEN
    SQL문장들1..
ELSE
    SQL문장들2..
END IF;



DROP PROCEDURE IF EXISTS ifProc;
DELIMITER $$
CREATE PROCEDURE ifProc()
BEGIN
    DECLARE var1 INT;
    SET var1 = 100;

    IF var1 = 100 THEN
        SELECT '100입니다.';
    ELSE
        SELECT '100이 아닙니다.';
    END IF;
END $$
DELIMITER ;
CALL ifProc();





DROP PROCEDURE IF EXISTS ifProc2;
USE employees;

DELIMITER $$
CREATE PROCEDURE ifProc2()
BEGIN
    DECLARE hireDATE DATE;
    DECLARE curDATE DATE;
    DECLARE days INT;

    SELECT hire_date INTO hireDATE
        FROM employees.employees
        WHERE emp_no = 10001;

    SET curDATE = CURRENT_DATE();
    SET days = DATEDIFF(curDATE, hireDATE);
    
    IF (days/365) >= 5 THEN
        SELECT CONCAT('입사한지 ', days, '일이나 지났습니다. 축하합니다!');
    ELSE
        SELECT '입사한지 ' + days + '일밖에 안되었네요. 열심히 일하세요.' ;
    END IF;
END $$
DELIMITER ;
CALL ifProc2();




### CASE

## IF문

DROP PROCEDURE IF EXISTS ifProc3;
DELIMITER $$
CREATE PROCEDURE ifProc3()
BEGIN
    DECLARE point INT ;
    DECLARE credit CHAR(1);
    SET point = 77 ;
    
    IF point >= 90 THEN
        SET credit = 'A';
    ELSEIF point >= 80 THEN
        SET credit = 'B';
    ELSEIF point >= 70 THEN
        SET credit = 'C';
    ELSEIF point >= 60 THEN
        SET credit = 'D';
    ELSE
        SET credit = 'F';
    END IF;
    SELECT CONCAT('취득점수==>', point), CONCAT('학점==>', credit);
END $$
DELIMITER ;
CALL ifProc3();


## CASE문

DROP PROCEDURE IF EXISTS caseProc;
DELIMITER $$
CREATE PROCEDURE caseProc()
BEGIN
    DECLARE point INT ;
    DECLARE credit CHAR(1);
    SET point = 77 ;
    
    CASE
        WHEN point >= 90 THEN
            SET credit = 'A';
        WHEN point >= 80 THEN
            SET credit = 'B';
        WHEN point >= 70 THEN
            SET credit = 'C';
        WHEN oint >= 60 THEN
            SET credit = 'D';
        ELSE
            SET credit = 'F';
    END CASE;
    SELECT CONCAT('취득점수==>', point), CONCAT('학점==>', credit);
END $$
DELIMITER ;
CALL caseProc();






=================

USE sqldb;
SELECT userID, SUM(price*amount) AS '총구매액'
    FROM buytbl2
    GROUP BY userID
    ORDER BY SUM(price*amount) DESC;




DROP PROCEDURE IF EXISTS memberCost;
DELIMITER $$
CREATE PROCEDURE memberCost()
BEGIN
    DECLARE cost INT ;
    DECLARE credit CHAR(1);
    SET point = 77 ;
    
    CASE
        WHEN point >= 90 THEN
            SET credit = 'A';
        WHEN point >= 80 THEN
            SET credit = 'B';
        WHEN point >= 70 THEN
            SET credit = 'C';
        WHEN oint >= 60 THEN
            SET credit = 'D';
        ELSE
            SET credit = 'F';
    END CASE;
    SELECT CONCAT('취득점수==>', point), CONCAT('학점==>', credit);
END $$
DELIMITER ;
CALL caseProc();






USE sqldb;
SELECT userID, SUM(price*amount) AS '총구매액'
    FROM buytbl2
    GROUP BY userID
    ORDER BY SUM(price*amount) DESC;




USE sqldb;
SELECT B.userID, U.name, SUM(price*amount) AS '총구매액'
    FROM buytbl B
        INNER JOIN usertbl U
            ON B.userID = U.userID
    GROUP BY B.userID, U.name
    ORDER BY SUM(price*amount) DESC;



USE sqldb;
SELECT B.userID, U.name, SUM(price*amount) AS '총구매액'
    FROM buytbl B
        RIGHT OUTER JOIN usertbl U
            ON B.userID = U.userID
    GROUP BY B.userID, U.name
    ORDER BY SUM(price*amount) DESC;



SELECT U.userID, U.name, SUM(price*amount) AS '총구매액'
    FROM buytbl B
        RIGHT OUTER JOIN usertbl U
            ON B.userID = U.userID
    GROUP BY U.userID, U.name
    ORDER BY SUM(price*amount) DESC;



## CASE문

SELECT U.userID, U.name, SUM(price*amount) AS '총구매액',
        CASE
            WHEN (SUM(price*amount) >= 1500)  THEN '최우수고객'
            WHEN (SUM(price*amount) >= 1000)  THEN '우수고객'
            WHEN (SUM(price*amount) >= 1)  THEN '일반고객'
            ELSE '유령고객'
        END AS '고객등급'
    FROM buytbl B
        RIGHT OUTER JOIN usertbl U
            ON B.userID = U.userID
    GROUP BY U.userID, U.name
    ORDER BY SUM(price*amount) DESC;

-- SELECT AS 뒤 CASE 앞에 ',' 확인





### WHILE과 ITERATE/LEAVE

<부울 식>이 참인 동안에 계속 반복되는 반복문이다.

형식:
WHILE <부울 식> DO
    SQL 명령문들...
END WHILE;



DROP PROCEDURE IF EXISTS whileProc;
DELIMITER $$
CREATE PROCEDURE whileProc()
BEGIN
        DECLARE i INT;
        DECLARE hap INT;
    SET i = 1;
    SET hap = 0;

        WHILE (i <= 100) DO
            SET hap = hap + i;
            SET i = i +1;
        END WHILE;

        SELECT hap;
END $$
DELIMITER ;
CALL whileProc();






DROP PROCEDURE IF EXISTS whileProc2;
DELIMITER $$
CREATE PROCEDURE whileProc2()
BEGIN
        DECLARE i INT;
        DECLARE hap INT;
    SET i = 1;
    SET hap = 0;

myWhile: WHILE (i <= 100) DO
    IF (i%7 = 0) THEN
            SET i = i +1;
            ITERATE myWhile;
    END IF;
    
        SET hap = hap + i;
        IF (hap >1000) THEN
            LEAVE myWhile;
    END IF;
        SET i = i + 1;
    END WHILE;

    SELECT hap;
END $$
DELIMITER ;
CALL whileProc2();



### 오류 처리

DECLARE 액션 HANDLER FOR 오류조건 처리할_문장;



DROP PROCEDURE IF EXISTS errorProc;
DELIMITER $$
CREATE PROCEDURE errorProc()
BEGIN
    DECLARE CONTINUE HANDLER FOR 1146 SELECT '테이블이 없어요 ㅠㅠ' AS '메시지';
    SELECT * FROM noTable;
END $$
DELIMITER ;
CALL errorProc();


## 1146 대신 SQLSTATE'42S02'로 써줘도 된다. 둘다 테이블이 없을 경우를 의미한다.



DROP PROCEDURE IF EXISTS errorProc2;
DELIMITER $$
CREATE PROCEDURE errorProc2()
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SHOW ERRORS;
        SELECT '오류가 발생했네요. 작업은 취소시켰습니다.' AS '메시지';
        ROLLBACK;
    END;
    INSERT INTO usertbl VALUES('LSG', '이상구', 1988, '서울', NULL,
        NULL, 170, CURRENT_DATE());
END $$
DELIMITER ;
CALL errorProc2();



### 동적 SQL

PREPARE는 SQL문을 실행하지는 않고 미리 준비만 해놓고, 와 EXECUTE문은 준비한 쿼리문을 실행한다.
실행 후에는 DEALLOCATE PREFARE로 문장을 해제해 주는 것이 바람직하다.


use sqldb;
PREPARE myQuery FROM 'SELECT * FROM usertbl WHERE userID = "EJW"';
EXECUTE myQuery;
DEALLOCATE PREPARE myQuery;




use sqldb;
DROP TABLE IF EXISTS myTable;
CREATE TABLE myTable (id INT AUTO_INCREMENT PRIMARY KEY, mDate DATETIME);

SET @curDATE = CURRENT_TIMESTAMP();

PREPARE myQuery FROM 'INSERT INTO myTable VALUES(NULL, ?)';
EXECUTE myQuery USING @curDATE;
DEALLOCATE PREPARE myQuery;

SELECT * FROM myTable;

-- 쿼리를 실행하는 순간의 날짜와 시간이 입력되는 기능을 한다.




#### MySQL 고급 ####

## 테이블

# 테이블 만들기

-- MySQL Workbench에서 테이블 생성

DROP DATABASE IF EXISTS ShopDB;
DROP DATABASE IF EXISTS ModeDB;
DROP DATABASE IF EXISTS sqldb;
DROP DATABASE IF EXISTS tabledb;

CREATE DATABASE tabledb;

## usertbl 테이블 생성
CREATE TABLE `tabledb`.`usertbl` (
  `userID` CHAR(8) NOT NULL,
  `name` VARCHAR(10) NOT NULL,
  `birthYear` INT NOT NULL,
  `addr` CHAR(2) NOT NULL,
  `mobile1` CHAR(3) NULL,
  `mobile2` CHAR(8) NULL,
  `height` SMALLINT NULL,
  `mDate` DATE NULL,
  PRIMARY KEY (`userID`));



## buytbl 테이블 생성
CREATE TABLE `tabledb`.`buytbl` (
  `num` INT NOT NULL AUTO_INCREMENT,
  `userID` CHAR(8) NOT NULL,
  `prodName` CHAR(6) NOT NULL,
  `groupName` CHAR(4) NULL,
  `price` INT NOT NULL,
  `amount` SMALLINT NOT NULL,
  PRIMARY KEY (`num`),
  FOREIGN KEY (userID) REFERENCES usertbl(userID)
  );


INSERT INTO `tabledb`.`usertbl` (`userID`, `name`, `birthYear`, `addr`, `mobile1`, `mobile2`, `height`, `mDate`) VALUES ('KBS', '김범수', '1979', '경남', '011', '22222222', '173', '2012-04-04');
INSERT INTO `tabledb`.`usertbl` (`userID`, `name`, `birthYear`, `addr`, `mobile1`, `mobile2`, `height`, `mDate`) VALUES ('KKH', '김경호', '1971', '전남', '019', '3333333', '177', '2007-07-07');
INSERT INTO `tabledb`.`usertbl` (`userID`, `name`, `birthYear`, `addr`, `mobile1`, `mobile2`, `height`, `mDate`) VALUES ('LSG', '이승기', '1987', '서울', '011', '11111111', '182', '2008-08-08');



INSERT INTO `tabledb`.`buytbl` (`userID`, `prodName`, `price`, `amount`) VALUES ('KBS', '운동화', '30', '2');
INSERT INTO `tabledb`.`buytbl` (`userID`, `prodName`, `groupName`, `price`, `amount`) VALUES ('KBS', '노트북', '전자', '1000', '1');



SQL로 테이블 생성

-- MySQL 도움말에 나오는 테이블을 생성하는 기본적인 형식은 다음과 같다.

형식 :
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    col_name column_definition
    : {INDEX:KEY} [index_name] [index_type] (key_part,...)
        [index_option] ...
    : {FULLTEXT:SPATIAL} [INDEX:KEY] [index_name] (key_part,...)
        [index_option] ...
    : [CONSTRAINT [symbol]] PRIMARY KEY
        [index_type] (key_part,...) 
        [index_option] ...
    :[CONSTRAINT [symbol]] UNIQUE [INDEX:KEY]
        [index_name] [index_type] (key_part,...)
        [index_option] ...
    : [CONSTRAINT [symbol]] FOREIGN KEY
        [index_name] (col_name,...)
        reference_definition
    : check_constraint_definition

column_definition:
    data_type [NOT NULL : NULL] [DEFAULT {literal : (expr)} ]
    [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
    [COMMENT 'string']
    [COLLATE collation_name]
    [COLLATE_FORMAT {FIXED:DYNAMIC:DEFAULT}]
    [STORAGE {DISK:MEMORY}]
    [reference_definition]
    [check_constraint_definition]
: data_type
    [COLLATE collation_name]
    [GENERATED ALWQYS] AS (expr)
    [VIRTUAL : STORED] [NOT NULL : NULL]
    [UNIQUE [KEY]] [[PRIMARY] KEY]
    [COMMENT 'string']
    [reference_definition]
    [check_constraint_definition]





### 

CREATE TABLE test (num INT);

### SQL을 이용해서 테이블을 생성하자.

DROP DATABASE tabledb;
CREATE DATABASE tabledb;


USE tabledb;
DROP TABLE IF EXISTS buytbl, usertbl;
CREATE TABLE usertbl
( userID CHAR(8),
    name VARCHAR(10),
    birthYear INT,
    addr CHAR(2),
    mobile1 CHAR(3),
    mobile2 CHAR(8),
    height SMALLINT,
    mDate DATE
);
CREATE TABLE buytbl
(   num INT,
    userid CHAR(8),
    prodName CHAR(6),
    groupName CHAR(4),
    price INT,
    amount SMALLINT
);


### ==== 추가 옵션을 줘서 테이블 생성

USE tabledb;
DROP TABLE IF EXISTS buytbl, usertbl;
CREATE TABLE usertbl
( userID CHAR(8) NOT NULL PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL,
    addr CHAR(2) NOT NULL,
    mobile1 CHAR(3) NULL,
    mobile2 CHAR(8) NULL,
    height SMALLINT NULL,
    mDate DATE NULL
);
CREATE TABLE buytbl
(   num INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    userid CHAR(8) NOT NULL,
    prodName CHAR(6) NOT NULL,
    groupName CHAR(4) NULL,
    price INT NOT NULL,
    amount SMALLINT NOT NULL
    , FOREIGN KEY(userid) REFERENCES usertbl(userID)
);


## 8.1.2 제약 조건

MySQL은 데이터의 무결성을 위해서 5가지의 제약 조건을 제공한다.

# PRIMARY KEY 제약 조건
# FOREIGN KEY
# UNIQUE 제약 조건
# CHECK 제약 조건
# DEFAULT 정의
# NULL 값 허용


## 기본 키 제약 조건

-- 테이블의 정보를 보기 위해서 DESCRIBE문을 사용

DESCRIBE usertbl;




DROP TABLE IF EXISTS userTBL;
CREATE TABLE userTBL
( userID CHAR(8) NOT NULL,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL,
    CONSTRAINT PRIMARY KEY PK_userTBL_userID (userID)
);




# SHOW KEYS FROM 테이블이름
-- 테이블에 지정된 키 열람

SHOW KEYS FROM usertbl;


-- 이미 만들어진 테이블을 수정하는 ALTER TABLE 구문을 사용할 수 있다.
DROP TABLE IF EXISTS userTBL;
CREATE TABLE userTBL
( userID CHAR(8) NOT NULL,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL
);
ALTER TABLE ueserTBL
    ADD CONSTRAINT PK_userTBL_userID
        PRIMARY KEY (userID);


## 기본키를 설정 할수 없을 때 두개 이상의 COLUMN을 합쳐서 기본키를 만들자.

DROP TABLE IF EXISTS prodTbl;
CREATE TABLE prodTbl
(   prodCode CHAR(3) NOT NULL,
    prodID CHAR(4) NOT NULL,
    prodDate DATETIME NOT NULL,
    prodCur CHAR(10) NULL
);
ALTER TABLE prodTbl
    ADD CONSTRAINT PK_prodTbl_proCode_prodID
        PRIMARY KEY (prodCode, prodID) ;


## CREATE TABLE 구만 안에 직접 사용할 수도 있다.
마지막 열 이후에 콤마(,)로 분리하고 제약 조건을 직접 지정하면 된다.

DROP TABLE IF EXISTS prodTbl;
CREATE TABLE prodTbl
(   prodCode CHAR(3) NOT NULL,
    prodID CHAR(4) NOT NULL,
    prodDate DATETIME NOT NULL,
    prodCur CHAR(10) NULL,
    CONSTRAINT PK_prodTbl_proCode_prodID
        PRIMARY KEY (prodCode, prodID)
);


# SHOW INDEX FROM prodTbl문으로 테이블의 정보를 확인
SHOW INDEX FROM prodTbl;


## 외래 키 제약 조건
# Unique

-- 외래 키를 생성하는 방법은 CREATE TABLE 끝에 FOREIGN KEY 키워드로 설정하는 방법이 있다.

DROP TABLE IF EXISTS buyTBL, userTBL;
CREATE TABLE userTBL
( userID CHAR(8) NOT NULL PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL
);
CREATE TABLE buyTBL
(   num INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    userID CHAR(8) NOT NULL,
    prodName CHAR(6) NOT NULL,
    FOREIGN KEY(userID) REFERENCES userTBL(userID)
);

====
DROP TABLE IF EXISTS buyTBL;
CREATE TABLE buyTBL
(   num INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    userID CHAR(8) NOT NULL,
    prodName CHAR(6) NOT NULL,
    CONSTRAINT FK_userTBL_buyTBL FOREIGN KEY(userID) REFERENCES userTBL(userID)
);

===
DROP TABLE IF EXISTS buyTBL;
CREATE TABLE buyTBL
(   num INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    userID CHAR(8) NOT NULL,
    prodName CHAR(6) NOT NULL
);
ALTER TABLE buyTBL
    ADD CONSTRAINT FK_userTBL_buyTBL
    FOREIGN KEY (userID)
    REFERENCES userTBL(userID);


SHOW INDEX FROM buyTBL; -- 설정된 외래 키 제약 조건을 확인


## 외래 키 옵션
ON DELETE CASCADE
ON UPDATE CASCADE
-- 기준 테이블의 데이터가 변경되었을 떄 외래 키 테이블도 자동으로 적용되도록 설정

ALTER TABLE buytbl
    DROP FOREIGN KEY FK_userTBL_buyTBL;
ALTER TABLE buytbl
    ADD CONSTRAINT FK_userTBL_buyTBL
    FOREIGN KEY (userID)
    REFERENCES usertbl (userID)
    ON UPDATE CASCADE;

## ON UPDATE NO ACTION / ON DELETE NO ACTION
-- 별도로 지정하지 않으면 NO ACTION 과 동일 하다.



### UNIQUE 제약 조건

USE tableDB;
DROP TABLE IF EXISTS buyTBL, userTBL;
CREATE TABLE userTBL
(   userID  CHAR(8) NOT NULL PRIMARY KEY,
    name    VARCHAR(10) NOT NULL,
    birthYear   INT NOT NULL,
    email   CHAR(30) NULL UNIQUE
);
DROP TABLE IF EXISTS userTBL;
CREATE TABLE userTBL
(   userID  CHAR(8) NOT NULL PRIMARY KEY,
    name    VARCHAR(10) NOT NULL,
    birthYear   INT NOT NULL,
    email   CHAR(30) NULL,
    CONSTRAINT AK_email UNIQUE (email)
);


## 제약 조건의 이름을 지정할 때 일반적으로 Primary Key는 PK, Foreign Key는 FK, Unique는 AK를 주로 사용한다.
참고로 Unique는 Alternate key로도 부른다.


### CHECK 제약 조건

-- 출생년도가 1900년 이후 그리고 2023년 이전, 이름은 반드시 넣어야 함.
DROP TABLE IF EXISTS userTBL;
CREATE TABLE userTBL
(   userID  CHAR(8) PRIMARY KEY,
    name    VARCHAR(10),
    birthYear   INT CHECK (birthYear >= 1900 AND birthYear <= 2023),
    mobile1 CHAR(3) NULL,
    CONSTRAINT CK_name CHECK ( name IS NOT NULL)
);

-- 휴대폰 국번 체크
ALTER TABLE userTBL
    ADD CONSTRAINT CK_mobile1
    CHECK (mobile1 IN ('010', '011', '016', '017', '018', '019')) ;

## CHECK 제약 조건을 만들되 작동하지 않도록 하려면 제약 조건의 제일 뒤에 NOT ENFORCED구문을 추가
-- 거의 사용하는 경우가 없다.


### DEFAULT 정의

DEFAULT는 값을 입력하지 않았을 떄, 자동으로 입력되는 기본 값을 정의하는 방법이다.

DROP TABLE IF EXISTS usertbl;
CREATE TABLE usertbl
( userID CHAR(8) NOT NULL PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL DEFAULT -1,
    addr CHAR(2) NOT NULL DEFAULT '서울',
    mobile1 CHAR(3) NULL,
    mobile2 CHAR(8) NULL,
    height SMALLINT NULL DEFAULT 170,
    mDate DATE NULL,
);


# ALTER TABLE 사용 시에 열에 DEFAULT를 지정하기 위해서 ALTER COLUMN문을 사용 한다.

DROP TABLE IF EXISTS usertbl;
CREATE TABLE usertbl
(   userID  CHAR(8) NOT NULL PRIMARY KEY,
    name    VARCHAR(10) NOT NULL,
    birthYear   INT NOT NULL,
    addr    CHAR(2) NOT NULL,
    mobile1 CHAR(3) NULL,
    mobile2 CHAR(8) NULL,
    height  SMALLINT NULL,
    mDate   DATE NULL,
);
ALTER TABLE userTBL
    ALTER COLUMN birthYear SET DEFAULT -1;
ALTER TABLE userTBL
    ALTER COLUMN addr SET DEFAULT '서울';
ALTER TABLE userTBL
    ALTER COLUMN height SET DEFAULT 170;


# 디폴트가 설정된 열에는 다음과 같은 방법으로 데이터를 입력할 수있다.

-- default문은 DEFAULT로 설정된 값을 자동 입력한다.
INSERT INTO usertbl VALUES ('LHL', '이혜리', default, default, '011', '1234567', default, '2023.12.12');

-- 열 이름이 명시되지 않으면 DEFAULT로 설정된 값을 자동 입력한다.
INSERT INTO usertbl(userID, name) VALUES('KAY', '김아영');

-- 값이 직접 명기되면 DEFAULT로 설정된 값은 무시된다.
INSERT INTO usertbl VALUES ('WB', '원빈', 1982, '대전', '019', '9876543', 176, '2020.5.5');

SELECT * FROM usertbl;



### Null 값 허용
-- 고정 길이 문자형(CHAR)은 공간을 모두 차지, 가변 길이 문자형(VARCHAR)은 공간을 차지하지 않는다.

## 테이블 압축
CREATE DATABASE IF NOT EXISTS compressDB;
USE compressDB;
CREATE TABLE normalTBL( emp_no int, first_name VARCHAR(14));
CREATE TABLE compressTBL( emp_no int, first_name VARCHAR(14))
    ROW_FORMAT=COMPRESSED ;

-- 데이터 가져오기
INSERT INTO normalTBL
    SELECT emp_no, first_name FROM employees.employees;
INSERT INTO compressTBL
    SELECT emp_no, first_name FROM employees.employees;


SHOW TABLE STATUS FROM compressDB;



## 임시 테이블

CREATE TEMPORARY TABLE [IF NOT EXISTS] 테이블이름
( 열 정의 ... )

-- 임시 테이블은 이름처럼 임시로 잠깐 사용되는 테이블이다.
-- 임시 테이블은 세션 내에서만 존재하며, 세션이 닫히면 자동으로 삭제된다.
-- 생성한 클라이언트에서만 접근이 가능, 다른 클라이언트는 접근 불가.

-- 데이터베이스 내의 다른 테이블과 이름을 동일하게 만들수 있다. 임시테이블이 있는동안 기존의 테이블에 접근이 불가하다.
-- 접근성 : 임시 테이블 > 기존 테이블
-- 임시 테이블 생성시 기존의 테이블 이름을 사용하지 말자.

# 임시 테이블이 삭제되는 시점
-- 사용자가 DROP TABLE로 직접 삭제
-- Workbench를 종료하거나 mysql 클라이언트를 종료하면 삭제
-- MySQL 서비스가 재시작되면 삭제


USE employees;
CREATE TEMPORARY TABLE IF NOT EXISTS temptbl (id INT, name CHAR(5));
CREATE TEMPORARY TABLE IF NOT EXISTS employees (id INT, name CHAR(5));
DESCRIBE temptbl;
DESCRIBE employees;


INSERT INTO temptbl VALUES (1, 'This');
INSERT INTO employees VALUES (2, 'MySQL');
SELECT * FROM temptbl;
SELECT * FROM employees;


USE employees;
SELECT * FROM temptbl;
SELECT * FROM employees;

DROP TABLE temptbl;



## 테이블 삭제

DROP TABLE 테이블이름;

-- 외래 키 제약 조건의 기준 테이블은 삭제할 수가 없다.
-- 외래 키가 생성된 외래 키 테이블을 삭제해야 한다.

-- 여러 개의 테이블을 동시에 삭제하려면 
# DROP TABLE 테이블1, 테이블2, 테이블3;


## 테이블 수정

# ALTER TABLE
-- 이미 생성된 테이블에 무언인가를 추가/변경/수정/삭제하는 것은 모두 ALTER TABLE을 사용


ALTER TABLE tbl_name
    [alter_option [, alter_option] ...]
    [partition_options]

alter_option: {
    table_options
  | ADD [COLUMN] col_name column_definition
        [FIRST | AFTER col_name]
  | ADD [COLUMN] (col_name column_definition,...)
  | ADD {INDEX | KEY} [index_name]
        [index_type] (key_part,...) [index_option] ...
  | ADD {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name]
        (key_part,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]] PRIMARY KEY
        [index_type] (key_part,...)
        [index_option] ...
  | ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]
        [index_name] [index_type] (key_part,...)
        [index_option] ...
  | ADD [CONSTRAINT [symbol]] FOREIGN KEY
        [index_name] (col_name,...)
        reference_definition
  | ADD [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]
  | DROP {CHECK | CONSTRAINT} symbol
  | ALTER {CHECK | CONSTRAINT} symbol [NOT] ENFORCED
  | ALGORITHM [=] {DEFAULT | INSTANT | INPLACE | COPY}
  | ALTER [COLUMN] col_name {
        SET DEFAULT {literal | (expr)}
      | SET {VISIBLE | INVISIBLE}
      | DROP DEFAULT
    }
  | ALTER INDEX index_name {VISIBLE | INVISIBLE}
  | CHANGE [COLUMN] old_col_name new_col_name column_definition
        [FIRST | AFTER col_name]
  | [DEFAULT] CHARACTER SET [=] charset_name [COLLATE [=] collation_name]
  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]
  | {DISABLE | ENABLE} KEYS
  | {DISCARD | IMPORT} TABLESPACE
  | DROP [COLUMN] col_name
  | DROP {INDEX | KEY} index_name
  | DROP PRIMARY KEY
  | DROP FOREIGN KEY fk_symbol
  | FORCE
  | LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
  | MODIFY [COLUMN] col_name column_definition
        [FIRST | AFTER col_name]
  | ORDER BY col_name [, col_name] ...
  | RENAME COLUMN old_col_name TO new_col_name
  | RENAME {INDEX | KEY} old_index_name TO new_index_name
  | RENAME [TO | AS] new_tbl_name
  | {WITHOUT | WITH} VALIDATION
}


partition_options:
    partition_option [partition_option] ...

partition_option: {
    ADD PARTITION (partition_definition)
  | DROP PARTITION partition_names
  | DISCARD PARTITION {partition_names | ALL} TABLESPACE
  | IMPORT PARTITION {partition_names | ALL} TABLESPACE
  | TRUNCATE PARTITION {partition_names | ALL}
  | COALESCE PARTITION number
  | REORGANIZE PARTITION partition_names INTO (partition_definitions)
  | EXCHANGE PARTITION partition_name WITH TABLE tbl_name [{WITH | WITHOUT} VALIDATION]
  | ANALYZE PARTITION {partition_names | ALL}
  | CHECK PARTITION {partition_names | ALL}
  | OPTIMIZE PARTITION {partition_names | ALL}
  | REBUILD PARTITION {partition_names | ALL}
  | REPAIR PARTITION {partition_names | ALL}
  | REMOVE PARTITIONING
}

key_part: {col_name [(length)] | (expr)} [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option: {
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}
}

table_options:
    table_option [[,] table_option] ...

table_option: {
    AUTOEXTEND_SIZE [=] value
  | AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}
  | CONNECTION [=] 'connect_string'
  | {DATA | INDEX} DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] engine_name
  | ENGINE_ATTRIBUTE [=] 'string'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}
  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}
  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}
  | STATS_SAMPLE_PAGES [=] value
  | TABLESPACE tablespace_name [STORAGE {DISK | MEMORY}]
  | UNION [=] (tbl_name[,tbl_name]...)
}

partition_options:
    (see CREATE TABLE options)



## 열의 추가

USE tabledb;
ALTER TABLE usertbl
    ADD homepage VARCHAR(30) -- 열 추가
        DEFAULT 'http://www.hanbit.co.kr' -- 디폴트 값
        NULL; -- Null 허용함

-- ALTER 문 제일 뒤에 작성.
-- 기본적으로 가장 뒤 열에 추가 됨.
-- 'FIRST' : 제일 앞에 열이 추가.
-- 'AFTER 열 이름' : 열 이름 다음에 추가.


## 열의 삭제

ALTER TABLE usertbl
    DROP COLUMN mobile1;

-- 제약 조건이 있는 경우 제약 조건 먼저 삭제해야 함.


## 열의 이름 및 데이터 형식 변경

ALTER TABLE usertbl
    CHANGE COLUMN name uName VARCHAR(20) NULL ;

-- name을 uName으로 수정하고 VARCHAR(20), NULL 허용으로 수정


## 열의 제약 조건 추가 및 삭제

ALTER TABLE usertbl
    DROP PRIMARY KEY;

-- error 발생

ALTER TABLE buytbl
    DROP FOREIGN KEY buytbl_ibfk_1;

-- 외래 키의 이름은 [Navigator]에서 테이블 아래 'Foreign Keys'를 확장하면 확인할 수 있다.

### P.346 ~ P.354 까지 복습

## 실습5
# STEP 1

USE tabledb;
DROP TABLE IF EXISTS buytbl, usertbl;
CREATE TABLE usertbl
( userID CHAR(8),
    name VARCHAR(10),
    birthYear INT,
    addr CHAR(2),
    mobile1 CHAR(3),
    mobile2 CHAR(8),
    height SMALLINT,
    mDate DATE
);
CREATE TABLE buytbl
(   num INT,
    userid CHAR(8),
    prodName CHAR(6),
    groupName CHAR(4),
    price INT,
    amount SMALLINT
);



# STEP 2

INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울', '011', '1111111', 182, '2008-8-8');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남', '011', '2222222', 173, '2012-4-4');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남', '019', '3333333', 177, '2007-7-7');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기', '011', '4444444', 166, '2009-4-4');

INSERT INTO buytbl VALUES(NULL, 'KBS', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buytbl VALUES(NULL, 'JYP', '모니터', '전자', 200, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200, 5);




# STEP 3

ALTER TABLE usertbl
    ADD CONSTRAINT PK_usertbl_userID
    PRIMARY KEY (userID);

# 확인
DESC usertbl;




# STEP 4

외래 키 테이블의 buytbl의 userid에 외래 키를 설정하자.
기준테이블 usertbl의 userID를 기준으로 한다.

DELETE FROM buytbl WHERE userid = 'BBK';

ALTER TABLE buytbl
    ADD CONSTRAINT FK_usertbl_buytbl
    FOREIGN KEY (userID)
    REFERENCES usertbl (userID);




# 외래 키 제약 조건을 비활성화 시키고, 데이터를 모두 입력한 후에 다시 외래 키 제약 조건을 활성화 한다.

SET foreign_key_checks = 0;
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200, 5);
INSERT INTO buytbl VALUES(NULL, 'KBS', '청바지', '의류', 50, 3);
INSERT INTO buytbl VALUES(NULL, 'BBK', '메모리', '전자', 80, 10);
INSERT INTO buytbl VALUES(NULL, 'SSK', '책', '서적', 15, 5);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '청바지', '의류', 50, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);
SET foreign_key_checks = 1;




# STEP 5

-- CHECK 제약 조건을 설정

usertbl의 출생년도를 1990~2023까지만 입력되도록 하자. 또, NULL 값을 허용하지 말고 출생년도는 반드시 입력하도록 설정

ALTER TABLE userTBL
    ADD CONSTRAINT CK_birthYear
    CHECK ( (birthYear >= 1900 AND birthYear <= 2023) AND (birthYear IS NOT NULL) );

# Error 발생


UPDATE usertbl SET birthYear=1979 WHERE userID='KBS';
UPDATE usertbl SET birthYear=1971 WHERE userID='KKH';


# 출생년도가 잘못된 값을 입력. 출생년도에 오류가 있는 데이터는 입력되지 않는다.
INSERT INTO usertbl VALUES('TKV', '태권뷔', 2999, 우주, NULL, NULL, 186, '2023-12-12');

# 나머지 usertbl의 정상적인 데이터 입력
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울', NULL, NULL, 186, '2013-12-12');
INSERT INTO usertbl VALUES('LJB', '임재범', 1963, '서울', '016', '6666666', 182, '2009-9-9');
INSERT INTO usertbl VALUES('YJS', '윤종신', 1969, '경남', NULL, NULL, 170, '2005-5-5');
INSERT INTO usertbl VALUES('EJW', '은지원', 1972, '경북', '011', '8888888', 174, '2014-3-3');
INSERT INTO usertbl VALUES('JKW', '조관우', 1965, '경기', '018', '9999999', 172, '2010-10-10');
INSERT INTO usertbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');


# 바비킴 자신의 ID를 변경
UPDATE문으로 변경

UPDATE usertbl SET userID = 'VVK' WHERE userID='BBK';

# ERROR 발생
-- buytbl에 구매한 기록이 있으므로 변경 불가.
-- 제약 조건을 비활성화 후 변경 가능.

SET foreign_key_checks = 0;
UPDATE usertbl SET userID = 'VVK' WHERE userID='BBK';
SET foreign_key_checks = 1;


# 구매 테이블(buytbl)의 사용자에게 물품 배송을 위해서, 회원 테이블과 조인시켜 보자.
구매한 회원 아이디, 회원 이름, 구매한 제품, 주소, 연락처를 출력



### 중요 완전 이해 필요.....
SELECT B.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM buytbl B
        INNER JOIN usertbl U 
            ON B.userid = U.userid ;



SELECT COUNT(*) FROM buytbl;



SELECT B.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM buytbl B
        LEFT OUTER JOIN usertbl U 
            ON B.userid = U.userid
        ORDER BY B.userid ;

# 12건중 4건이 누락 되고 8건만 출력 되었다. BBK 이름을 VVK로 변경 했기 때문이다. 함부로 외래 키 제약 조건을 끊고 데이터를 수정하지 말자.


SET foreign_key_checks = 0;
UPDATE usertbl SET userID = 'BBK' WHERE userID='VVK';
SET foreign_key_checks = 1;


## 이러한 문제를 없애기 위해서 회원 테이블의 userID가 바뀔 떄 이와 관련되는 구매 테이블의 userID도 자동 변경되도록 하자.
-- 외래 키 제약 조건을 삭제한 후에 다시 ON UPDATE CASCADE 옵션과 함께 설정한다.

ALTER TABLE buytbl
    DROP FOREIGN KEY FK_usertbl_buytbl;
ALTER TABLE buytbl
    ADD CONSTRAINT FK_usertbl_buytbl
        FOREIGN KEY (userID)
        REFERENCES usertbl (userID)
        ON UPDATE CASCADE;

UPDATE usertbl SET userID = 'VVK' WHERE userID='BBK';

SELECT B.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM buytbl B
        INNER JOIN usertbl U 
            ON B.userid = U.userid
    ORDER BY B.userid;


# 바비킴이 회원을 탈되하면 구매한 기록도 삭제 되는지 확인하자.

DELETE FROM usertbl WHERE userID = 'VVK';

-- 외래 키 제약 조건 때문에 삭제되지 않는다.

# ON DELETE CASCADE

ALTER TABLE buytbl
    DROP FOREIGN KEY FK_usertbl_buytbl;
ALTER TABLE buytbl
    ADD CONSTRAINT FK_usertbl_buytbl
        FOREIGN KEY (userID)
        REFERENCES usertbl (userID)
        ON UPDATE CASCADE
        ON DELETE CASCADE;


DELETE FROM usertbl WHERE userID = 'VVK';
SELECT * FROM buytbl;


# usertbl에서 CHECK 제약 조건이 걸린 출생년도 열을 삭제하자.

ALTER TABLE usertbl
    DROP COLUMN birthYear ;







### 뷰
-- 뷰는 일반 사용자 입장에서는 테이블과 동일하게 사용하는 개체다.

## 뷰의 개념

SELECT userID, name, addr FROM usertbl문의 결과를 v_usertbl이라고 부른다.

USE tabledb;
CREATE VIEW v_usertbl
AS
    SELECT userid, name, addr FROM usertbl;

SELECT * FROM v_usertbl;



## 뷰의 장점

1. 보안에 도움이 된다.
2. 복잡한 쿼리를 단순화 시켜 줄 수 있다.

# 물건을 구매한 회원들에 대한 쿼리

SELECT U.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM usertbl U
        INNER JOIN buytbl B
            ON U.userid = B.userid ;

# 뷰를 생성해서 쉽게 접근할 수 있도록 하자.

CREATE VIEW v_userbuytbl
AS
SELECT U.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS '연락처'
    FROM usertbl U
        INNER JOIN buytbl B
            ON U.userid = B.userid ;


SELECT * FROM v_userbuytbl WHERE name = '김범수';


## sqldb 초기화 후 데이터 다시 불러오기

# file > Open SQL Script 해서 sql 파일을 불러와서 실행 적용

DROP DATABASE IF EXISTS sqldb;
create DATABASE sqldb;

use sqldb;
CREATE TABLE usertbl
( userID	char(8) not null primary key,
name	VARCHAR(10) NOT NULL,
birthYear	INT NOT NULL,
addr 	CHAR(2) NOT NULL,
mobile1	CHAR(3),
mobile2 CHAR(8),
height	SMALLINT,
mDate	DATE);
CREATE TABLE buytbl
( num	INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
userID CHAR(8) NOT NULL,
prodName CHAR(6) NOT NULL,
groupName	CHAR(4),
price	INT NOT NULL,
amount	INT NOT NULL,
FOREIGN KEY (userID) REFERENCES usertbl(userID)
);




-- 데이터 추가 입력

INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울', '011', '1111111', 182, '2008-8-8');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남', '011', '2222222', 173, '2012-4-4');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남', '019', '3333333', 177, '2007-7-7');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기', '011', '4444444', 166, '2009-4-4');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울', NULL, NULL, 186, '2013-12-12');
INSERT INTO usertbl VALUES('LJB', '임재범', 1963, '서울', '016', '6666666', 182, '2009-9-9');
INSERT INTO usertbl VALUES('YJS', '윤종신', 1969, '경남', NULL, NULL, 170, '2005-5-5');
INSERT INTO usertbl VALUES('EJW', '은지원', 1972, '경북', '011', '8888888', 174, '2014-3-3');
INSERT INTO usertbl VALUES('JKW', '조관우', 1965, '경기', '018', '9999999', 172, '2010-10-10');
INSERT INTO usertbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');

INSERT INTO buytbl VALUES(NULL, 'KBS', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buytbl VALUES(NULL, 'JYP', '모니터', '전자', 200, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200, 5);
INSERT INTO buytbl VALUES(NULL, 'KBS', '청바지', '의류', 50, 3);
INSERT INTO buytbl VALUES(NULL, 'BBK', '메모리', '전자', 80, 10);
INSERT INTO buytbl VALUES(NULL, 'SSK', '책', '서적', 15, 5);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '청바지', '의류', 50, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);



# 기본적인 뷰를 생성. 뷰의 생성 시에 뷰에서 사용될 열의 이름을 변경할 수도 있다.

USE sqldb;
CREATE VIEW v_userbuytbl
AS
    SELECT U.userid AS 'USER ID', U.name AS 'USER NAME', B.prodName AS 'PRODUCT NAME', U.addr, CONCAT(U.mobile1, U.mobile2) AS 'MOBILE PHONE'
        FROM usertbl U 
    INNER JOIN buytbl B 
        ON U.userid = B.userid;

SELECT * FROM v_userbuytbl;
SELECT `USER ID`, `USER NAME` FROM v_userbuytbl;  -- 주의! 백틱을 사용한다. ''아니고 ``이다.


# 뷰 삭제는 DROP VIEW

DROP VIEW v_userbuytbl;


USE sqldb;
CREATE OR REPLACE VIEW v_usertbl
AS
    SELECT userid, name, addr FROM usertbl;

DESCRIBE v_usertbl;

# 뷰의 소스 코드를 확인
SHOW CREATE VIEW v_usertbl;
-- 결과 전체를 보려면 [Form Editor]

# v_usertbl 뷰를 통해 데이터 수정
UPDATE v_usertbl SET addr = '부산' WHERE userid='JKW' ;

# 데이터 입력

INSERT INTO v_usertbl(userid, name, addr) VALUES('KBS', '김병만', '충북') ;
# ERROR 발생

# SUM() 함수를 사용하는 뷰
CREATE VIEW v_sum
AS
    SELECT userid AS 'userid', SUM(price*amount) AS 'total'
        FROM buytbl GROUP BY userid;

SELECT * FROM v_sum;

SELECT * FROM INFORMATION_SCHEMA.VIEWS
    WHERE TABLE_SCHEMA = 'sqldb' AND TABLED_NAME = 'v_sum';


# 키가 177 이상인 뷰를 생성

CREATE VIEW v_height177
AS
    SELECT * FROM usertbl WHERE height >= 177;

SELECT * FROM v_height177 ;


# v_height177 뷰에서 키가 177이하인 데이터를 삭제

DELETE FROM v_height177 WHERE height < 177;


# v_height177 뷰에서 키가 177 미만인 데이터를 입력

INSERT INTO v_height177 VALUES('KBM', '김병만', 1977, '경기', '010', '5555555', 158, '2023-01-01') ;

SELECT * FROM v_height177 ; -- 조회안됨
SELECT * FROM usertbl;


## WITH CHECK OPTION

ALTER VIEW v_height177
AS
    SELECT * FROM usertbl WHERE height >= 177
        WITH CHECK OPTION ;

INSERT INTO v_height177 VALUES('SJH', '서장훈', 2006, '서울', '010', '33333333', 155, '2023-3-3') ;

-- 키가 177 미만은 입력 불가, 177 이상의 데이터만 입력 가능


## 두 개 이상의 테이블이 관련되는 복합 뷰를 생성하고 데이터를 입력하자.


CREATE VIEW v_userbuytbl
AS
    SELECT U.userid, U.name, B.prodName, U.addr, CONCAT(U.mobile1, U.mobile2) AS mobile1
        FROM usertbl U 
        INNER JOIN buytbl B 
            ON U.userid = B.userid ;

INSERT INTO v_userbuytbl VALUES('PKL', '박경리', '운동화', '경기', '00000000000', '2023-2-2');

# 에러 발생 -- 두개 이상의 테이블이 관련된 뷰는 업데이트를 할 수 없다.

DROP TABLE IF EXISTS buytbl, usertbl ;

# 뷰의 상태 체크

CHECK TABLE v_userbuytbl ;




### 테이블스페이스
대용량의 데이터를 다룰 때는 성능 향상을 위해서 테이블스페이스에 대한 설정을 하는 것이 좋다.

## 테이블스페이스의 개념
별도로 저장하지 않으면 시스템 테이블스페이스에 대한 정보는 시스템 변수 innodb_data_file_path에 관련 내용이 저장되어 있다.

SHOW VARIABLES LIKE 'innodb_data_file_path';

# 테이블스페이스 파일은 기본적으로 아래 경로에 저장되어 있다.
C:\ProgramData\MySQL\MySQL Server 8.0\Data


## 성능 향상을 위한 테이블스페이스 추가

# 실습7
대용량의 데이터를 운영한다는 가정하에, 테이블스페이스를 분리해서 사용해 보자.

SHOW VARIABLES LIKE 'innodb_file_per_table';

CREATE TABLESPACE ts_a ADD DATAFILE 'ts_a.ibd';
CREATE TABLESPACE ts_b ADD DATAFILE 'ts_b.ibd';
CREATE TABLESPACE ts_c ADD DATAFILE 'ts_c.ibd';


# 각 테이블스페이스에 파일을 생성하자.

USE sqldb;
CREATE TABLE table_a (id INT) TABLESPACE ts_a;

# 테이블을 만든 후에 ALTER TABLE 문으로 테이블스페이스를 변경할 수 있다.

CREATE TABLE table_b (id INT);
ALTER TABLE table_b TABLESPACE ts_b;

# 대용량의 테이블을 복사한 후, 테이블스페이스를 지정해 보자.

CREATE TABLE table_c (SELECT * FROM employees.salaries);
ALTER TABLE table_c TABLESPACE ts_c;
# 오류 발생

-- 쿼리 응답 시간이 짧게 설정되어 있어서 오류 발생

#
Workbench 메뉴의 [Edit] >> [Preferences] 선택
[SQL Editor] 선택
[MySQL Session] 부분의 'DBMS connection read timeout interval'과 'DBMS connection timeout interval'두개를 0으로 설정 OK




#### 인덱스

### 인덱스의 개념
### 인덱스의 종류와 자동 생성

## 인덱스의 종류

-- 클러스터형 인덱스 Clustered Index 
사전 형식, 테이블당 한 개만 생성 가능. 
행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬

-- 보조 인덱스 Secondary Index
테이블당 여러 개 생성 가능.


## 데이터베이스 튜닝
SQL 서버가 기존보다 더욱 좋은 성능을 내도록 하는 전반적인 방법론을 말한다.

# 응답시간 단축 
(단축시간이 줄어 들도록 튜닝 하여 좋아 보일수 있지만, 성능 과부화로 전체적인 시스템의 성능이 나빠질수 있음)

# 서버의 부하량 최소화
(한 명 한 명 사용자의 응답시간보다는 서버가 처리하는 총 작업량을 줄임으로써 시스템의 전반적인 성능을 향상시켜 서버가 더 많은 일을 할수 있도록 하는 것이다.)


## 자동으로 생성되는 인덱스

테이블 생성 시에 제약 조건 Primary Key 또는 Unique를 사요하면 자동으로 인덱스가 자동 생성된다.

# 실습 1
제약 조건으로 자동 생성되는 인덱스를 확인해 보자.

USE sqldb ;
CREATE TABLE tbl1 
    (   a INT PRIMARY KEY,
        b INT,
        c INT
    );

SHOW INDEX FROM tbl1;

SHOW INDEX FROM 테이블이름 : 의 결과에서 Non_unique열은 0이면 Unique 인덱스를, 1이면 Nonunique 인덱스를 의미한다.




CREATE TABLE tbl2
    (   a INT PRIMARY KEY,
        b INT UNIQUE,
        c INT UNIQUE,
        d INT
    );

SHOW INDEX FROM tbl2;


CREATE TABLE tbl3
    (   a INT UNIQUE,
        b INT UNIQUE,
        c INT UNIQUE,
        d INT
    );

SHOW INDEX FROM tbl3;


CREATE TABLE tbl4
    (   a INT UNIQUE NOT NULL,
        b INT UNIQUE,
        c INT UNIQUE,
        d INT
    );

SHOW INDEX FROM tbl4;


CREATE TABLE tbl5
    (   a INT UNIQUE NOT NULL,
        b INT UNIQUE,
        c INT UNIQUE,
        d INT PRIMARY KEY
    );

SHOW INDEX FROM tbl5;


CREATE DATABASE IF NOT EXISTS testdb;
use testdb;
DROP TABLE IF EXISTS usertbl;
CREATE TABLE usertbl
( userID	char(8) not null primary key,
name	VARCHAR(10) NOT NULL,
birthYear	INT NOT NULL,
addr 	nchar(2) NOT NULL
);

INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울');

SELECT * FROM usertbl;

## 입력 순서와 다르게 userID에 클러스터형 인덱스가 생성되어 있으므로 데이터가 입력되는 즉시 userID로 데이터를 정렬

ALTER TABLE usertbl DROP PRIMARY KEY ;
ALTER TABLE usertbl
    ADD CONSTRAINT pk_name PRIMARY KEY(name);
SELECT * FROM usertbl;

# name 열로 다시 정렬 -- name열에 클러스터형 인덱스가 생성되었기 때문에 재정렬, 대용량 데이터였다면 MySQL이 엄청나게 많은 작업을 해야 한다.


# PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성된다.
# UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성된다.
# UNIQUE(또는 UNIQUE NULL) 로 지정한 열은 보조 인덱스가 생성된다.
# PRIMARY KEY 와 UNIQUE NOT NULL이 있으면 PRIMARY KEY 로 지정한 열에 우선 클러스터형 인덱스가 생성된다.
# PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다.


### 인덱스의 내부 작동

## B-Tree(Balanced Tree, 균형 트리)

루트 노드(Root Node)
중간 수준 노드
리프 노드(Leaf Node)

페이지 16 Kbyte = 16384 Byte

## 페이지 분할
데이터 변경 작업(INSERT, UPDATE, DELETE)


## 클러스터형 인덱스와 보조 인덱스의 구조

CREATE DATABASE IF NOT EXISTS testdb;
USE testdb;
DROP TABLE IF EXISTS clustertbl;
CREATE TABLE clustertbl -- Cluster Table 약자
( userID    CHAR(8),
    name    VARCHAR(10)
);
INSERT INTO clustertbl VALUES('LSG', '이승기');
INSERT INTO clustertbl VALUES('KBS', '김범수');
INSERT INTO clustertbl VALUES('KHH', '김경호');
INSERT INTO clustertbl VALUES('JYP', '조용필');
INSERT INTO clustertbl VALUES('SSK', '성시경');
INSERT INTO clustertbl VALUES('LJB', '임재범');
INSERT INTO clustertbl VALUES('YJS', '윤종신');
INSERT INTO clustertbl VALUES('EJW', '은지원');
INSERT INTO clustertbl VALUES('JKW', '조관우');
INSERT INTO clustertbl VALUES('BBK', '바비킴');


SELECT * FROM clustertbl;


ALTER TABLE clustertbl
    ADD CONSTRAINT PK_clustertbl_userID
        PRIMARY KEY (userID);


CREATE DATABASE IF NOT EXISTS testdb;
USE testdb;
DROP TABLE IF EXISTS secondarytbl;
CREATE TABLE secondarytbl
( userID    CHAR(8),
    name    VARCHAR(10)
);
INSERT INTO secondarytbl VALUES('LSG', '이승기');
INSERT INTO secondarytbl VALUES('KBS', '김범수');
INSERT INTO secondarytbl VALUES('KHH', '김경호');
INSERT INTO secondarytbl VALUES('JYP', '조용필');
INSERT INTO secondarytbl VALUES('SSK', '성시경');
INSERT INTO secondarytbl VALUES('LJB', '임재범');
INSERT INTO secondarytbl VALUES('YJS', '윤종신');
INSERT INTO secondarytbl VALUES('EJW', '은지원');
INSERT INTO secondarytbl VALUES('JKW', '조관우');
INSERT INTO secondarytbl VALUES('BBK', '바비킴');


ALTER TABLE secondarytbl
    ADD CONSTRAINT UK_secondarytbl_userID
        UNIQUE (userID);

SELECT * FROM secondarytbl;


INSERT INTO clustertbl VALUES('FNT', '푸니타');
INSERT INTO clustertbl VALUES('KAI', '카아이');

INSERT INTO secondarytbl VALUES('FNT', '푸니타');
INSERT INTO secondarytbl VALUES('KAI', '카아이');


## 클러스터형 인덱스와 보조 인덱스가 혼합되어 있을 경우

# 실습2
하나의 테이블에 클러스터형 인덱스와 보조 인덱스가 모두 존재할 경우를 살펴보자.

# step 0

CREATE DATABASE IF NOT EXISTS testdb;
USE testdb;
DROP TABLE IF EXISTS mixedtbl;
CREATE TABLE mixedtbl
(   userID  CHAR(8) NOT NULL,
    name    VARCHAR(10) NOT NULL,
    addr    CHAR(2)
);
INSERT INTO mixedtbl VALUES('LSG', '이승기', '서울');
INSERT INTO mixedtbl VALUES('KBS', '김범수', '경남');
INSERT INTO mixedtbl VALUES('KHH', '김경호', '전남');
INSERT INTO mixedtbl VALUES('JYP', '조용필', '경기');
INSERT INTO mixedtbl VALUES('SSK', '성시경', '서울');
INSERT INTO mixedtbl VALUES('LJB', '임재범', '서울');
INSERT INTO mixedtbl VALUES('YJS', '윤종신', '경남');
INSERT INTO mixedtbl VALUES('EJW', '은지원', '경북');
INSERT INTO mixedtbl VALUES('JKW', '조관우', '경기');
INSERT INTO mixedtbl VALUES('BBK', '바비킴', '서울');


# step 1
이 테이블의 userID 에 클러스터형 인덱스를 먼저 생성. Primary Key 로 지정하고 별다른 얘기가 없으면 디폴트로 클러스터형 인덱스가 생성

ALTER TABLE mixedtbl
    ADD CONSTRAINT PK_mixedtbl_userID
        PRIMARY KEY (userID);


# UNIQUE 제약조건으로 보조 인덱스를 추가

ALTER TABLE mixedtbl
    ADD CONSTRAINT UK_mixedtbl_name
        UNIQUE (name);

SHOW INDEX FROM mixedtbl;


SELECT addr FROM mixedtbl WHERE name = '임재범';

SELECT userID, name, addr FROM mixedtbl WHERE name = '임재범';


# 인덱스 생성

CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (key_part,...)
    [index_option]
    [algorithm_option | lock_option] ...

key_part: {col_name [(length)] | (expr)} [ASC | DESC]

index_option: {
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}
  | ENGINE_ATTRIBUTE [=] 'string'
  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
}

index_type:
    USING {BTREE | HASH}

algorithm_option:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

lock_option:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}


## MySQL F1
# https://dev.mysql.com/doc/refman/8.0/en/create-index.html



## 인덱스 제거

DROP INDEX index_name ON tbl_name
    [algorithm_option | lock_option] ...

algorithm_option:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

lock_option:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}



# DROP INDEX 인덱스이름 ON 테이블이름;

### 인덱스를 모두 제거할 때는 되도록 보조 인덱스부터 삭제하도록 하자.


# 실습 3
인덱스를 생성하고 사용하는 실습을 해보자.



DROP DATABASE IF EXISTS sqldb;
create DATABASE sqldb;

use sqldb;
CREATE TABLE usertbl
( userID	char(8) not null primary key,
name	VARCHAR(10) NOT NULL,
birthYear	INT NOT NULL,
addr 	CHAR(2) NOT NULL,
mobile1	CHAR(3),
mobile2 CHAR(8),
height	SMALLINT,
mDate	DATE);
CREATE TABLE buytbl
( num	INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
userID CHAR(8) NOT NULL,
prodName CHAR(6) NOT NULL,
groupName	CHAR(4),
price	INT NOT NULL,
amount	INT NOT NULL,
FOREIGN KEY (userID) REFERENCES usertbl(userID)
);




### -- 데이터 추가 입력

INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울', '011', '1111111', 182, '2008-8-8');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남', '011', '2222222', 173, '2012-4-4');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남', '019', '3333333', 177, '2007-7-7');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기', '011', '4444444', 166, '2009-4-4');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울', NULL, NULL, 186, '2013-12-12');
INSERT INTO usertbl VALUES('LJB', '임재범', 1963, '서울', '016', '6666666', 182, '2009-9-9');
INSERT INTO usertbl VALUES('YJS', '윤종신', 1969, '경남', NULL, NULL, 170, '2005-5-5');
INSERT INTO usertbl VALUES('EJW', '은지원', 1972, '경북', '011', '8888888', 174, '2014-3-3');
INSERT INTO usertbl VALUES('JKW', '조관우', 1965, '경기', '018', '9999999', 172, '2010-10-10');
INSERT INTO usertbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');

INSERT INTO buytbl VALUES(NULL, 'KBS', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buytbl VALUES(NULL, 'JYP', '모니터', '전자', 200, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200, 5);
INSERT INTO buytbl VALUES(NULL, 'KBS', '청바지', '의류', 50, 3);
INSERT INTO buytbl VALUES(NULL, 'BBK', '메모리', '전자', 80, 10);
INSERT INTO buytbl VALUES(NULL, 'SSK', '책', '서적', 15, 5);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '청바지', '의류', 50, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책', '서적', 15, 1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL, 30, 2);






USE sqldb;
SELECT * FROM usertbl;


USE sqldb;
SHOW INDEX FROM usertbl;

# 인덱스의 크기 확인
SHOW TABLE STATUS LIKE 'usertbl';


# step 2
클러스터형 인덱스가 이미 있으므로 이 테이블에는 클러스터형 인덱스를 생성할 수 없다.

# 주소(addr)에 단순 보조 인덱스를 생성하자. '단순'은 중복을 허용한다는 의미로 고유(UNIQUE)와 반대라고 생각하자.

CREATE INDEX idx_usertbl_addr
    ON usertbl (addr);

# 확인
SHOW INDEX FROM usertbl;



SHOW TABLE STATUS LIKE 'usertbl';
# 확인해봐도 Index_length가 0으로 나와 있다.

ANALYZE TABLE 문으로 먼저 테이블을 분석/처리해줘야 한다.

ANALYZE TABLE usertbl;
SHOW TABLE STATUS LIKE 'usertbl';

# 출생년도에 고유 보조 인덱스를 생성하자.

CREATE UNIQUE INDEX idx_usertbl_birthYear
    ON usertbl (birthYear);

## 김범수, 성시경이 1979년 출생년도가 중복되기 떄문에 고유 보조 인덱스를 생성 할 수 없다.


# 이름에 고유 보조 인덱스 생성

CREATE UNIQUE INDEX idx_usertbl_name
    ON usertbl (name);

고유 보조 인덱스 설정 이후에는 중복된 이름을 입력할 수 없다.

업무 절차상 절대로 중복되지 않을 경우(예로 주민등록번호, 학번, 이메일 주소 등)에만 인덱스 생성 시에 UNIQUE 옵션을 사용해야 한다.



# 이름 열과 출생년도 열을 조합해서 인덱스를 생성 그리고 이름 인덱스 삭제

CREATE UNIQUE INDEX idx_usertbl_name_birthYear
    ON usertbl (name, birthYear);

DROP INDEX idx_usertbl_name ON usertbl;

SHOW INDEX FROM usertbl;


SELECT * FROM usertbl WHERE name = '윤종신' and birthYear = '1969';
SELECT * FROM usertbl WHERE name = '윤종신';

# 휴대폰의 국번(mobile1)열에 인덱스를 생성

CREATE INDEX idx_usertbl_mobile1
    ON usertbl (mobile1);

SELECT * FROM usertbl WHERE mobile1 = '011';

# 국번의 종류가 적은 열에는 인덱스를 생성하지 않는 편이 낫다.
(선택도가 나쁜 데이터)


# 인덱스 삭제
DROP INDEX idx_usertbl_addr ON usertbl;
DROP INDEX idx_usertbl_name_birthYear ON usertbl;
DROP INDEX idx_usertbl_mobile1 ON usertbl;


ALTER TABLE usertbl DROP INDEX idx_usertbl_addr ;
ALTER TABLE usertbl DROP INDEX idx_usertbl_name_birthYear ;
ALTER TABLE usertbl DROP INDEX idx_usertbl_mobile1 ;


# Primary Key 지정으로 자동 생성된 클러스터형 인덱스를 삭제
Primary Key 에 설정된 인덱스는 DROP INDEX 문으로 삭제되지 않고, ALTER TABLE 문으로만 삭제할 수 있다.

ALTER TABLE usertbl DROP PRIMARY KEY; -- 오류 발생

usertbl의 userID열을 buytbl이 참조하고 있기 때문
외래 키 관계를 제거한 후에 다시 PRIMARY KEY 제거

# 먼저 외래 키 제약 조건 이름을 알아내자.
INFORMATION_SCHEMA 데이터베이스의 referential_constraints 테이블을 조회하면 된다.

SELECT table_name, constraint_name
    FROM information_schema.referential_constraints
    WHERE constraint_schema = 'sqldb';

ALTER TABLE buytbl DROP FOREIGN KEY buytbl_ibfk_1;
ALTER TABLE usertbl DROP PRIMARY KEY;



## 인덱스의 성능 비교

CREATE DATABASE IF NOT EXISTS indexdb;

USE indexdb;
SELECT COUNT(*) FROM employees.employees;

CREATE TABLE emp SELECT * FROM employees.employees ORDER BY RAND();
CREATE TABLE emp_c SELECT * FROM employees.employees ORDER BY RAND();
CREATE TABLE emp_Se SELECT * FROM employees.employees ORDER BY RAND();

SELECT * FROM emp LIMIT 5;
SELECT * FROM emp_c LIMIT 5;
SELECT * FROM emp_Se LIMIT 5;



SHOW TABLE STATUS문으로 테이블에 인덱스가 있는지 확인해 보자.

# step 2

emp_c에는 클러스터형 인덱스(=Primary Key 인덱스)를 emp_Se에는 보조 인덱스를 생성해 보자.

# 인덱스를 두 테이블에 생성한다.

ALTER TABLE emp_c ADD PRIMARY KEY(emp_no);
ALTER TABLE emp_Se ADD INDEX idx_emp_no (emp_no);

# 다시 데이터를 5건씩만 확인해 보자.
SELECT * FROM emp LIMIT 5;
SELECT * FROM emp_c LIMIT 5;
SELECT * FROM emp_Se LIMIT 5;


# 생성한 인덱스를 실제로 적용시키려면 ANALYZE문을 사용해야 하낟.

ANALYZE TABlE emp, emp_c, emp_Se;


# 테이블의 인덱스를 확인해 보자.
SHOW INDEX FROM emp;
SHOW INDEX FROM emp_c;
SHOW INDEX FROM emp_Se;
SHOW TABLE STATUS;


## step 3
MySQL 전체의 시스템 상태를 초기화 하자.

쿼리 창을 모두 닫고 Workbench를 종료하자.
파워셀을 관리자 모드로 실행한 후, 다음 명령을 실행해서 MySQL 서비스를 재시작 하자.

# 컴퓨터를 재부팅해도 동일한 효과다.

cmd
NET STOP MySQL
NET START MySQL

## step 4

USE indexdb;

# 인덱스가 없는 emp 테이블을 조회하자.
1) 회원 번호로 조회해 보자. SELECT 결과는 하나가 나왔을 것이다.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read'; -- 쿼리 실행 전의 읽은 페이지 수
SELECT * FROM emp WHERE emp_no = 100000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read'; -- 쿼리 실행 후에 읽은 페이지 수

2) 실행 계획을 확인하자. SELECT 문만 선택해서 다시 실행한 후 [Execution Plan]을 선택하자.


## step 5

# 인덱스가 없는 테이블을 범위로 조회해 보자.

1) 약 999건의 데이터를 읽는다.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';
SELECT * FROM emp WHERE emp_no < 100000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';

# 인덱스가 없다면 하나를 조회하든 범위로 조회하든 별 차이가 없다.

# 클러스터형 인덱스 테이블을 범위로 조회해 보자.
1) 동일한 데이터를 조회하자.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';
SELECT * FROM emp_c WHERE emp_no < 100000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';

# 결과가 정렬되어 있다.

# 클러스터형 인덱스에서 전체 데이터를 읽어보자.
1) 전체를 읽어야 하므로 LIMIT 1000000으로 충분히 지정했다. 약 30만 건이 조회될 것이다.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';
SELECT * FROM emp_c WHERE emp_no < 500000 LIMIT 1000000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';


4) 인데스 힌트를 사용해서 인덱스를 사용하지 못하도록 강제로 지정할 수 있다.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';
SELECT * FROM emp_c IGNORE INDEX(PRIMARY) WHERE emp_no < 500000 LIMIT 1000000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';

# 인덱스 힌트는 강제로 사용하는 'USE INDEX(인덱스이름)'와 강제로 사용하지 못하게 하는 'IGNORE INDEX(인덱스이름)' 정도만 알고 있으면 된다.

# 인덱스를 사용하지 않고 읽었을떄가 'Data Read'가 12M로 적은 데이터를 읽었다. 이런 경우는 인덱스를 사용하는 것보다 오히려 인덱스를 사용하지 않는 것이 데이터를 읽는 양은 적게 들어서 효율적이라고 볼 수 있겠다.


# 이번에는 WHERE 조건이 없는 전체 데이터를 조회해 보자.
1) 다음 쿼리를 수행하자. 약 30만 건이 조회될 것이다.

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';
SELECT * FROM emp_c LIMIT 1000000;
SHOW GLOBAL STATUS LIKE 'Innodb_pages_read';


## 응용 프로그램이 주로 전체 데이터의 15% 이상의 범위의 데이터를 검색하는 경우에는 차라리 인덱스를 만들지 않는 것이 시스템 성능에 도움이 된다.
# 사용하지 않는 보조 인덱스는 데이터의 변경 작업(특히 INSERT)이 발생 했을 때, 시스템의 성능을 나쁘게 만들 소지가 있다.


## step 7

SELECT * FROM emp;

ALTER TABLE emp ADD INDEX idx_gender (gender);
ANALYZE TABLE Emp;
SHOW INDEX FROM Emp;

# 남성을 조회해 보자. 
SELECT * FROM emp WHERE gender = 'M' LIMIT 500000;

# 인덱스 사용하지 못하도록 한 후에, 실행 계획 비교
SELECT * FROM emp IGNORE INDEX (idx_gender) WHERE gender = 'M' LIMIT 500000;



##
CREATE TABLE usertbl
(   userID  CHAR(8) NULL UNIQUE ,
    nameVARCHAR(10) NOT NULL,
    birthYear   INT NOT NULL,
    .......
)


## Unique 키에 NOT NULL 을 함께 지정하면 클러스터형 인덱스가 생성되므로 NULL로 지정해야 한다.
그리고 Unique 키로 지정한 userID열에 반드시 값을 입력해야 한다.


# 사용하지 않는 인덱스는 제거하자.
-- 운영되는 응용 프로그램의 쿼리들을 분석해서 WHERE 조건에서 사용되지 않는 열의 인덱스는 제거할 필요가 있다.
그러면, 공간을 확보할 뿐 아니라 데이터의 입력 시에 발생되는 부하도 많이 줄일 수 있다.

# 주기적인 OPTIMIZE TABLE 구문이나 ANALYZE TABLE 구문으로 인덱스를 재구성을 통해서 조각화를 최소화해야만 시스템의 성능을 최상으로 유지시킬 수 있을 것이다.



#### 스토어드 프로그램

스토어드 프로그램은 크게 프로시저, 스토어드 함수, 트리거, 커서 등이 있다.

자주 사용하는 복잡한 쿼리는 하나로 묶어서 이름을 지정한 후에, 간단히 그것의 이름만을 호출하면 쿼리가 실행되도록 설정한다.

쿼리의 대부분을 스토어드 프로그램으로 만들어서 사용하고 있다.

데이터베이스 개발자들이 거의 대부분의 시간을 스토어드 프로그램을 생성하는 데 보내는 경우도 많다.


형식 :
DELIMITER $$
CREATE PROCEDURE 스토어드 프로시저이름( IN 또는 OUT 파라미터 )
BEGIN

    이 부분에 SQL 프로그램 코딩.

END $$
DELIMITER ;
CALL 스토어드 프로시저이름();




USE sqlDB;
DROP PROCEDURE IF EXISTS userProc;
DELIMITER $$
CREATE PROCEDURE 스토어드 userProc()
BEGIN
    SELECT * FROM userTbl;
END $$
DELIMITER ;

CALL userProc();

## 예전에는 SELECT * FROM userTbl을 매번 사용했다면, 이제부터는 CALL userProc()라고 호출 한다.


## 스토어드 프로시저의 수정과 삭제
스토어드 프로시저의 수정은 간단히 ALTER PROCEDURE를 사용하면 되며, 삭제는 DROP PROCEDURE를 사용하면 된다.

## 매개 변수의 사용

# 입력 매개 변수를 지정하는 형식
IN 입력_매개변수_이름 데이터_형식

# 입력 매개 변수가 있는 스토어드 프로시저를 실행하기 위해서는 다음과 같이 사용한다.

CALL 프로시저_이름(전달 값);

# 출력 매개 변수를 지정하기 위해서는 다음의 형식을 따른다.

OUT 출력_매개변수_이름 데이터_형식

# 출력 매개 변수에 값을 대입하기 위해서는 주로  SELECT...INTO문을 사용한다.

# 출력 매개 변수가 있는 스토어드 프로시저를 실행하기 위해서는 다음과 같이 사용한다.

CALL 프로시저_이름(@변수명);
SELECT @변수명;



## 프로그래밍 기능

## 스토어드 프로시저 내의 오류 처리
스토어드 프로시저 내부에서 오류가 발생했을 경우에는 DECLARE 액션 HANDLER FOR 오류조건 처리할_문장 구문을 사용할 수 있다.

# 실습1
스토어디 프로시저 내용을 실습하자.

# step 0
sqlDB.sql을 이용해서 slqDB 초기화

# step 1
입력 매개 변수가 있는 스토어드 프로시저를 생성하고 실행해 보자.


USE sqlDB;
DROP PROCEDURE IF EXISTS userProc1;
DELIMITER $$
CREATE PROCEDURE userProc1(IN userName VARCHAR(10))
BEGIN
    SELECT * FROM userTbl WHERE name = userName;
END $$
DELIMITER ;

CALL userProc1('조관우');

# 2개의 입력 매개 변수가 있는 스토어드 프로시저를 생성하자.


DROP PROCEDURE IF EXISTS userProc2;
DELIMITER $$
CREATE PROCEDURE userProc2(
    IN userBirth INT,
    IN userHeight INT
)
BEGIN
    SELECT * FROM userTbl
    WHERE birthYear > userBirth AND height > userHeight;
END $$
DELIMITER ;

CALL userProc2(1970, 178);


## 출력 매개 변수를 설정해서 사용해 보자.
먼저 스토어드 프로시저를 생성한다. 그리고 테스트로 사용할 테이블을 생성하자.

DROP PROCEDURE IF EXISTS userProc3;
DELIMITER $$
CREATE PROCEDURE userProc3(
    IN txtValue CHAR(10),
    OUT outValue INT
)
BEGIN
    INSERT INTO testTBL VALUES(NULL, txtValue);
    SELECT MAX(id) INTO outValue FROM testTBL;
END $$
DELIMITER ;

CREATE TABLE IF NOT EXISTS testTBL(
    id INT AUTO_INCREMENT PRIMARY KEY,
    txt CHAR(10)
);




CALL userProc3 ('테스트값', @myValue);
SELECT CONCAT('현재 입력된 ID 값 ==>', @myValue);



## IF...ELSE문을 사용해 보자.

DROP PROCEDURE IF EXISTS ifelseProc;
DELIMITER $$
CREATE PROCEDURE ifelseProc(
    IN userName VARCHAR(10)
)
BEGIN
    DECLARE bYear INT;
    SELECT birthYear INTO bYear FROM userTBL
        WHERE name = userName;
    IF (bYear >= 1980) THEN
        SELECT '아직 젊군요..';
    ELSE 
        SELECT '나이가 지긋하시네요.';
    END IF;
END $$
DELIMITER ;

CALL ifelseProc ('조용필');





## CASE문을 사용해 보자.

DROP PROCEDURE IF EXISTS caseProc;
DELIMITER $$
CREATE PROCEDURE caseProc(
    IN userName VARCHAR(10)
)
BEGIN
    DECLARE bYear INT;
    DECLARE tti CHAR(3);
    SELECT birthYear INTO bYear FROM userTBL
        WHERE name = userName;
    CASE
        WHEN ( bYear%12 = 0) THEN   SET tti = '원숭이';
        WHEN ( bYear%12 = 1) THEN   SET tti = '닭';
        WHEN ( bYear%12 = 2) THEN   SET tti = '개';
        WHEN ( bYear%12 = 3) THEN   SET tti = '돼지';
        WHEN ( bYear%12 = 4) THEN   SET tti = '쥐';
        WHEN ( bYear%12 = 5) THEN   SET tti = '소';
        WHEN ( bYear%12 = 6) THEN   SET tti = '호랑이';
        WHEN ( bYear%12 = 7) THEN   SET tti = '토끼';
        WHEN ( bYear%12 = 8) THEN   SET tti = '용';
        WHEN ( bYear%12 = 9) THEN   SET tti = '뱀';
        WHEN ( bYear%12 = 10) THEN   SET tti = '말';
        ELSE SET tti = '양';
    END CASE;
    SELECT CONCAT(userName, '의 띠 ==>', tti);
END $$
DELIMITER ;

CALL caseProc ('김범수');


## While문을 활용해 보자. 구구단을 문자열로 생성해서 테이블에 입력하는 스토어드 프로시저를 만들자. 2중 반복문을 사용해야 한다.

USE sqldb;

DROP PROCEDURE IF EXISTS guguTBL;
CREATE TABLE guguTBL (txt VARCHAR(100)); -- 구구단 저장용 테이블

DROP PROCEDURE IF EXISTS whileProc;
DELIMITER $$
CREATE PROCEDURE whileProc()
BEGIN
    DECLARE str VARCHAR(100); -- 각 단을 문자열로 저장
    DECLARE i INT; -- 구구단 앞자리
    DECLARE k INT; -- 구구단 뒷자리
    SET i = 2; -- 2단부터 계산
    
    WHILE (i < 10) DO -- 바깥 반복문. 2단~9단까지
        SET str = ''; -- 각 단의 결과를 저장할 문자열 초기화
        SET k = 1; -- 구구단 뒷자리는 항상 1부터 9까지
        WHILE (k < 10) DO
            SET str = CONCAT(str, ' ', i, 'x', k, '=', i*k);
            SET k= k + 1; -- 뒷자리 증가
        END WHILE;
        SET i = i + 1; -- 앞자리 증가
        INSERT INTO guguTBL VALUES(str); -- 각 단의 결과를 테이블에 입력
    END WHILE;
END $$
DELIMITER ;

CALL whileProc();
SELECT * FROM guguTBL;


## DECLARE ~~ HANDLER를 이용해서 오류 처리를 해보자.
무한루페에서 1+2+3+4+.... 숫자를 계속 더하는데, 합계가 정수형(int) 데이터 형식의 오버플로가 발생하면 멈추고자 한다.
오버플로 직전의 합계가 오버플로가 어느 숫자까지 더했을 떄 발생하는지 체크해 보자.


DROP PROCEDURE IF EXISTS errorProc;
DELIMITER $$
CREATE PROCEDURE errorProc()
BEGIN
    DECLARE i INT; -- 1씩 증가하는 값
    DECLARE hap INT; -- 합계(정수형), 오버플로 발생시킬 예정
    DECLARE saveHap INT; -- 합계(정수형), 오버플로 직전의 값을 저장

    DECLARE EXIT HANDLER FOR 1264 -- INT형 오버플로가 발생하면 이 부분 수행
    BEGIN
        SELECT CONCAT('INT 오버플로 직전의 합계 -->', saveHap);
        SELECT CONCAT('1+2+3+4...+',i ,'=오버플로');
    END;

    SET i = 1; -- 1부터 증가
    SET hap = 0; -- 합계를 누적
        
    WHILE (TRUE) DO -- 무한 루프
        SET saveHap = hap; -- 오버플로 직전의 합계를 저장
        SET hap = hap + i; -- 오버플로가 나면 11행, 12행을 수행함
        SET i = i + 1;
    END WHILE;
END $$
DELIMITER ;

CALL errorProc();


# INFORMATION_SCHEMA 데이터베이스의 ROUTINES 테이블을 조회하면 내용을 확인할 수 있다.

SELECT routine_name, routine_definition FROM INFORMATION_SCHEMA.ROUTINES
    WHERE routine_schema = 'sqldb' AND routine_type = 'PROCEDURE';


# 파라미터를 확인하려면 INFORMATION_SCHEMA 데이터베이스의 ROUTINES 테이블을 조회하면 된다.

SELECT parameter_mode, parameter_name, dtd_identifier
    FROM INFORMATION_SCHEMA.PARAMETERS
    WHERE specific_name = 'userProc3';


# SHOW CREATE PROCEDURE문으로도 스토어드 프로시저의 내용을 확인할 수 있다.

SHOW CREATE PROCEDURE sqldb.userProc3;


## 테이블 이름을 파라미터로 전달하는 방법을 알아보자.
직접 입력 파라미터로 테이블 이름을 전달해 보자.


### ERROR 발생
DROP PROCEDURE IF EXISTS nameProc;
DELIMITER $$
CREATE PROCEDURE nameProc(
    IN tblName VARCHAR(20)
)
BEGIN
    SELECT * FROM tblName;
END $$
DELIMITER ;

CALL nameProc ('userTBL');
### ERROR 발생 MySQL에서는 직접 테이블 이름을 파라미터로 사용할 수 없다.


DROP PROCEDURE IF EXISTS nameProc;
DELIMITER $$
CREATE PROCEDURE nameProc(
    IN tblName VARCHAR(20)
)
BEGIN
    SET @sqlQuery = CONCAT('SELECT * FROM', tblName);
    PREPARE myQuery FROM @sqlQuery;
    EXECUTE myQuery;
    DEALLOCATE PREPARE myQuery;
END $$
DELIMITER ;

CALL nameProc ('userTBL');


# 배송 담당자는 다음과 가팅 스토어드 프로시저를 사용하면 된다.

DELIMITER $$
CREATE PROCEDURE delivProc(
    IN id VARCHAR(10)
)
BEGIN
    SELECT userID, name, addr, mobile1, mobile2
        FROM userTbl
        WHERE userID = id;
END $$
DELIMITER ;

CALL delivProc ('LJB');


### 스토어드 함수

## 스토어드 함수의 개요
스토어드 함수에 대한 정의는 MySQL 도움말에 다음과 같이 나와 있다.

## 스토어드 함수 실습 (추가 학습 필요)


### 커서
## 커서의 개요
## 커서의 처리 순서

### 트리거
## 트리거의 개요
데이터의 무결성을 위한 제약조건(PRIMARY Key, Foreign Key 등)
트리거는 제약조건과 더불어 데이터 무결성을 위해서 MySQL에서 사용할 수 있는 또 다른 기능이다.

트리거는 테이블에 관련되어 DML문(Insert, Update, Delete 등)의 이벤트가 발생될 때 작동하는 데이터베이스 개체중 하나다.

트리거는 테이블에 부착되는 프로그램 코드라고 생각하면 된다.

트리거가 부착된 테이블에 이벤트(입력, 수정, 삭제)가 발생하면 자동으로 부착된 트리거가 실행된다.

스토어드 프로시저와 달리 IN, OUT 매개 변수를 사용할 수도 없다.

# 실습4
간단한 트리거를 생성하고 결과 확인

# testDB에 간단한 테이블을 생성하자.

CREATE DATABASE IF NOT EXISTS testDB;
USE testDB;
CREATE TABLE IF NOT EXISTS testTbl (id INT, txt VARCHAR(10));
INSERT INTO testTbl VALUES(1, '레드벨벨');
INSERT INTO testTbl VALUES(2, '잇지');
INSERT INTO testTbl VALUES(3, '블랙핑크');

# testTbl에 트리거를 부착하자.

DROP TRIGGER IF EXISTS testTrg;
DELIMITER $$
CREATE TRIGGER testTrg
    AFTER DELETE
    ON testTbl
    FOR EACH ROW
BEGIN
    SET @msg = '가수 그룹이 삭제된';
END $$
DELIMITER ;


# 데이터를 삽입, 수정, 삭제해 보자.

SET @msg = '';
INSERT INTO testTbl VALUES(4, '마마무');
SELECT @msg;
UPDATE testTbl SET txt = '블핑' WHERE id = 3;
SELECT @msg;
DELETE FROM testTbl WHERE id = 4;
SELECT @msg;


# 확인

SELECT * FROM testTbl;



## 트리거의 종류

# AFTER 트리거

테이블에 INSERT, UPDATE, DELETE 등의 작업이 일어났을 때 작동하는 트리거를 말한다. 해당 작업 후에 작동한다.

# BEFORE 트리거

이벤트가 발생하기 전에 작동하는 트리거이다.

## 트리거의 사용
# CREATE TRIGGER Statement

CREATE
    [DEFINER = user]
    TRIGGER [IF NOT EXISTS] trigger_name
    trigger_time trigger_event
    ON tbl_name FOR EACH ROW
    [trigger_order]
    trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

trigger_order: { FOLLOWS | PRECEDES } other_trigger_name


## 트리거는 ALTER TRIGGER문을 사용할 수 없다.


## AFTER 트리거의 사용
회원 테이블에 update나 delete를 시도하면 수정 또는 삭제된 데이터를 별도의 테이블에 보관하고 변경된 일자와 변경한 사람을 기록해 놓자.


# step 0
# sqlDB 초기화 #

insert나 update 작업이 일어나는 경우에, 변경되기 전의 데이터를 저장할 테이블을 하나 생성하자.

USE sqlDB;
DROP TABLE buyTbl; -- 구매 테이블은 실습에 필요 없으므로 삭제
CREATE TABLE backup_userTbl
(   userID  CHAR(8) NOT NULL PRIMARY KEY,
    name    VARCHAR(10) NOT NULL,
    birthYear   INT NOT NULL,
    addr    CHAR(2) NOT NULL,
    mobile1 CHAR(3),
    mobile2 CHAR(8),
    height  SMALLINT,
    mDate   DATE,
    modType CHAR(2),
    modDate DATE,
    modUser VARCHAR(256)
);


# step 1
변경과 삭제가 발생할 떄 작동하는 트리거를 userTbl에 부착하자.
# 1-1 먼저 변경이 발생했을 떄 작동하는 backUserTbl_UpdateTrg 트리거를 생성하자.

DROP TRIGGER IF EXISTS backUserTbl_UpdateTrg;
DELIMITER $$
CREATE TRIGGER backUserTbl_UpdateTrg
    AFTER UPDATE
    ON userTBL
    FOR EACH ROW
BEGIN
    INSERT INTO backup_userTbl VALUES( OLD.userID, OLD.name, OLD.birthYear,
        OLD.addr, OLD.mobile1, OLD.mobile2, OLD.height, OLD.mDate,
        '수정', CURDATE(), CURRENT_USER() );
END $$
DELIMITER ;

# 1-2 삭제가 발생했을 때 작동하는 backUserTbl_DeleteTrg 트리거를 생성하자. backUserTbl_UpdateTrg 트리거와 거의 비슷하다.

DROP TRIGGER IF EXISTS backUserTbl_DeleteTrg;
DELIMITER $$
CREATE TRIGGER backUserTbl_DeleteTrg
    AFTER DELETE
    ON userTBL
    FOR EACH ROW
BEGIN
    INSERT INTO backup_userTbl VALUES( OLD.userID, OLD.name, OLD.birthYear,
        OLD.addr, OLD.mobile1, OLD.mobile2, OLD.height, OLD.mDate,
        '삭제', CURDATE(), CURRENT_USER() );
END $$
DELIMITER ;


UPDATE userTbl SET addr = '몽고' WHERE userID = 'JKW';
DELETE FROM userTbl WHERE height >= 177;

SELECT * FROM backup_userTbl;



# step 3
테이블의 모든 행 데이터를 삭제해 보자.

TRUNCATE TABLE userTbl;

# TRUNCATE TABLE로 삭제 시에는 트리거가 작동하지 않는다. DELETE 트리거는 DELETE문에만 작동한다.


# step 4
userTbl에 데이터 입력을 못하도록 설정하고 수정이나 삭제 시도시 경고 메시지를 보이게 하자.

# INSERT 트리거를 생성한다.

DROP TRIGGER IF EXISTS backUserTbl_InsertTrg;
DELIMITER $$
CREATE TRIGGER backUserTbl_InsertTrg
    AFTER INSERT
    ON userTBL
    FOR EACH ROW
BEGIN
    SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = '데이터의 입력을 시도했습니다. 귀하의 정보가 서버에 기록되었습니다.';
END $$
DELIMITER ;


INSERT INTO userTbl VALUES('ABC', '에비씨', 1977, '서울', '011', '11111111', 181, '2019-12-25');



## 트리거가 생성하는 임시 테이블

