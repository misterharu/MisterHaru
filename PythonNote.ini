# Python 노트

numbers[0:3]
0,1,2
numbers[0] = numbers[0] + numbers[1]

print(len(numbers))
# len = length

# append // 새로운 값을 우측 끝에 입력한다.

numbers = []
numbers.append(5)  // 함수를 입력하는 커맨드
numbers.append(8)
numbers.extend([6, 7, 8])  // 6,7,8 다수의 함수를 입력하는 커맨드
del numbers[1]   //1번 인덱스 함수를 삭제하는 커맨드
numbers.insert(3, 30)   //3번 인덱스에 30이라는 함수를 넣어 주는 커맨드

print(numbers)   // 함수 numbers를 프린트
print(len(numbers))    // numbers 총 인덱스 값을 프린트


# 함수 순서 정리

# sort 아무것도 리턴하지 않고, 기존 리스트를 정렬
numbers.sort()
numbers.sort(reverse=True)

# sorted 기존 리스트는 건드리지 않고, 정렬된 새로운 리스트를 리턴
new_list = sorted(numbers)
new_list = sorted(numbers, reverse=True)



# 리스트 인덱싱 연습
greetings = ["안녕", "니하오", "곤니찌와", "올라", "싸와디캅", "헬로", "봉주르"]

i = 0
while i < 7:
    print(greetings[i])
    i += 1

# 일반화
i = 0
while i < len(greetings):
    print(greetings[i])
    i += 1

# 추가 수정 // 시간적으로 별차이 없음. 연산이 추가되어 몇초 더 느릴수 있음.
cnt = len(greetings)
i = 0
while i < cnt:
    print(greetings[i])
    i += 1


# 온도 단위 바꾸기
# 화씨 온도에서 섭씨 온도로 바꿔 주는 함수
실습 설명
화씨 온도(°F)를 섭씨 온도(°C)로 바꾸어주는 프로그램을 만들려고 합니다.

섭씨와 화씨의 관계식은 다음과 같습니다:

°C = (°F - 32) * 5 / 9

화씨 온도를 섭씨 온도로 변환해 주는 함수 fahrenheit_to_celsius를 써 보세요. 
이 함수를 파라미터로 화씨 온도 fahrenheit를 받고, 변환된 섭씨 온도를 리턴합니다.

def fahrenheit_to_celsius(fahrenheit):
    return (fahrenheit - 32) * 5 / 9


temperature_list = [40, 15, 32, 64, -4, 11]
print("화씨 온도 리스트: {}".format(temperature_list))  # 화씨 온도 출력

# 리스트의 값들을 화씨에서 섭씨로 변환하는 코드
i = 0
while i < len(temperature_list):
    temperature_list[i] = round(fahrenheit_to_celsius(temperature_list[i]), 1)
    i += 1
    
print("섭씨 온도 리스트: {}".format(temperature_list))  # 섭씨 온도 출력



# 환전 서비스
# 실습 설명
제가 구매하고 싶은 물건들의 가격을 리스트에 정리해 놨습니다.

prices = [34000, 13000, 5000, 21000, 1000, 2000, 8000, 3000]
가격의 단위는 모두 원화(￦)인데요. 이 물건들의 가격을 미국 달러($)로 하면 얼마일지, 그리고 일본 엔화(￥)로 하면 얼마일지 확인해 보려고 합니다.

해야 할 일
우리가 해야 할 일은 크게 두 가지입니다.

함수 작성
반복문을 통해 리스트 요소들 변환
1. 함수 작성
먼저 한국 원화를 미국 달러로 변환해 주는 krw_to_usd 함수, 그리고 미국 달러를 일본 엔화로 변환해 주는 usd_to_jpy 함수를 써야 하는데요. krw_to_usd 함수는 파라미터로 원화 krw을 받아서 변환된 미국 달러 액수를 리턴해 줍니다. 마찬가지로 usd_to_jpy 함수는 파라미터로 달러 usd를 받아서 변환된 일본 엔화 액수를 리턴해 주는 거죠.

참고로 환율은 1달러에 1,000원, 그리고 1,000엔에 8달러라고 가정합니다.

2. 반복문을 통해 리스트 요소들 변환
반복문을 사용해서 리스트의 요소들을 각각 다른 화폐로 변환해야 하는데요. 그 과정에서 krw_to_usd 함수와 usd_to_jpy 함수를 활용하면 되겠죠?

실습 결과
한국 화폐: [34000, 13000, 5000, 21000, 1000, 2000, 8000, 3000]
미국 화폐: [34.0, 13.0, 5.0, 21.0, 1.0, 2.0, 8.0, 3.0]
일본 화폐: [4250.0, 1625.0, 625.0, 2625.0, 125.0, 250.0, 1000.0, 375.0]

# 해설
함수 정의
원화(￦)에서 달러($)로
krw_to_usd 함수부터 정의합시다. 이 함수는 원화를 달러로 변환하는 역할을 하는데요. 1,000원은 1달러와 동일합니다.

# 원화(￦)에서 달러($)로 변환하는 함수
def krw_to_usd(krw):
    return krw / 1000  # 1,000원 당 1달러
달러($)에서 엔화(￥)로
마찬가지로 usd_to_jpy는 이렇게 쓸 수 있습니다.

# 달러($)에서 엔화(￥)로 변환하는 함수
def usd_to_jpy(usd):
    return usd / 8 * 1000
함수 이용하기
우리가 정의한 함수를 이용해서 리스트의 원소를 어떻게 수정할 수 있을까요? 예를 하나 들어 봅시다.

인덱스 2의 값을 원화에서 달러로 변환하기 위해서는 이렇게 하면 됩니다.

prices[2] = krw_to_usd(prices[2])
만약 변환된 달러를 정수형로 딱 떨어지게 하고 싶으면 이렇게 하면 되고,

prices[2] = int(krw_to_usd(prices[2]))
소수점 첫째 자리까지 반올림하고 싶으면 이렇게 하면 됩니다.

prices[2] = round(krw_to_usd(prices[2]), 1)
반복문으로 모든 원소 변환하기
우리가 정의한 함수들과 while 반복문을 사용해서, 리스트의 요소들을 각각 다른 화폐로 변환해야 하는데요. 반복문은 인덱스 0부터 인덱스 len(prices) - 1까지 돌면 됩니다.

원화(￦)에서 달러($)로
# prices를 원화(￦)에서 달러($)로 변환하기
i = 0
while i < len(prices):
    prices[i] = krw_to_usd(prices[i])
    i += 1

# 달러($)로 각각 얼마인가요?
print("미국 화폐: " + str(prices))
달러($)에서 엔화(￥)로
# prices를 달러($)에서 엔화(￥)로 변환하기
i = 0
while i < len(prices):
    prices[i] = usd_to_jpy(prices[i])
    i += 1

# 엔화(￥)로 각각 얼마인가요?
print("일본 화폐: " + str(prices))
모범 답안
# 원화(￦)에서 달러($)로 변환하는 함수
def krw_to_usd(krw):
    return krw / 1000  # 1,000원 당 1달러


# 달러($)에서 엔화(￥)로 변환하는 함수
def usd_to_jpy(usd):
    return usd / 8 * 1000


# 원화(￦)로 각각 얼마인가요?
prices = [34000, 13000, 5000, 21000, 1000, 2000, 8000, 3000]
print("한국 화폐: " + str(prices))
 
# prices를 원화(￦)에서 달러($)로 변환하기
i = 0
while i < len(prices):
    prices[i] = krw_to_usd(prices[i])
    i += 1

# 달러($)로 각각 얼마인가요?
print("미국 화폐: " + str(prices))

# prices를 달러($)에서 엔화(￥)로 변환하기
i = 0
while i < len(prices):
    prices[i] = usd_to_jpy(prices[i])
    i += 1

# 엔화(￥)로 각각 얼마인가요?
print("일본 화폐: " + str(prices))
한국 화폐: [34000, 13000, 5000, 21000, 1000, 2000, 8000, 3000]
미국 화폐: [34.0, 13.0, 5.0, 21.0, 1.0, 2.0, 8.0, 3.0]
일본 화폐: [4250.0, 1625.0, 625.0, 2625.0, 125.0, 250.0, 1000.0, 375.0]



# 리스트 함수 활용하기
실습 설명
리스트 함수를 활용하여 아래의 지시 사항을 따르세요.

numbers라는 빈 리스트를 만들고 리스트를 출력한다.
append를 이용해서 numbers에 1, 7, 3, 6, 5, 2, 13, 14를 순서대로 추가한다. 그 후 리스트를 출력한다.
numbers 리스트의 원소들 중 홀수는 모두 제거한다. 그 후 다시 리스트를 출력한다.
numbers 리스트의 인덱스 0 자리에 20이라는 수를 삽입한 후 출력한다.
numbers 리스트를 정렬한 후 출력한다.
실습 결과
[]
[1, 7, 3, 6, 5, 2, 13, 14]
[6, 2, 14]
[20, 6, 2, 14]
[2, 6, 14, 20]

힌트2/2

해설 보기

해설
리스트에 값들 추가
append를 이용해서 원하는 값들을 순서대로 '추가'하면 됩니다.

numbers.append(1)
numbers.append(7)
numbers.append(3)
numbers.append(6)
numbers.append(5)
numbers.append(2)
numbers.append(13)
numbers.append(14)
print(numbers)
홀수 모두 제거
while 반복문을 이용해서 numbers 리스트의 원소를 순서대로 확인할 수 있습니다. 하나씩 보다가 홀수인 원소가 있으면 제거하면 되겠죠? 이 논리를 코드로 표현하면 아래와 같습니다.

i = 0
while i < len(numbers):
    # 홀수면 제거
    if numbers[i] % 2 == 1:
        del numbers[i]
    i += 1
print(numbers)
그런데 사실 위 코드에는 문제가 있습니다.

어떤 요소가 홀수여서 제거될 경우, 그 뒤에 있는 요소들이 모두 하나씩 앞당겨집니다. 예를 들어서 numbers[3]이 홀수여서 제거되면, 4번 인덱스에 있던 요소는 3번 인덱스로 가고 5번 인덱스에 있던 요소는 4번 인덱스로 간다는 거죠.

우리는 현재 i를 1씩 늘려 주며 while 반복문을 돌고 있는데요. 홀수인 요소를 제거하고 나서는 i를 늘리면 안 됩니다. i를 늘리면 요소 하나를 검토하지 않고 건너뛰게 되는 겁니다.

수행 부분에서 경우를 나눠서 동작을 다르게 하면 됩니다. 홀수 요소를 찾으면 그 요소를 제거하고, 짝수 요소를 찾으면 i를 늘리는 거죠. 아래 코드처럼요!

i = 0
while i < len(numbers):
    if numbers[i] % 2 == 1:
        del numbers[i]
    else:
        i += 1
print(numbers)
인덱스 0 자리에 20을 삽입
insert를 이용해서 값을 원하는 위치에 '삽입'할 수 있습니다.

numbers.insert(0, 20)
print(numbers)
정렬
sort를 이용해서 리스트를 정렬할 수 있습니다. 작은 순서대로 정렬하기 위해서 파라미터를 안 넘겨 줬습니다.

numbers.sort()
print(numbers)
모범 답안
# 빈 리스트 만들기
numbers = []
print(numbers)

# numbers에 값들 추가
numbers.append(1)
numbers.append(7)
numbers.append(3)
numbers.append(6)
numbers.append(5)
numbers.append(2)
numbers.append(13)
numbers.append(14)
print(numbers)

# numbers에서 홀수 제거
i = 0
while i < len(numbers):
    if numbers[i] % 2 == 1:
        del numbers[i]
    else:
        i += 1
print(numbers)

# numbers의 인덱스 0 자리에 20이라는 값 삽입
numbers.insert(0, 20)
print(numbers)

# numbers를 정렬해서 출력
numbers.sort()
print(numbers)
[]
[1, 7, 3, 6, 5, 2, 13, 14]
[6, 2, 14]
[20, 6, 2, 14]
[2, 6, 14, 20]


# 리스트 꿀팁
리스트에서 값의 존재 확인하기
어떤 값이 리스트에 있는지 확인하는 함수를 써보겠습니다.

# value가 some_list의 요소인지 확인
def in_list(some_list, value):
    i = 0
    while i < len(some_list):
        # some_list에서 value를 찾으면 True를 리턴
        if some_list[i] == value:
            return True
        i = i + 1

    # 만약 some_list에서 value를 발견하지 못했으면 False를 리턴
    return False

# 테스트
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
print(in_list(primes, 7))
print(in_list(primes, 12))
True
False
쓰는데 아주 어렵지는 않습니다. 하지만 리스트에 값의 존재를 확인하는 것은 너무 자주 있는 일이라서 파이썬에 이미 이 기능이 내장되어 있습니다. in이라는 키워드를 쓰면 됩니다.

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
print(7 in primes)
print(12 in primes)
True
False
거꾸로 값이 없는지 확인하려면 in 앞에 not을 붙이면 됩니다.

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
print(7 not in primes)
print(12 not in primes)
False
True
리스트 안의 리스트 (Nested List)
리스트 안에는 또 다른 리스트가 있을 수 있습니다. 이를 영어로 nested list라고 부릅니다.

# 세 번의 시험을 보는 수업
grades = [[62, 75, 77], [78, 81, 86], [85, 91, 89]]

# 첫 번째 학생의 성적
print(grades[0])

# 세 번째 학생의 성적
print(grades[2])

# 첫 번째 학생의 첫 번째 시험 성적
print(grades[0][0])

# 세 번째 학생의 두 번째 시험 성적
print(grades[2][1])

# 첫 번째 시험의 평균
print((grades[0][0] + grades[1][0] + grades[2][0]) / 3)
[62, 75, 77]
[85, 91, 89]
62
91
75.0

# sort 메소드
저번에 정렬된 새로운 리스트를 리턴시켜주는 sorted 함수를 보여드렸습니다. some_list.sort()는 새로운 리스트를 생성하지 않고 some_list를 정렬된 상태로 바꿔줍니다.

numbers = [5, 3, 7, 1]
numbers.sort()
print(numbers)
[1, 3, 5, 7]

# reverse 메소드
some_list.reverse()는 some_list의 원소들을 뒤집어진 순서로 배치합니다.

numbers = [5, 3, 7, 1]
numbers.reverse()
print(numbers)
[1, 7, 3, 5]

# index 메소드
some_list.index(x)는some_list에서 x의 값을 갖고 있는 원소의 인덱스를 리턴해줍니다.

members = ["영훈", "윤수", "태호", "혜린"]
print(members.index("윤수"))
print(members.index("태호"))
1
2

# remove 메소드
some_list.remove(x)는some_list에서 첫 번째로 x의 값을 갖고 있는 원소를 삭제해줍니다.

fruits = ["딸기", "당근", "파인애플", "수박", "참외", "메론"]
fruits.remove("파인애플")
print(fruits)
['딸기', '당근', '수박', '참외', '메론']


# for 반복문
my_list = [2, 3, 5, 7, 11]

for number in my_list:
print(number)

# while문
my_list = [2, 3, 5, 7, 11]

i = 0
while i < len(my_list):
    print(my_list[i])
    i += 1


# range 함수

for i in range(start, stop):
    print(i)

    // start부터 stop-1까지의 범위


for i in range(start, stop, step):
    print(i)

    // start부터 stop-1까지의 범위, 간격 step

for i in range(3, 17, 3):
    print(i)

# 3, 6, 9, 12, 15



# 거듭제곱
# 실습 설명
"2의 n제곱"을 출력하는 프로그램을 만들려고 합니다.

코드를 실행하면 아래와 같이 2^0 = 1부터 2^10 = 1024까지 출력되어야 합니다.

실습 결과
2^0 = 1
2^1 = 2
2^2 = 4
.
.
.
2^10 = 1024

# 해설
"2의 0제곱"부터 "2의 10제곱"까지 출력하고 싶으니까, 0부터 10까지 반복문을 돌리면 되겠죠? 그러면 range(11)을 사용하면 됩니다.

for i in range(11):
혹시 잊으셨다면, 거듭제곱 연산은 파이썬에서 **인데요. 2 ** 3을 하면 "2의 3제곱"이기 때문에 8이 나오는 거죠.

이제 거듭 제곱 연산과 문자열 포맷팅을 사용하면 코드를 완성할 수 있습니다.

모범 답안
for i in range(11):
    print("{}^{} = {}".format(2, i, 2 ** i))

2^0 = 1
2^1 = 2
2^2 = 4
.
.
.
2^10 = 1024


# for문으로 구구단
# 실습 설명
구구단 프로그램을 while문이 아닌 for문을 사용해서 만들어 보세요.

# 실습 결과
1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
.
.
.
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81


# 해설
1단만 작성
먼저 1단만 작성하겠습니다.

for j in range(1, 10):
    print("{} * {} = {}".format(1, j, 1 * j))
1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
1 * 4 = 4
1 * 5 = 5
1 * 6 = 6
1 * 7 = 7
1 * 8 = 8
1 * 9 = 9
1단부터 9단까지 모두 작성
while문으로 구구단 만들었던 거 기억 나시나요? 이번에도 매우 유사합니다.

그때는 while문 안에 또 다른 while문을 "중첩"해서 사용했는데요. 이번에는 for문 안에 또 다른 for문을 쓰셔야 하는 거죠.

for i in range(1, 10):
    for j in range(1, 10):
        print("{} * {} = {}".format(i, j, i * j))
모범답안
for i in range(1, 10):
    for j in range(1, 10):
        print("{} * {} = {}".format(i, j, i * j))



# 피타고라스 삼조
실습 설명


'피타고라스 정리'라고 들어 보셨나요? 직각삼각형에서, 빗변의 제곱이 두 직각변의 제곱의 합과 같다는 정리입니다.

거기서 나온 '피타고라스 삼조'라는 개념이 있는데요. 피타고라스 삼조란, 피타고라스 정리
(a^2 + b^2 = c^2)를 만족하는 세 자연수 쌍 (a,b,c)입니다.

예를 들어, 3^2 + 4^2 = 5^2 이기 때문에 (3,4,5)는 피타고라스 삼조입니다.
a < b < c라고 가정할 때, a + b + c = 400을 만족하는 피타고라스 삼조 (a,b,c)는 단 하나인데요. 
이 경우, a ∗ b ∗ c는 얼마인가요?
2040000


# 문제 출처

*수강 편의를 위해 a + b + c = 1000이었던 문제 조건을 a + b + c = 400으로 바꾸었습니다. 참고하세요!


# 해설
가장 단순한 방식
가장 단순하게 코드를 짜면 이렇습니다.


for a in range(1, 400):
    for b in range(1, 400):
        for c in range(1, 400):
            if a * a +  b * b == c * c and a < b < c and a + b + c == 400:
                print(a * b * c)


이 코드를 막상 실행해 보면, 꽤 오랜 시간이 걸릴 것입니다. 논리적으로 봤을 때 언젠가는 올바른 정답을 찾아 주는 코드입니다. 하지만 400 대신 더 큰 숫자가 들어갈 수도 있는 걸 감안하면, 너무 오래 걸려서 사실상 사용할 수 없다고 보시면 되는데요. 이런 걸 "비효율적인 알고리즘"이라고 합니다.

알고리즘이 비효율적인 이유를 간단히만 설명드리겠습니다.

a가 가능한 경우는 1부터 399까지, b가 가능한 경우는 1부터 399까지, c가 가능한 경우는 1부터 399까지인데요. 그러면,

if a * a + b * b == c * c and a < b < c and a + b + c == 400:
    print(a * b * c)

# 위 코드가 총 63,521,199번 실행됩니다. 6천만 번 이상 실행되는 거죠.



# 효율적인 방식
우리는 a + b + c = 400이라는 조건을 지켜야 합니다. 그말인즉슨 c ++ 200 - a - b라는 거죠.
이 점을 잘 활용하면 더 효율적인 코드를 작성할 수 있습니다.



# 모범 답안
for a in range(1, 400):
    for b in range(1, 400):
        c = 400 - a - b
        if a * a + b * b == c * c and a < b < c:
            print(a * b * c)

이렇게 하면 정답인 2040000를 구할 수 있습니다.


## 리스트 뒤집기
# 실습 설명
리스트 내 요소들의 순서를 거꾸로 뒤집으려고 합니다.

예를 들면 다음과 같습니다.

[1, 4, 7]이 있으면 1과 7의 위치를 바꾸어서 [7, 4, 1]로 만듭니다.
[1, 4, 7, 11]이 있으면 1과 11의 위치를 바꾸고, 4와 7의 위치를 바꾸어서 [11, 7, 4, 1]로 만듭니다.
아래와 같이 numbers라는 리스트가 주어졌을 때, for문을 사용하여 리스트를 거꾸로 뒤집어 보세요!

numbers = [2, 3, 5, 7, 11, 13, 17, 19]

# 리스트 뒤집기
# 여기에 코드를 작성하세요

print("뒤집어진 리스트: {}".format(numbers))
실습 결과
뒤집어진 리스트: [19, 17, 13, 11, 7, 5, 3, 2]

# 해설
# 접근법 #1
리스트를 뒤집기 위해서는, 서로 대칭인 원소들의 위치를 바꿔야(swap) 합니다.

대칭 관계 이해하기
대칭인 원소들을 어떻게 찾을 수 있을까요? 서로 대칭이 되는 인덱스를 찾아야겠죠.

인덱스 0과 대칭되는 위치는 인덱스 len(numbers) - 1입니다.
인덱스 1과 대칭되는 위치는 인덱스 len(numbers) - 2입니다.
인덱스 2와 대칭되는 위치는 인덱스 len(numbers) - 3입니다.
대칭되는 두 인덱스를 left와 right라고 합시다.

right = len(numbers) - left - 1로 관계를 표현할 수 있습니다.

반복문 돌기
반복문을 돌면서 left 요소와 right 요소의 위치를 바꿔 줘야 합니다.

그러기 위해서는 이렇게 할 수 있는데요.

numbers = [2, 3, 5, 7, 11, 13, 17, 19]

# 리스트 뒤집기
for left in range(len(numbers)):
    # 인덱스 left와 대칭인 인덱스 right 계산
    right = len(numbers) - left - 1

    # 위치 바꾸기
    temp = numbers[left]
    numbers[left] = numbers[right]
    numbers[right] = temp

print("뒤집어진 리스트: " + str(numbers))
뒤집어진 리스트: [2, 3, 5, 7, 11, 13, 17, 19]
이렇게 하면 리스트가 뒤집히지 않은 상태로 출력됩니다. 왜 그런 걸까요?

우리는 for문을 left가 0일 때부터 left가 len(numbers) - 1일 때까지 반복하는데요. 사실 left가 그렇게 끝까지 돌 필요가 없습니다. 그냥 리스트 길이의 반만 돌아도 리스트를 뒤집을 수 있기 때문이죠!

오히려 리스트 길이의 반을 넘게 돌면, 잘 바꿔 놨던 위치를 다시 원상 복구하는 셈입니다. 이미 바뀐 위치에 다시 위치 바꾸기 코드를 적용하게 되니까요. 그래서 리스트 길이의 반만 돌 수 있도록 아래와 같이 작성해주셔야 합니다.

numbers = [2, 3, 5, 7, 11, 13, 17, 19]


# 리스트 뒤집기

for left in range(len(numbers) // 2):
    # 인덱스 left와 대칭인 인덱스 right 계산
    right = len(numbers) - left - 1

    # 위치 바꾸기
    temp = numbers[left]
    numbers[left] = numbers[right]
    numbers[right] = temp

print("뒤집어진 리스트: " + str(numbers))

# 접근법 #2
위치 바꾸기를 쉽게 할 수 있는 방법도 알아보겠습니다. 피보나치 수열 과제에서 언급한 방법 기억나시나요? 강의에서 배우지는 않지만, 튜플(tuple)이라는 자료형을 이용해서 할당하는 겁니다. 튜플은 아래와 같이 표현합니다.

korean_names = ('효선', '유신')
english_names = 'hyoseon', 'yusin'

print(type(korean_names))
print(type(english_names))
<class 'tuple'>
<class 'tuple'>
위처럼 괄호를 통해 표현할 수도 있지만 , 로만 각 요소를 구분해도 튜플로 인식이 됩니다.

그럼 어떻게 위치를 쉽게 바꿀 수 있는지 코드를 보겠습니다.

numbers = [2, 3, 5, 7, 11, 13, 17, 19]

# 리스트 뒤집기
for left in range(len(numbers) // 2):
    # 인덱스 left와 대칭인 인덱스 right 계산    
    right = len(numbers) - left - 1

    # 위치 바꾸기
    numbers[right], numbers[left] = numbers[left], numbers[right]

print("뒤집어진 리스트: " + str(numbers))
위와 같이 쓰게 되면 지정 연산자(=) 의 오른쪽에 있는 튜플이 위치가 바뀌기 전의 numbers[left], numbers[right] 의 값을 보관하게 됩니다. 그리고 numbers[right], numbers[left] 에 해당하는 요소에 값을 각각 할당하게 되면서 이전 코드처럼 임시 변수를 만들지 않고도 값을 교환할 수 있는 것입니다.

어느 접근법을 이용하여 해결하셔도 좋습니다. 두번째 접근법은 파이썬스러운(Pythonic) 방법으로 다른 코드에서 보실 수도 있으니 참고로 알아두세요!

# 모범 답안
numbers = [2, 3, 5, 7, 11, 13, 17, 19]

# 리스트 뒤집기
for left in range(len(numbers) // 2):
    # 인덱스 left와 대칭인 인덱스 right 계산
    right = len(numbers) - left - 1

    # 위치 바꾸기
    temp = numbers[left]
    numbers[left] = numbers[right]
    numbers[right] = temp

print("뒤집어진 리스트: " + str(numbers))


# 사전 (dictionary)
# key-value pair (키-값 쌍)
my_dictionary = {
    5: 25,
    2: 4,
    3: 9
print(type(my_dictionary))
}

// print(my_dictionary[3])
// 9

# 사전 내용 추가하기
my_dictionary[9] = 81


#
my_family = {'엄마': '김자옥',
    '아빠' : '이석진',
    '아들': '이동민',
    '딸': '이지영'
}

print(my_family['아빠'])



# 영어 단어장
# 실습 설명
태호는 미국 다트머스 대학교 컴퓨터 과학과에 지원하려고 합니다. 컴퓨터 과학 전공으로 미국 유학을 가고 싶기 때문에, 코딩 공부와 영어 공부를 모두 해야 하는 상황인데요. 그 둘을 동시에 하기 위해서 파이썬으로 단어장 프로그램을 만들기로 합니다.

해야 할 일
단어장 만들기
새로운 단어들 추가
1. 단어장 만들기
잘 모르는 단어 네 개입니다.

sanitizer: 살균제
ambition: 야망
conscience: 양심
civilization: 문명
이 단어들을 저장하는 사전을 만들고, 만든 사전을 vocab라는 변수에 저장하세요. 단어와 뜻이 key-value로 들어가야 합니다.

2. 새로운 단어들 추가
이미 만들어진 vocab 사전에 새로운 단어들을 추가하고 싶습니다. 아래 단어들을 추가해 주세요.

privilege: 특권
principle: 원칙
실습 결과
{'sanitizer': '살균제', 'ambition': '야망', 'conscience': '양심', 'civilization': '문명'}
{'sanitizer': '살균제', 'ambition': '야망', 'conscience': '양심', 'civilization': '문명', 'privilege': '특권', 'principle': '원칙'}

# 해설
1. 단어장 만들기
사전을 만들기 위해서는 괄호를 열고 닫고, 그 사이에 원하는 쌍(pair)들을 추가하면 됩니다.

vocab = {
    'sanitizer': '살균제',
    'ambition': '야망',
    'conscience': '양심',
    'civilization': '문명'
}
2. 새로운 단어들 추가
vocab 사전에 새로운 key-value 쌍을 추가하기 위해서는 vocab[key] = value의 형태로 코드를 쓰면 됩니다.

vocab['privilege'] = '특권'
vocab['principle'] = '원칙'
모범 답안
# 1. 단어장 만들기
vocab = {
    'sanitizer': '살균제',
    'ambition': '야망',
    'conscience': '양심',
    'civilization': '문명'
}
print(vocab)


# 2. 새로운 단어들 추가
vocab['privilege'] = '특권'
vocab['principle'] = '원칙'
print(vocab)



# print(vocab.values())
# print('문명' in vocab.values())

# 반복문
for value in vocab.value():
    print(value)

# keys 값을 전부 불러올때
print(vocab.keys())

# 반복문
for key in vocab.keys():
    print(key)

# key와 value를 동시에 불러 오기 1
for key in vocab.keys():
    value = vocab[key]
    print(key, value)

# key와 value를 동시에 불러 오기 2
for key, value in vocab.items():
    print(key, value)


# 사전 뒤집기
# 실습 설명
태호는 영어 단어 공부를 위해서 단어장 프로그램을 만들었습니다. 하지만 이번에는 영-한으로 공부하는 것이 아니라, 한-영으로 공부를 해 보고 싶습니다.

사전의 key와 value를 뒤집어 주는 함수 reverse_dict를 작성해 주세요. reverse_dict는 파라미터로 사전 dict를 받고, key와 value가 뒤집힌 새로운 사전을 리턴합니다.

# 실습 결과
영-한 단어장
{'sanitizer': '살균제', 'ambition': '야망', 'conscience': '양심', 'civilization': '문명', 'privilege': '특권', 'principles': '원칙'}

한-영 단어장
{'살균제': 'sanitizer', '야망': 'ambition', '양심': 'conscience', '문명': 'civilization', '특권': 'privilege', '원칙': 'principles'}


# 해설
dict의 key와 value를 모두 받아오려면 어떻게 해야 할까요?

이렇게 하면 됩니다.

for key, value in dict.items():
각 key-value 쌍을 new_dict에 저장하고 싶은 건데요. new_dict[key] = value를 하면 기존 dict와 똑같은 사전이 만들어집니다. new_dict[value] = key를 해야 뒤집힌 사전을 만들 수 있겠죠?

# 모범 답안
# 언어 사전의 단어와 뜻을 서로 바꿔주는 함수
def reverse_dict(dict):
    new_dict = {}  # 새로운 사전
    
    # dict의 key와 value를 뒤집어서 new_dict에 저장
    for key, value in dict.items():
        new_dict[value] = key
    
    return new_dict  # 변환한 새로운 사전 리턴


# 영-한 단어장
vocab = {
    'sanitizer': '살균제',
    'ambition': '야망',
    'conscience': '양심',
    'civilization': '문명',
    'privilege': '특권',
    'principles': '원칙'
}

# 기존 단어장 출력
print("영-한 단어장\n{}\n".format(vocab))

# 변환된 단어장 출력
reversed_vocab = reverse_dict(vocab)
print("한-영 단어장\n{}".format(reversed_vocab))



# 투표 집계하기
# 실습 설명
효신이는 매년 국회의원 선거 때마다, 성북구에서 집계 도우미 봉사를 하는데요. 작년까지는 표를 손수 세다가, 올해부터는 IT 시대에 더 적합한 솔루션을 개발하려고 합니다.

파이썬 리스트 votes에는 성북구민들의 투표 결과가 저장되어 있습니다. 리스트 votes의 정보를 토대로, 사전 vote_counter에 후보별 득표수를 정리하는 것이 목표입니다.

예를 들어서 votes가 ['허유나', '서혜선', '허유나']라고 가정하면, vote_counter는 {'허유나': 2, '서혜선': 1}이 되어야 하는 거죠.

실습 결과
{'김영자': 11, '강승기': 6, '최만수': 8}

# 해설
for문을 이용해서 votes에 있는 후보 이름을 순서대로 name이라는 변수에 지정합니다. name을 vote_counter 사전에 반영하면 되는데요. 두 가지 경우가 있습니다.

해당 후보(name)가 아직 vote_counter에 없는 케이스
해당 후보(name)가 이미 vote_counter에 있는 케이스
1번 케이스는 해당 후보가 첫 득표를 한 상황인데요. 그러면 그냥 vote_counter[name] = 1을 하면 되겠죠?

2번 케이스는 해당 후보가 이미 최소 하나의 득표를 한 상황입니다. 이 경우 기존 득표 수에 1을 늘려 주면 되는데요. 그러면 vote_counter[name] += 1을 하면 됩니다.

# 모범 답안
# 투표 결과 리스트
votes = ['김영자', '강승기', '최만수', '김영자', '강승기', '강승기', '최만수', '김영자', \
'최만수', '김영자', '최만수', '김영자', '김영자', '최만수', '최만수', '최만수', '강승기', \
'강승기', '김영자', '김영자', '최만수', '김영자', '김영자', '강승기', '김영자']

# 후보별 득표수 사전
vote_counter = {}

# 리스트 votes를 이용해서 사전 vote_counter를 정리하기
for name in votes:
    if name not in vote_counter:
        vote_counter[name] = 1
    else:
        vote_counter[name] += 1

# 후보별 득표수 출력
print(vote_counter)


# Aliasing
# 동일한 값을 가리키며 y 값이 변경되면 x 값도 같이 변경된다.
X = [2, 3, 5, 7, 11]
y = x
y [2] = 4
print(x) //[2, 3, 5, 7, 11]
print(y) //[2, 3, 5, 7, 11]

# list 커맨드는 array를 복사해서 따로 가져간다.
X = [2, 3, 5, 7, 11]
y = list (x)
y [2] = 4
print(x)  //[2, 3, 5, 7, 11]
print(y)  //[2, 4, 5, 7, 11]



# 리스트와 문자열
name = [1, 2, 3, 4, 5]
name[0] = 5
print(name)

name = 'codeit'
name[0] = 'C'
print(name)  //error


name = 'code' + 'it' // 문자열을 합쳐서 새로운 문자열 생성은 가능하다. 수정 X
# 리스트는 수정이 가능하지만, 문자열은 수정이 불가능하다.



## 리스트와 문자열 정리
리스트와 문자열은 굉장히 비슷합니다. 리스트가 어떤 자료형들의 나열이라면, 문자열은 문자들의 나열이라고 할 수 있겠죠. 지금부터 파이썬에서 리스트와 문자열이 어떻게 같고 어떻게 다른지 알아봅시다.

인덱싱 (Indexing)
두 자료형은 공통적으로 인덱싱이 가능합니다.

# 알파벳 리스트의 인덱싱
alphabets_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
print(alphabets_list[0])
print(alphabets_list[1])
print(alphabets_list[4])
print(alphabets_list[-1])

# 알파벳 문자열의 인덱싱
alphabets_string = 'ABCDEFGHIJ'
print(alphabets_string[0])
print(alphabets_string[1])
print(alphabets_string[4])
print(alphabets_string[-1])
A
B
E
J
A
B
E
J
for 반복문
두 자료형은 공통적으로 인덱싱이 가능합니다. 따라서 for 반복문에도 활용할 수 있습니다.

# 알파벳 리스트의 반복문
alphabets_list = ['C', 'O', 'D', 'E', 'I', 'T']
for alphabet in alphabets_list:
    print(alphabet)

# 알파벳 문자열의 반복문
alphabets_string = 'CODEIT'
for alphabet in alphabets_string:
    print(alphabet)
C
O
D
E
I
T

C
O
D
E
I
T
슬라이싱 (Slicing)
두 자료형은 공통적으로 슬라이싱이 가능합니다.

# 알파벳 리스트의 슬라이싱
alphabets_list = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
print(alphabets_list[0:5])
print(alphabets_list[4:])
print(alphabets_list[:4])

# 알파벳 문자열의 슬라이싱
alphabets_string = 'ABCDEFGHIJ'
print(alphabets_string[0:5])
print(alphabets_string[4:])
print(alphabets_string[:4])
['A', 'B', 'C', 'D', 'E']
['E', 'F', 'G', 'H', 'I', 'J']
['A', 'B', 'C', 'D']
ABCDE
EFGHIJ
ABCD
덧셈 연산
두 자료형에게 모두 덧셈은 "연결"하는 연산입니다.

# 리스트의 덧셈 연산
list1 = [1, 2, 3, 4]
list2 = [5, 6, 7, 8]
list3 = list1 + list2
print(list3)

# 문자열의 덧셈 연산
string1 = '1234'
string2 = '5678'
string3 = string1 + string2
print(string3)
[1, 2, 3, 4, 5, 6, 7, 8]
12345678
len 함수
두 자료형은 모두 길이를 재는 len 함수를 쓸 수 있습니다.

# 리스트의 길이 재기
print(len(['H', 'E', 'L', 'L', 'O']))

# 문자열의 길이 재기
print(len("Hello, world!"))
5
13
Mutable (수정 가능) vs. Immutable (수정 불가능)
하지만 차이점이 있습니다. 리스트는 데이터를 바꿀 수 있지만, 문자열은 데이터를 바꿀 수 없다는 것입니다. 리스트와 같이 수정 가능한 자료형을 'mutable'한 자료형이라고 부르고, 문자열과 같이 수정 불가능한 자료형을 'immutable'한 자료형이라고 부릅니다. 숫자, 불린, 문자열은 모두 immutable한 자료형입니다.

# 리스트 데이터 바꾸기
numbers = [1, 2, 3, 4]
numbers[0] = 5
print(numbers)
[5, 2, 3, 4]
리스트 numbers의 인덱스 0에 5를 새롭게 지정해주었습니다. [5, 2, 3, 4]가 출력되었습니다. 이처럼 리스트는 데이터의 생성, 삭제, 수정이 가능합니다.

# 문자열 데이터 바꾸기
name = "codeit"
name[0] = "C"
print(name)
Traceback (most recent call last):
  File "untitled.py", line 3, in <module>
    name[0] = "C"
TypeError: 'str' object does not support item assignment
문자열 name의 인덱스 0 에 "C"를 새롭게 지정해주었더니 오류가 나왔습니다. TypeError: 'str' object does not support item assignment는 문자열은 변형이 불가능하다는 메시지입니다. 이처럼 문자열은 리스트와 달리 데이터의 생성, 삭제, 수정이 불가능합니다.


# 자릿수 합 구하기
# 실습 설명
함수 sum_digit은 파라미터로 정수형 num을 받고, num의 각 자릿수를 더한 값을 리턴합니다.

예를 들어서 12의 각 자릿수는 1, 2이니까 sum_digit(12)는 3, 즉 1 + 2의 결괏값을 리턴합니다.

마찬가지로 486의 각 자릿수는 4, 8, 6이니까 sum_digit(486)은 18(4 + 8 + 6)을 리턴하는 거죠.

여러분이 해야 할 일은 두 가지입니다.

sum_digit 함수를 작성한다.
sum_digit(1)부터 sum_digit(1000)까지의 합을 구해서 출력한다.
실습 결과
13501

# 해설
sum_digit 함수 정의
sum_digit 함수를 정의하기 위한 단계들을 먼저 봅시다.

자릿수 합을 보관하는 변수 total을 0으로 정의한다.
정수형 num을 문자열로 바꾼다.
문자열은 리스트와 유사하다는 점을 이용하여, 반복적으로 각 자릿수를 받는다.
각 자릿수를 정수형으로 변환한다.
각 자릿수를 total에 더한다.
반복문을 이용해서 total을 모두 계산한 후, total을 리턴한다.
이 단계들을 코드로 표현하면 이렇습니다.

def sum_digit(num):
    total = 0
    str_num = str(num)
    
    for i in range(len(str_num)):
        digit = str_num[i]
        total += int(digit)
    
    return total
그런데 우리는 인덱스 i는 굳이 필요 없습니다. 그래서 코드를 더 깔끔하게 쓰고 싶으면 이렇게 바꿀 수 있습니다.

# 자리수 합 리턴
def sum_digit(num):
    total = 0
    str_num = str(num)
    
    for digit in str_num:
        total += int(digit)

    return total
훨씬 낫죠?

# 테스트
잘 작동하는지 테스트를 해 봅시다.

print(sum_digit(12))
print(sum_digit(486)
3
18
잘 되는 것 같습니다!

sum_digit(1)부터 sum_digit(1000)까지 더하기
이제 sum_digit(1)부터 sum_digit(1000)까지 더하면 되는데요. 이건 for문을 이용해서 어렵지 않게 할 수 있습니다.

digit_total = 0
for i in range(1, 1001):
    digit_total += sum_digit(i)

# 모범 답안
# 자리수 합 리턴
def sum_digit(num):
    total = 0
    str_num = str(num)
    
    for digit in str_num:
        total += int(digit)

    return total


# sum_digit(1)부터 sum_digit(1000)까지의 합 구하기
digit_total = 0
for i in range(1, 1001):
    digit_total += sum_digit(i)

print(digit_total)


# 주민등록번호 가리기
# 실습 설명
주민등록번호 YYMMDD-abcdefg는 총 열세 자리인데요.

앞의 여섯 자리 YYMMDD는 생년월일을 의미합니다.

YY → 연
MM → 월
DD → 일
뒤의 일곱 자리 abcdefg는 살짝 복잡합니다.

a → 성별
bc → 출생등록지에 해당하는 지방자치단체의 고유번호
defg → 임의의 번호
보시다시피 많은 부분은 특정 규칙대로 정해져 있는데요. 여러분에 대한 몇 가지 정보만 알면, 마지막 네 개 숫자 defg를 제외한 앞의 아홉 자리는 쉽게 알 수 있다는 거죠.

그래서 저희는 주민등록번호의 마지막 네 자리 defg만 가려 주는 보안 프로그램을 만들려고 합니다.

mask_security_number라는 함수를 정의하려고 하는데요. 이 함수는 파라미터로 문자열 security_number를 받고, security_number의 마지막 네 글자를 '*'로 대체한 새 문자열을 리턴합니다.

참고로 파라미터 security_number에는 작대기 기호(-)가 포함될 수도 있고, 포함되지 않을 수도 있는데요.  작대기 포함 여부와 상관 없이, 마지막 네 글자가 '*'로 대체되어야 합니다!

# 실습 결과
880720-123****
880720123****
930124-765****
930124765****
761214-235****
761214235****

# 해설
# 접근법 #1
문자열은 수정이 불가능합니다. 하지만 문자열과 유사한 리스트는 수정이 가능하죠? 그러면 문자열 security_number를 리스트로 변환한 후, 마지막 네 원소를 '*'로 바꿔 주면 됩니다. 그리고 나서 그 리스트를 다시 하나의 문자열로 합치면 되겠죠?

코드로 봅시다.

def mask_security_number(security_number):
    # security_number를 리스트로 변환
    num_list = []
    for i in range(len(security_number)):
        num_list.append(security_number[i])
문자열을 반복문을 쓰지 않고 한번에 리스트로 바꾸고 싶으면 곧바로 형 변환을 쓸 수도 있습니다.

def mask_security_number(security_number):
    # security_number를 리스트로 변환
    num_list = list(security_number)
이제 마지막 네 요소, 즉 인덱스 len(num_list) - 4부터 인덱스 len(num_list) - 1의 값들을 *로 바꿔주면 됩니다.

def mask_security_number(security_number):
    # security_number를 리스트로 변환
    num_list = list(security_number)

    # 마지막 네 값을 *로 대체
    for i in range(len(num_list) - 4, len(num_list)):
        num_list[i] = "*"
마지막으로 이 리스트를 이제 다시 문자열로 만들어서 리턴시켜 주어야합니다. 리스트의 각 요소를 하나씩 빈 문자열을 시작으로 연결해주면 기존 문자열로 만들 수 있을 것입니다. 그럼 이 연결을 어떻게 해줄 수 있을까요? 리스트와 문자열 정리에서 배운 덧셈 연산을 이용하면 됩니다.

def mask_security_number(security_number):
    # security_number를 리스트로 변환
    num_list = list(security_number)

    # 마지막 네 값을 *로 대체
    for i in range(len(num_list) - 4, len(num_list)):
        num_list[i] = "*"

    # 리스트를 문자열로 복구
    total_str = ""
    for i in range(len(num_list)):
        total_str += num_list[i]

    return total_str

# 접근법 #2
사실 리스트를 문자열로 복구하는 코드는 join() 이라는 메소드로 한번에 할 수 있습니다. 이 메소드는 문자열로 이루어진 리스트를 구분자로 결합하여 하나의 문자열로 만들어 줍니다. 아래 코드로 확인해보겠습니다.

units = ["cm", "m", "yard"]
units_to_string = ', '.join(units)

print(type(units_to_string))
print(units_to_string)
<class 'str'>
cm, m, yard
join() 메소드는 str.join(list) 형태로 쓰게 됩니다. str은 리스트 요소들을 결합할 때 사용될 구분자입니다. 구분자는 문자열이어야 합니다. 그리고 list 는 각 요소가 문자열인 리스트를 의미합니다. 그래서 위 코드의 결과로 units 리스트의 각 요소들이 ,와 공백으로 결합된 하나의 문자열로 출력되는 것입니다.

이 과제에서는 각 숫자들을 공백없이 결합을 해야합니다. 그럼 어떻게 작성할 수 있을까요? 잠시 생각해보시고 아래 코드를 확인해보세요.

def mask_security_number(security_number):
    num_list = list(security_number)

    # 마지막 네 값을 *로 대체
    for i in range(len(num_list) - 4, len(num_list)):
        num_list[i] = '*'

    # 리스트를 문자열로 복구하여 반환
    return ''.join(num_list)

# 접근법 #3
그런데 더 쉬운 방법이 있습니다. 문자열 슬라이싱을 이용하는 건데요.

security_number의 마지막 네 자리만 제외해서 슬라이싱을 하고, 문자열 "****"과 연결하면 끝입니다!

# 모범 답안
def mask_security_number(security_number):
    return security_number[:-4] + '****'


# 테스트
print(mask_security_number("880720-1234567"))
print(mask_security_number("8807201234567"))
print(mask_security_number("930124-7654321"))
print(mask_security_number("9301247654321"))
print(mask_security_number("761214-2357111"))
print(mask_security_number("7612142357111"))


# 팰린드롬
# 실습 설명
"토마토"나 "기러기"처럼 거꾸로 읽어도 똑같은 단어를 '팰린드롬(palindrome)'이라고 부릅니다.

팰린드롬 여부를 확인하는 함수 is_palindrome을 작성하려고 하는데요. is_palindrome은 파라미터 word가 팰린드롬이면 True를 리턴하고 팰린드롬이 아니면 False를 리턴합니다.

예를 들어서 "racecar"과 "토마토"는 거꾸로 읽어도 똑같기 때문에 True가 출력되어야 합니다. 그리고 "hello"는 거꾸로 읽으면 "olleh"가 되기 때문에 False가 나와야 하는 거죠.

# 실습 결과
True
False
True
True
False


# 해설
문자열의 첫 번째 원소와 마지막 원소를 비교해서 일치하는지 확인해야 합니다. 그 다음 문자열의 두 번째 원소와 끝에서 두 번째 원소를 비교해서 일치하는지 확인해야겠죠.

문자열 word의 첫 번째 원소의 인덱스는 0이고, 마지막 원소의 인덱스는 len(word) - 1입니다. 문자열 word의 두 번째 원소의 인덱스는 1이고, 끝에서 두 번째 원소의 인덱스는 len(word) - 2입니다.

이걸 어떻게 일반화할 수 있을까요?

i를 0부터 1씩 늘린다고 가정했을 때, 인덱스 i에 있는 값과 인덱스 len(word) - i - 1에 있는 값을 비교하면 됩니다!

참고로 i를 0부터 len(word) - 1까지 반복할 필요는 없습니다. 어차피 반대쪽과 비교하는 것이기 때문에 i를 len(word) // 2까지만 반복해도 이미 모든 확인은 끝나는 거죠!

# 모범 답안
def is_palindrome(word):
    for left in range(len(word) // 2):
        # 한 쌍이라도 일치하지 않으면 바로 False를 리턴하고 함수를 끝냄
        right = len(word) - left - 1
        if word[left] != word[right]:
            return False

    # for문에서 나왔다면 모든 쌍이 일치
    return True


# 테스트 코드
print(is_palindrome("racecar"))
print(is_palindrome("stars"))
print(is_palindrome("토마토"))
print(is_palindrome("kayak"))
print(is_palindrome("hello"))


# 모듈
// 같은 폴더에 있는 .py 모듈만 불러 올수 있다.
# calculator.py
# 더하기
def add(x, y):
    return x + y

# 빼기
def subtract(x, y):
    return x + y

# 곱하기
def multiply(x, y):
    return x + y

# 나누기
def divide(x, y):
    return x + y

# run.py
import calculator
import calculator as calc // as 뒤 이름은 간결하게 정해야 한다. # 추천
form calculator import add, multiply // add, multiply 두 함수만 불러 옴
form calculator import * // 모든 함수를 불러옴. 출처를 몰라서 잘 사용하지 않음 # 비추천

print(calculator.add(2, 5))
print(calculator.multiply(2, 5))

# 추천
print(calc.add(2, 5))
print(calc.multiply(2, 5))


# standard library (표준 라이브러리)

# import math
print(math.log10(100))
print(math.cos(0))
print(math.pi)

# import random
print(random.random()) // 0.0 ~ 1.0 사이의 값을 랜덤하게 만들어 준다.

# import os
print(ox.getlogin())  // 로그인 되어 있는 계정을 알려 준다.
print(ox.getcwd())  // 이파일이 있는 경로를 알려 준다.



## random 모듈
스탠다드 라이브러리에 있는 random 모듈은 랜덤으로 숫자를 생성하는 다양한 함수들을 제공합니다.

import random

# randint() 함수
randint() 함수는 두 수 사이의 어떤 랜덤한 정수를 리턴하는 함수입니다. randint(a, b)를 하면, a ≤ N ≤ b를 만족하는 어떤 랜덤한 정수 N을 리턴하는 것이죠.

import random

print(random.randint(1, 20))
print(random.randint(1, 20))
print(random.randint(1, 20))
print(random.randint(1, 20))
print(random.randint(1, 20))
8
3
6
6
2
1 이상 20 이하의 수 다섯 개를 출력했는데요. 보시다시피 매번 다른 랜덤한 수가 출력되었습니다. 여러분이 실행하면 아마 또다른 결과가 나오겠죠?

# uniform() 함수
uniform() 함수는 두 수 사이의 랜덤한 소수를 리턴하는 함수입니다. randint() 함수와 다른 것은 리턴하는 값이 정수가 아니라 소수라는 점입니다. uniform(a, b)를 하면, a ≤ N ≤ b를 만족하는 어떤 랜덤한 소수 N을 리턴하는 것이죠.

import random

print(random.uniform(0, 1))
print(random.uniform(0, 1))
print(random.uniform(0, 1))
print(random.uniform(0, 1))
print(random.uniform(0, 1))
0.08811632754196952
0.599056286966887
0.03005761564442677
0.45302183459579204
0.5120418463594933
0 이상, 1 이하의 수 다섯 개를 출력했는데요. 보시다시피 매번 다른 랜덤한 수가 출력되었습니다. 여러분이 실행하면 아마 또다른 결과가 나오겠죠?



## datetime 모듈

스탠다드 라이브러리에 있는 datetime 모듈은 '날짜'와 '시간'을 다루기 위한 다양한 '클래스'를 갖추고 있습니다. '클래스' 개념은 아직 배우지 않았지만, 일단은 몰라도 이 모듈을 사용하는 데에는 문제없습니다.

import datetime

# datetime 값 생성
2020년 3월 14일을 파이썬으로 어떻게 표현할 수 있을까요? 이렇게 하면 됩니다.

pi_day = datetime.datetime(2020, 3, 14)
print(pi_day)
print(type(pi_day))
2020-03-14 00:00:00
<class 'datetime.datetime'>
보시다시피 시간은 자동으로 00시 00분 00초로 설정되었는데요. 우리가 시간까지도 직접 정할 수 있습니다.

pi_day = datetime.datetime(2020, 3, 14, 13, 6, 15)
print(pi_day)
print(type(pi_day))
2020-03-14 13:06:15
<class 'datetime.datetime'>

# 오늘 날짜
우리가 날짜와 시간을 정해 주는 게 아니라, 코드를 실행한 '지금 이 순간'의 날짜와 시간을 받아 올 수도 있는데요. 이렇게 하면 됩니다.

today = datetime.datetime.now()
print(today)
print(type(today))
2020-04-05 17:49:12.360266
<class 'datetime.datetime'>

# timedelta 타입
두 datetime 값 사이의 기간을 알고 싶으면, 마치 숫자 뺄셈을 하듯이 그냥 빼면 됩니다.

today = datetime.datetime.now()
pi_day = datetime.datetime(2020, 3, 14, 13, 6, 15)
print(today - pi_day)
print(type(today - pi_day))
22 days, 4:42:57.360266
<class 'datetime.timedelta'>
보시다시피 두 datetime 값을 빼면, timedelta라는 타입이 나오는데요. 이건 날짜 간의 차이를 나타내는 타입이라고 생각하시면 됩니다. 반대로 timedelta를 생성해서 datetime 값에 더할 수도 있습니다.

today = datetime.datetime.now()
my_timedelta = datetime.timedelta(days=5, hours=3, minutes=10, seconds=50)

print(today)
print(today + my_timedelta)
2020-04-05 17:54:24.221660
2020-04-10 21:05:14.221660

# datetime 해부하기
datetime 값에서 '연도'나 '월' 같은 값들을 추출하려면 어떻게 해야 할까요? 아래의 코드와 코멘트를 확인해 주세요.

today = datetime.datetime.now()

print(today)
print(today.year)  # 연도
print(today.month)  # 월
print(today.day)  # 일
print(today.hour)  # 시
print(today.minute)  # 분
print(today.second)  # 초
print(today.microsecond)  # 마이크로초
2020-04-05 17:59:21.709817
2020
4
5
17
59
21
709817

# datetime 포매팅
datetime 값을 출력하면 별로 예쁘지 않습니다. 하지만 strftime() 함수를 사용하면, 우리 입맛대로 바꿀 수 있습니다.

today = datetime.datetime.now()

print(today)
print(today.strftime("%A, %B %dth %Y"))
2020-04-05 18:09:55.233501
Sunday, April 05th 2020
%A, %B, %d, %Y와 같은 걸 포맷 코드라고 하는데요. 어떤 포맷 코드를 사용할지는 아래 표를 참고해 주세요.

포맷 코드	설명	예시
%a	요일 (짧은 버전)	Mon
%A	요일 (풀 버전)	Monday
%w	요일 (숫자 버전, 0~6, 0이 일요일)	5
%d	일 (01~31)	23
%b	월 (짧은 버전)	Nov
%B	월 (풀 버전)	November
%m	월 (숫자 버전, 01~12)	10
%y	연도 (짧은 버전)	16
%Y	연도 (풀 버전)	2016
%H	시간 (00~23)	14
%I	시간 (00~12)	10
%p	AM/PM	AM
%M	분 (00~59)	34
%S	초 (00~59)	12
%f	마이크로초 (000000~999999)	413215
%Z	표준시간대	PST
%j	1년 중 며칠째인지 (001~366)	162
%U	1년 중 몇 주째인지 (00~53, 일요일이 한 주의 시작이라고 가정)	35
%W	1년 중 몇 주째인지 (00~53, 월요일이 한 주의 시작이라고 가정)	35


## inmput
// 사용자에게 받는 값은 문자열이다.
name = inmput("이름을 입력하세요: ")
print(name)  

// 정수를 받기 위해서는 int로 감싸줘야 한다.
name = int(inmput("숫자를 입력하세요: "))
print(x + 5) 


## 숫자 맞히기 게임
# 실습 설명
1과 20 사이의 숫자를 맞히는 게임을 만들려고 합니다. 
random 모듈과 input() 함수를 활용하여 프로그램을 만들어 보세요.

# 진행 방식
프로그램을 실행하면 기회가 *번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요:가 출력됩니다. 
총 네 번의 기회가 주어지며, 사용자가 한 번 추측할 때마다 남은 기회가 줄어듭니다.
정답을 맞히면 축하합니다. *번 만에 숫자를 맞히셨습니다.가 출력되고 프로그램은 종료됩니다.
사용자가 입력한 수가 정답보다 작은 경우 Up이 출력되고, 입력한 수가 정답보다 큰 경우 Down이 출력됩니다.
정답이 틀렸으면 1번부터 다시 진행합니다. 만약 네 번의 기회를 모두 사용했는데도 답을 맞히지 못했으면, 아쉽습니다. 
정답은 *입니다.가 출력되고 프로그램은 종료됩니다.

# 실습 결과
예시 1
기회가 4번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 10
Up
기회가 3번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 15
Up
기회가 2번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 17
축하합니다. 3번만에 숫자를 맞히셨습니다.
예시 2
기회가 4번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 19
Down
기회가 3번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 14
Down
기회가 2번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 6
Up
기회가 1번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: 10
UP
아쉽습니다. 정답은 12였습니다.


다음 항목들이 제대로 구현되었는지 확인해 보세요!
"기회가 4번 남았습니다"부터 "기회가 1번 남았습니다"까지 기회가 줄어들면서 출력된다.
정답이 입력값보다 큰 경우 "Up", 작은 경우 "Down", 같은 경우 정답 메시지가 잘 출력되었는지 확인한다.
정답을 맞춘 경우, 몇 번만에 맞혔는지 출력한다.
4번의 기회를 모두 사용했는데도 답을 맞히지 못했으면 정답이 출력된다.
정답을 맞혔을 경우, "아쉽습니다"와 "축하합니다"가 동시에 출력되지 않는다.

# 해설
우선 게임이 실행되는 동안 바뀌지 않을 상수 두 개를 먼저 정의하겠습니다.

게임의 정답: ANSWER
총 기회 수: NUM_TRIES
게임이 실행되는 도중에는 정답이 바뀌지 않지만, 다른 게임이 시작되면 정답은 바뀌어야 하죠? random 모듈의 randint() 함수를 사용할게요.

import random

ANSWER = random.randint(1, 20)
그리고 사용자에게 네 번의 기회를 주고 싶으니까 NUM_TRIES는 4로 설정하겠습니다.

NUM_TRIES = 4
사용자 인풋 받기
이제 사용자에게 인풋을 받아 봅시다. 사용자로부터 입력을 받기 위해서는 아래 코드를 쓰면 되는데요.

input("기회가 {}번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: ".format(tries))
사용자의 입력을 받는 input() 함수의 리턴값은 문자열입니다. 우리는 문자열이 아닌 정수형을 원하기 때문에, input() 함수의 리턴값을 정수형으로 변환해야 합니다. 그리고 이 정수값을 guess라는 변수에 저장합시다.

guess = int(input("기회가 {}번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: ".format(tries)))
위 코드를 while문의 수행 부분에 넣어야 할 텐데요. while문의 조건 부분과 수행 부분은 어떻게 쓰면 좋을지 고민해 보세요.

while문의 조건 부분
while문의 수행 부분에 들어간다는 것은 어떤 의미인가요? 아직 게임이 끝나지 않았다는 뜻이죠? 게임이 계속 진행되기 위해서는 두 가지 조건을 만족해야 합니다.

아직 사용자가 정답을 맞히지 않았다.
아직 사용자에게 기회가 남았다.
사용자가 입력한 값은 변수 guess에 저장되어 있고, 사용자 시도 횟수는 변수 tries에 저장되어 있다고 합시다. 그러면 while문의 조건 부분은 이렇게 쓸 수 있습니다.

while guess != ANSWER and tries < NUM_TRIES:
그렇다면 while문 전에 두 변수에 대한 정의도 미리 필요하겠죠? guess는 처음에 임시적으로 -1로 저장하겠습니다. 그리고 tries는 0부터 시작하면 됩니다.

guess = -1
tries = 0

while guess != ANSWER and tries < NUM_TRIES:
    # 여기에 코드를 작성하세요
while문의 수행 부분 틀
while문의 수행 부분은 어떻게 쓸 수 있을까요? 수행 부분에서는 크게 세 가지를 해야 합니다.

사용자에게 입력을 받는다.
사용자 시도 횟수(tries)를 1 만큼 늘린다.
사용자가 입력한 숫자(guess)가 ANSWER보다 큰지, 작은지에 따라 상황에 맞는 동작을 한다.
이것을 코드로 옮기면 이렇습니다.

while guess != ANSWER and tries < NUM_TRIES:
    guess = int(input("기회가 {}번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: ".format(NUM_TRIES - tries)))
    tries += 1    
    
    if ANSWER > guess:
        print("Up")
    elif ANSWER < guess:
        print("Down")
while문이 끝나고 나면?
while문에서 빠져 나오게 되면 무엇을 해야 할까요? 두 가지 시나리오가 있는데요.

사용자가 정답을 맞혀서 빠져나온 경우
사용자가 정답은 못 맞혔지만, 기회를 다 사용해서 빠져나온 경우
각 상황에 맞는 내용이 출력되도록 코드를 작성하면 이렇습니다.

if guess == ANSWER:
    print("축하합니다. {}번 만에 숫자를 맞히셨습니다.".format(tries))
else:
    print("아쉽습니다. 정답은 {}입니다.".format(ANSWER))

# 모범 답안
import random

# 상수 정의
ANSWER = random.randint(1, 20)
NUM_TRIES = 4

# 변수 정의
guess = -1
tries = 0

while guess != ANSWER and tries < NUM_TRIES:
    guess = int(input("기회가 {}번 남았습니다. 1-20 사이의 숫자를 맞혀 보세요: ".format(NUM_TRIES - tries)))
    tries += 1    
    
    if ANSWER > guess:
        print("Up")
    elif ANSWER < guess:
        print("Down")

if guess == ANSWER:
    print("축하합니다. {}번 만에 숫자를 맞히셨습니다.".format(tries))
else:
    print("아쉽습니다. 정답은 {}입니다.".format(ANSWER))



## 파일 읽기
with open('data/chicken.txt', 'r') as f:
    for line in f:
    print(line)


## strip  // .strip()
// 화이트 스페이스를 제거해준다. " " "\t" "\n"
// 문자열 사이의 화이트 스페이스는 유지하고 앞뒤의 화이트 스페이스만 제거해준다.

print("   abc   def     ".strip())

with open('data/chicken.txt', 'r') as f:
    for line in f:
    print(line.strip())


## split
my_string = " 1. 2. 3. 4. 5. 6"
print(my_string.split(". ")) // "."을 할 경우 우측에 스페이스 공간이 생기는데, split(". ")로 수정해 줄수 있다.

#
full_name = "kim, Yuna"
name_data = full_name.split(", ")
last_name = name_data[0]
first_name = name_data[1]

print(first_name, last_name)

# split()으로 모든 화이트 스페이스를 제거할수 있다.
print("     \n\n   2   \t   3  \n  5 7 11 \n\n".split())

# split()로 구분해주면 값은 문자열이다.
numbers = "     \n\n   2   \t   3  \n  5 7 11 \n\n".split()
print(numbers[0] + numbers[1])  //23

# 정수로 변환
print(int(numbers[0]) + int(numbers[1]))  //5



## 코딩에 빠진 닭
# 실습 설명
밑에 나와 있는 chicken.txt 파일을 보세요. 제가 운영하는 치킨집 '코딩에빠진닭(이하 코빠닭)'의 12월 매출이 정리되어 있습니다.

1일: 453400
2일: 388600
3일: 485300
4일: 477900
5일: 432100
6일: 665300
7일: 592500
8일: 465200
9일: 413200
10일: 523000
11일: 488600
12일: 431500
13일: 682300
14일: 633700
15일: 482300
16일: 391400
17일: 512500
18일: 488900
19일: 434500
20일: 645200
21일: 599200
22일: 472400
23일: 469100
24일: 381400
25일: 425800
26일: 512900
27일: 723000
28일: 613600
29일: 416700
30일: 385600
31일: 472300
:의 왼쪽에는 해당 월의 며칠인지, 그리고 오른쪽에는 그 날의 매출이 적혀 있습니다. data 폴더의 chicken.txt 파일을 읽어 들이고, strip과 split을 써서 12월 코빠닭의 하루 평균 매출을 출력하세요. 평균을 구하기 위해서는 총 매출을 총 일수로 나누면 됩니다. 참고로 현재 제공된 파일에는 31일이 있지만, 어떤 달은 31일이 아닐 수도 있습니다. 이 점을 고려해서 확장성 있는 코드를 작성해 주시길 바랍니다.

실습 결과
501916.12903225806

# 해설
파일 열기
파일 여는 건 영상에서 봤었죠?

with open('data/chicken.txt', 'r') as f:
일별 매출 출력
우선 각 날의 매출을 출력하는 것부터 해 봅시다. strip과 split을 적절히 활용하면 되겠죠?

for line in f:
    data = line.strip().split(": ")
    revenue = int(data[1])  # 그날의 매출
    print(revenue)
평균 일 매출 구하기
우리는 한 달 동안의 평균 일매출을 구하려고 하는데요. 이를 계산하기 위해서 한 달 동안의 총 매출과 한 달 동안의 총 일수를 알아야 합니다. 총 매출과 총 일수를 어떻게 구할 수 있을까요? 총 매출을 누적으로 보관하는 변수 total_revenue를 만듭시다. 마찬가지로 총 일수를 누적으로 보관하는 변수 total_days도 만들겠습니다.

total_revenue = 0
total_days = 0
이제 for 반복문의 수행 부분에 들어갈 때마다, 두 값을 업데이트해야겠죠? 그리고 반복문이 끝나고 나서 print(total_revenue / total_days)를 하면 평균 일매출을 출력할 수 있습니다.

# 모범 답안
with open('data/chicken.txt', 'r') as f:
    total_revenue = 0
    total_days = 0
    
    for line in f:
        data = line.strip().split(": ")
        revenue = int(data[1])  # 그날의 매출

        total_revenue += revenue
        total_days += 1

    print(total_revenue / total_days)



## 파일 쓰기
# 덮어쓰기
with open('new_file.txt', 'w') as f:
    f.write("Hello codeit!\n")
    f.write("My name is Codeit.\n")

# 추가로 쓰기  // 파일명이 있으면 그 파일에 추가로 쓰고, 파일명이 없으면 파일을 생성후 쓴다.
with open('new_file.txt', 'a') as f:
    f.write("Hello codeit!\n")
    f.write("My name is Codeit.\n")

# 단어장 만들기
# 실습 설명
영어 강사 Coy는 학생들의 단어 암기를 위해 단어장 프로그램을 만들려고 합니다. 이 프로그램은 콘솔로 영어 단어와 한국어 뜻을 받고, vocabulary.txt라는 새로운 텍스트 파일에 단어와 뜻을 정리하는데요. 사용자가 새로운 단어와 뜻을 입력할 때마다 vocabulary.txt에 작성되는 것입니다. 사용자는 반복적으로 단어와 뜻을 입력하는데, 단어나 뜻으로 q를 입력하는 순간 프로그램은 즉시 종료됩니다. 사용자가 q를 입력하고 나면 파일은 더 이상 바뀌지 않아야 합니다.

# 실습 결과
프로그램의 예시 동작은 아래와 같습니다.

영어 단어를 입력하세요:

영어 단어를 입력하세요: cat
한국어 뜻을 입력하세요:

영어 단어를 입력하세요: cat
한국어 뜻을 입력하세요: 고양이
영어 단어를 입력하세요:

영어 단어를 입력하세요: cat
한국어 뜻을 입력하세요: 고양이
영어 단어를 입력하세요: apple
한국어 뜻을 입력하세요:

영어 단어를 입력하세요: cat
한국어 뜻을 입력하세요: 고양이
영어 단어를 입력하세요: apple
한국어 뜻을 입력하세요: 사과
영어 단어를 입력하세요:
이런 식으로 단어를 8개 입력했다고 가정합시다.

영어 단어를 입력하세요: cat
한국어 뜻을 입력하세요: 고양이
영어 단어를 입력하세요: apple
한국어 뜻을 입력하세요: 사과
영어 단어를 입력하세요: church
한국어 뜻을 입력하세요: 교회
영어 단어를 입력하세요: temple
한국어 뜻을 입력하세요: 절
영어 단어를 입력하세요: wallet
한국어 뜻을 입력하세요: 지갑
영어 단어를 입력하세요: backpack
한국어 뜻을 입력하세요: 책가방
영어 단어를 입력하세요: soap
한국어 뜻을 입력하세요: 비누
영어 단어를 입력하세요: bicycle
한국어 뜻을 입력하세요: 자전거
영어 단어를 입력하세요: q
사용자가 q를 입력하면 프로그램이 종료되고, vocabulary.txt에 다음과 같이 단어들이 정리되어 있어야 합니다.

cat: 고양이
apple: 사과
church: 교회
temple: 절
wallet: 지갑
backpack: 책가방
soap: 비누
bicycle: 자전거


다음 항목들이 제대로 구현되었는지 확인해 보세요!

프로그램을 실행하면 "영어 단어를 입력하세요:"가 출력되고 사용자의 입력을 받는다.


영어 단어를 입력하고 나면 "한국어 뜻을 입력하세요:"라고 출력된 후, 사용자 입력을 받는다.


q를 입력하면 프로그램이 종료된다.


vocabulary.txt 파일에 내가 입력한 단어들이 잘 기록되어 있다.


q를 입력했을 때, q가 vocabulary.txt 파일에 기록되지 않는다.


# 해설
파일을 쓰기 위해서는 먼저 파일을 열어야겠죠?

with open('vocabulary.txt', 'w') as f:
이렇게 하면 vocabulary.txt라는 파일을 열고, 그 파일에 글을 작성할 수 있습니다. 글을 작성하기 위해서는 단어와 뜻을 반복적으로 받아야 하는데요. while문에서 반복적으로 해야 하는 일을 정리해 봅시다.

영어 단어를 입력 받는다.
만약 유저가 q를 입력했으면 프로그램을 종료한다.
한국어 뜻을 받는다.
만약 유저가 q를 입력했으면 프로그램을 종료한다.
영어 단어와 한국어 뜻을 단어: 뜻의 형태로 파일에 작성한다.
이것을 코드로 변환하기만 하면 됩니다.

모범 답안
with open('vocabulary.txt', 'w') as f:
    while True:
        english_word = input('영어 단어를 입력하세요: ')    
        if english_word == 'q':
            break
        
        korean_word = input('한국어 뜻을 입력하세요: ')
        if korean_word == 'q':
            break
        
        f.write('{}: {}\n'.format(english_word, korean_word))


## 단어 퀴즈
# 실습 설명
앞선 실습에서 vocabulary.txt라는 파일을 만들었죠? 이 파일에는 우리가 암기하고 싶은 단어들이 정리되어 있는데요. 이번에는 이 파일의 단어들을 가지고 학생들에게 문제를 내는 프로그램을 만들려고 합니다.

프로그램은 터미널에 한국어 뜻을 알려 줄 것이고, 사용자는 그에 맞는 영어 단어를 입력해야 합니다. 사용자가 입력한 영어 단어가 정답이면 맞았습니다!라고 출력하고, 틀리면 아쉽습니다. 정답은 OOO입니다.가 출력되어야 합니다.

문제를 내는 순서는 vocabulary.txt에 정리된 순서입니다.

# 실습 결과
고양이: cat
맞았습니다!

사과: fruit
아쉽습니다. 정답은 apple입니다.

교회: church
맞았습니다!

절: tample
아쉽습니다. 정답은 temple입니다.

지갑: wallet
맞았습니다!

책가방: bag
아쉽습니다. 정답은 backpack입니다.

비누: soap
맞았습니다!

자전거: bycicle
아쉽습니다. 정답은 bicycle입니다.

# 셀프 채점
다음 항목들이 제대로 구현되었는지 확인해 보세요!

vocabulary.txt 파일에 있는 단어를 하나씩 순서대로 불러와서 퀴즈를 낸다.


정답을 맞추면 "맞았습니다!", 틀리면 "아쉽습니다. 정답은 *입니다"가 출력된다.


vocabulary.txt 파일에 있는 단어 수가 달라져도 코드가 잘 작동한다.


# 해설
영어 단어와 한국어 뜻 받아 오기
파일을 읽기 위해서는 먼저 파일을 열어야겠죠?

with open('vocabulary.txt', 'r') as f:
이렇게 하면 vocabulary.txt라는 파일을 열고, 그 파일을 읽을 수 있습니다. 이제 파일을 한 줄씩 순서대로 읽어야 하는데요. for문을 사용하면 되겠죠?

for line in f:
for문의 수행 부분에는 어떤 코드가 들어가야 할까요? 먼저 각 줄(line)의 영어 단어와 한국어 뜻을 각각 어떻게 받아 올 수 있을지 생각해 봅시다. 두 단계를 거쳐 받아 올 수 있는데요.

strip을 이용해서 line에서 "\n"을 없앤다.
split을 이용해서 영어 단어와 한국어 뜻 나눈다.
코드로 작성하면 이렇습니다.

data = line.strip().split(": ")
그러면 data 리스트의 0번 인덱스에는 영어 단어가 들어가고, 1번 인덱스에는 한국어 뜻이 들어가는 거죠. 깔끔한 코드를 위해, 각각 변수에 할당하겠습니다.

english_word, korean_word = data[0], data[1]
문제 내기
이제 사용자에게 문제를 내고, 답을 입력 받으면 됩니다.

guess = input("{}: ".format(korean_word))
그 후에는 답이 맞았는지 틀렸는지 알려 주는 코드만 작성하면 되는데요. 이렇게 할 수 있습니다.

if guess == english_word:
    print("맞았습니다!\n")
else:
    print("아쉽습니다. 정답은 {}입니다.\n".format(english_word))

# 모범 답안
with open('vocabulary.txt', 'r') as f:
    for line in f:
        data = line.strip().split(": ")
        english_word, korean_word = data[0], data[1]
        
        # 유저 입력값 받기
        guess = input("{}: ".format(korean_word))
        
        # 정답 확인하기
        if guess == english_word:
            print("맞았습니다!\n")
        else:
            print("아쉽습니다. 정답은 {}입니다.\n".format(english_word))



## 고급 단어장
# 실습 설명
지난 실습 과제에서 단어장 퀴즈 프로그램을 만들었는데요. 학생들이 문제의 순서가 매번 똑같아서 재미가 없다고 합니다. 이번에는 random 모듈과 사전(dictionary)을 이용해서 vocabulary.txt의 단어들을 랜덤한 순서로 문제를 내도록 프로그램을 바꿔 보세요. 같은 단어를 여러 번 물어봐도 괜찮고, 프로그램은 사용자가 알파벳 q를 입력할 때까지 계속 실행됩니다.

# 실습 결과
교회: church
맞았습니다!

사과: apple
맞았습니다!

자전거: bicycle
맞았습니다!

지갑: wallet
맞았습니다!

교회: church
맞았습니다!

절: tample
틀렸습니다. 정답은 temple입니다.

비누: soap
맞았습니다!

고양이: dog
틀렸습니다. 정답은 cat입니다.

자전거: q

# 셀프 채점
다음 항목들이 제대로 구현되었는지 확인해 보세요!

vocabulary.txt 파일에 단어가 작성된 순서에 상관없이 랜덤한 순서로 퀴즈가 나온다.


정답을 맞추면 "맞았습니다!", 틀리면 "틀렸습니다. 정답은 *입니다."가 출력된다.


vocabulary.txt 파일에 있는 단어 수가 달라져도 코드가 잘 작동한다.


vocabulary.txt 파일에 있는 단어 수보다 많은 횟수 테스트를 진행해도 코드가 잘 작동한다.


q를 입력하면 프로그램이 즉시 종료된다.


# 해설
이 프로그램은 크게 두 단계로 나뉩니다.

vocabulary.txt에 있는 단어와 뜻을 파이썬 사전에 정리한다.
사전에 있는 단어 중 랜덤하게 골라서 문제를 낸다.

# 1. 사전 정리
우선 vocabulary.txt 파일을 읽고, 파이썬 사전을 채워 넣겠습니다.

vocab = {}
with open('vocabulary.txt', 'r') as f:
    for line in f:
        data = line.strip().split(": ")
        english_word, korean_word = data[0], data[1]
        vocab[english_word] = korean_word
이렇게 하면 파일에 있는 단어와 뜻이 모두 vocab 사전에 정리되겠죠? 영어 단어 목록을 받아 오려면 파이썬 사전의 keys를 사용하면 되는데요. keys라는 변수에 저장해 줍시다.

keys = list(vocab.keys())

# 2. 문제 내기
문제를 내는 부분은 코드가 조금 더 복잡합니다. 이 중에서도 가장 헷갈릴 만한 부분은 랜덤한 문제를 받아 오는 것입니다. 우선 한국어 단어는 배제하고 생각해 봅시다.

random 모듈의 randint() 함수를 이용해서 랜덤한 인덱스를 받는다.
그 랜덤한 인덱스를 통해 vocab.keys() 리스트에서 단어를 받는다.
코드로 표현하면 이렇습니다.

index = random.randint(0, len(keys) - 1)
english_word = keys[index]
그리고 이제 이에 해당하는 한국어 뜻을 받아 오는 것은 너무 쉽습니다.

korean_word = vocab[english_word]
나머지 부분은 앞선 실습과 거의 똑같습니다.

유저에게 단어를 입력 받는다.
만약 유저가 q를 입력했으면 프로그램을 종료한다.
유저가 입력한 영어 단어가 정답인지 확인한다.

# 모범 답안
import random

# 사전 만들기
vocab = {}
with open('vocabulary.txt', 'r') as f:
    for line in f:
        data = line.strip().split(": ")
        english_word, korean_word = data[0], data[1]
        vocab[english_word] = korean_word

# 목록 가져오기
keys = list(vocab.keys())

# 문제 내기
while True:
    # 랜덤한 문제 받아 오기
    index = random.randint(0, len(keys) - 1)
    english_word = keys[index]
    korean_word = vocab[english_word]
    
    # 유저 입력값 받기
    guess = input("{}: ".format(korean_word))
    
    # 프로그램 끝내기
    if guess == 'q':
        break
    
    # 정답 확인하기
    if guess == english_word:
        print("정답입니다!\n")
    else:
        print("틀렸습니다. 정답은 {}입니다.\n".format(english_word))



## 프로젝트 소개: 로또 시뮬레이션

로또 시뮬레이션 프로그램을 만들어 보겠습니다. 이 프로그램은 과정이 많기 때문에, 여러 파트로 나눠서 문제를 해결해 나갈 건데요. 먼저 이 레슨에서 프로그램 전체에 대해 설명해 드리겠습니다.

# 규칙
로또는 주 1회 간격으로 당첨자를 발표합니다. 참여 횟수에 제한이 없어서, 한 사람이 한 회차에 여러 번 참여할 수도 있습니다. 고를 수 있는 번호는 1부터 45까지 있는데요. 주최측에서는 매주 6개의 '일반 당첨 번호'와 1개의 '보너스 번호'를 뽑습니다. 그리고 참가자는 참여할 때마다 서로 다른 번호 6개를 선택합니다. 당첨 액수는 아래 규칙에 따라 결정됩니다.

내가 뽑은 번호 6개와 일반 당첨 번호 6개 모두 일치: 10억 원
내가 뽑은 번호 5개와 일반 당첨 번호 5개 일치, 그리고 내 번호 1개와 보너스 번호 일치: 5천만 원
내가 뽑은 번호 5개와 일반 당첨 번호 5개 일치: 100만 원
내가 뽑은 번호 4개와 일반 당첨 번호 4개 일치: 5만 원
내가 뽑은 번호 3개와 일반 당첨 번호 3개 일치: 5천 원

# 프로젝트에서 작성할 함수 미리보기
여러분의 임무는 로또 시뮬레이션을 위한 함수들을 작성하는 것입니다. 어떤 함수들이 있는지 봅시다.

# generate_numbers() 함수
이 함수는 파라미터로 정수 n을 받습니다. 1과 45 사이의 서로 다른 번호를 무작위로 n개 뽑고, 그 번호들이 담긴 리스트를 리턴합니다. 예시 코드와 실행 결과를 보여 드릴게요.

print(generate_numbers(6))
[16, 2, 30, 40, 15, 33]
다시 실행하면 또다른 결과가 나오겠죠? 참고로 이 함수는 참가자의 번호를 뽑는 데에도 쓰이고, 보너스를 포함한 당첨 번호 7개를 뽑는 데에도 쓰입니다.

# draw_winning_numbers() 함수
일반 당첨 번호 6개와 보너스 번호 1개가 포함된 리스트를 리턴합니다. 일반 당첨 번호 6개는 정렬되어 있어야 하고, 보너스 번호는 마지막에 추가하면 됩니다. 코드와 실행 결과를 예로 보여 드릴게요.

print(draw_winning_numbers())
[4, 12, 14, 28, 40, 41, 6]
앞서 정의한 generate_numbers() 함수를 잘 활용하면, 간결하게 작성할 수 있습니다.

# count_matching_numbers() 함수
파라미터로 리스트 list_1과 리스트 list_2를 받고, 두 리스트 사이에 겹치는 번호의 개수를 리턴합니다. 아래 코드와 실행 결과를 참고해 주세요.

print(count_matching_numbers([2, 7, 11, 14, 25, 40], [2, 11, 13, 14, 30, 35]))
3
2, 11, 14, 3개의 숫자가 겹치기 때문에 3이 나왔습니다.

하나의 예를 더 보여 드릴게요.

print(count_matching_numbers([2, 7, 11, 14, 25, 40], [14]))
1
이번에는 14, 1개만 겹치기 때문에 1이 나왔습니다.

# check() 함수
참가자의 당첨 금액을 리턴합니다. 파라미터로 참가자가 뽑은 번호가 담긴 리스트 numbers와 주최측에서 뽑은 번호가 담긴 리스트 winning_numbers를 받는데요. numbers는 당연히 6개의 번호를 담고 있고, winning_numbers는 보너스 번호까지 7개의 번호를 담고 있겠죠? 예시를 한번 보여 드릴게요.

numbers_test = [2, 4, 11, 14, 25, 40]
winning_numbers_test = [4, 12, 14, 28, 40, 41, 6]

print(check(numbers_test, winning_numbers_test))
5000
4, 14, 40, 이렇게 번호 3개가 겹치기 때문에 5천 원에 당첨되었습니다.


## 로또 시뮬레이션: 번호 뽑기

from random import randint


def generate_numbers(n):
    numbers = []

    while len(numbers) < n:
        num = randint(1, 45)
        if num not in numbers:
            numbers.append(num)

    return numbers


# 테스트 코드
print(generate_numbers(6))



# 해설
해설
1과 45 사이의 번호 n개를 무작위로 뽑아야 하는데요. 우선 빈 리스트를 만드는 것부터 시작합시다.


numbers = []
우리는 총 n개의 번호를 추가하고 싶은 거니까, numbers 리스트에 값이 n개 미만인 동안 반복문을 돌겠습니다.


while len(numbers) < n:
그리고 while문의 수행 부분에서 리스트에 번호를 추가하면 되는데요. 번호를 무작위로 뽑는 건 randint() 함수를 사용해서 할 수 있겠죠?


while len(numbers) < n:
    num = randint(1, 45)
이제 여기서 조금 주의하셔야 할 게 있습니다. 이 new_number를 무작정 추가하면, 리스트에 중복값이 들어갈 수도 있습니다. new_number가 numbers 리스트에 없는 경우에만 추가해야겠죠?


while len(numbers) < n:
    num = randint(1, 45)
    if num not in numbers:
        numbers.append(num)
반복문에서 나오면 numbers는 번호 n개가 들어 있을 텐데, 이제 numbers를 리턴하기만 하면 됩니다.


return numbers


## 
