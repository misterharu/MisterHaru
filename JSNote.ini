#프론트 엔드 공부해야 할 언어
# nextjs . recoil . ReactQuery . Tailwind
# AWS EC2 . ECS ECR Fargate
# FastAPI - AI 백엔드
# WASM webassembly / Threejs / Framer-motion





#  반복문

while (조건){
    반복해서 실행할 코드
}


while (true) {
    console.log("Hello MisterHaru!");
}


while (true) {
    document.write("Hello MisterHaru! <br />" );
}

#  while 문
var i = 1;

while(i < 10) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
    i++
}

#  for 문

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}

var ID = misterharu;
alert(prompt("아이디를 입력하세요!"));
if(misterharu){"안녕하세요!" + ID +"님."
} else alert("아이디 입력이 틀렸습니다.");

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}



#  break & continue 문

for(var i = 0; i < 10; i++){
    if(i === 5) {
        break;
    }
    document.write('coding everybody'+i+'<br />');
}




for(var i = 0; i < 10; i++){
    if(i === 5) {
        continue;
    }
    document.write('coding everybody'+i+'<br />');
}



# 함수의 형식
function 함수명( [인자...[,인자]] ){
    코드
    return 반환값
}


# 객체(Object)
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};


// RegExr expression - 치환
var pattern = /(\w+)\satisfies(\w+)/;
var str = "conding everybody";
var result = str.replace(pattern, "$2, $1");
console.log(result);

var urlPattern = /\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*/gim;
var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';
var result = content.replace(urlPattern, function(url){
    return '<a href="'+url+'">'+url+'</a>';
});
console.log(result);
\


//전역변수의 사용
MYAPP = {}
MYAPP.calculator = {
    'left' : null,
    'right' : null
}
MYAPP.coordinate = {
    'left' : null,
    'right' : null
}
 
MYAPP.calculator.left = 10;
MYAPP.calculator.right = 20;
function sum(){
    return MYAPP.calculator.left + MYAPP.calculator.right;
}
document.write(sum());


//전역 변수를 지역 변수로 변경
(function(){
    var MYAPP = {}
    MYAPP.calculator = {
        'left' : null,
        'right' : null
    }
    MYAPP.coordinate = {
        'left' : null,
        'right' : null
    }
    MYAPP.calculator.left = 10;
    MYAPP.calculator.right = 20;
    function sum(){
        return MYAPP.calculator.left + MYAPP.calculator.right;
    }
    document.write(sum());
}())



//함수는 함수의 리턴 값으로도 사용할 수 있다.
function cal(mode){
    var funcs = {
        'plus' : function(left, right){return left + right},
        'minus' : function(left, right){return left - right}
    }
    return funcs[mode];
}
alert(cal('plus')(2,1));
alert(cal('minus')(2,1));   


//당연히 배열의 값으로도 사용할 수 있다.
var process = [
    function(input){ return input + 10;},
    function(input){ return input * input;},
    function(input){ return input / 2;}
];
var input = 1;
for(var i = 0; i < process.length; i++){
    input = process[i](input);
}
alert(input);



# 처리의 위임
//값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.

function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]


// 클랜 획득 점수에 따른 리더보드 순위와 구분을 할 수 있다.

var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
var sortfunc = function(a, b){
    return b - a;
}
console.log(numbers.sort(sortfunc));


# 비동기 처리
<!DOCTYPE html>
<html>
<head>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</head>
<body>
<script type="text/javascript">
    $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
</script>
</body>
</html>



# 클로저
function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter();
inner();


//

function factory_movie(title){
    return {
        get_title : function (){
            return title;
        },
        set_title : function(_title){
            if(typeof _title === 'String'){
                title = _title
            } else {
                alert('제목은 문자열이어야 합니다.');
            }
            
        }
    }
}
ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
 
alert(ghost.get_title());
alert(matrix.get_title());
 
ghost.set_title('공각기동대');
 
alert(ghost.get_title());
alert(matrix.get_title());



//
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}



# arguments

function sum(){
    var i, _sum = 0;    
    for(i = 0; i < arguments.length; i++){
        document.write(i+' : '+arguments[i]+'<br />');
        _sum += arguments[i];
    }   
    return _sum;
}
document.write('result : ' + sum(1,2,3,4));



//
function zero(){
    console.log(
        'zero.length', zero.length,
        'arguments', arguments.length
    );
}
function one(arg1){
    console.log(
        'one.length', one.length,
        'arguments', arguments.length
    );
}
function two(arg1, arg2){
    console.log(
        'two.length', two.length,
        'arguments', arguments.length
    );
}
zero(); // zero.length 0 arguments 0 
one('val1', 'val2');  // one.length 1 arguments 2 
two('val1');  // two.length 2 arguments 1



//
function sum(arg1, arg2){
    return arg1+arg2;
}
alert(sum.apply(null, [1,2]))


# apply

sum.apply(null, [1.2]);


//
o1 = {val1:1, val2:2, val3:3}
o2 = {v1:10, v2:50, v3:100, v4:25}
function sum(){
    var _sum = 0;
    for(name in this){
        _sum += this[name];
    }
    return _sum;
}
alert(sum.apply(o1)) // 6
alert(sum.apply(o2)) // 185


//
var preson = {}
preson.name = 'egoing';
preson.introduce = function(){
    return 'My name is'+this.name;
}
document.write(preson.introduce());



//생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다.
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");

var p2 = new Person('leezche');
document.write(p2.introduce());


// apply call 을 이용해서 this의 값을 제어
var o = {}
var p = {}
function func(){
    switch(this){
        case o:
            document.write('o<br />');
            break;
        case p:
            document.write('p<br />');
            break;
        case window:
            document.write('window<br />');
            break;          
    }
}
func();
func.apply(o);
func.apply(p);

# 상속(inheritance)
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");


// 수정
function Person(name){
    this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
    return 'My name is '+this.name; 
}

function Programmer(name){
    this.name = name;
}
Programmer.prototype = new Person();
Programmer.prototype.coding = function(){
    return "hello world";
}

function Designer(name){
    this.name = name;
}
Designer.prototype = new Person();
Designer.prototype.design = function(){
    return "beautiful!";
}

var p1 = new Programmer('egoing');
document.write(p1.introduce()+"<br />");
document.write(p1.coding()+"<br />");

var p2 = new Designer('Haru');
document.write(p2.introduce()+"<br />");
document.write(p2.design()+"<br />");


# prototype
Array.prototype.rand = function(){
    var index = Math.floor(this.length*Math.random());
    return this[index];
}
var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');
console.log(arr.rand());


#  Object
Object.prototype.contain = function(neddle) {
    for(var name in this){
        if(this[name] === neddle){
            return true;
        }
    }
    return false;
}
var o = {'name':'egoing', 'city':'seoul'}
console.log(o.contain('egoing'));
var a = ['egoing','leezche','grapittie'];
console.log(a.contain('leezche'));
//
for(var name in o){
    if(o.hasOwnProperty(name))
        console.log(name);  
}

// 입력연습
Object.prototype.contain = function(MisterHaru){
    for(var name in this){
        if(this[name] === MisterHaru){
            return true;
        }
    }
}


#  hasOwnProperty 에 대해 추가 공부 필요

//Wrapper Object 레퍼 객체 , 원시 데이터 타입
// var str = 'coding';
// str = new String('coding');

var str = 'coding';
console.log(str.length);        // 6
console.log(str.charAt(0));     // "C"

var str = 'coding';
str.prop = 'everybody';
console.log(str.prop);      // undefined


// 밤 낮 화이트 블랙 변경
<input type="button" value="night" onclick="
    document.querySelector('body').style.backgroundColor='black;
    document.querySelector('body').style.color='white';
">
<input type="button" value="day" onclick="
    document.querySelector('body').style.backgroundColor='white;
    document.querySelector('body').style.color='black';
">

//
<input type="button" value="hi" onclick="alert('hi')">
<input type="text" onchange="alert('changed')">
<input type="text" onkeydown="alert('key down!')">



/////////////


요약
문자열에서 인자로 주어진 값에 해당하는 문자를 리턴한다.

문법
# charAt(index)
인자
index - 필수, 0보다 큰 정수

설명
문자열에 속하는 문자는 왼쪽부터 오른쪽까지 0부터 인덱싱되어 있다.
charAt은 index로 주어진 값에 해당하는 문자를 리턴한다.
인덱스는 0부터 시작하기 때문에 index로 들어갈 수 있는 가장 큰 수는 (문자열.legnth-1)이다.
존재하지 않는 index를 인자로 전달하면 공백이 출력된다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = 'coding everybody';
alert(stringName.charAt(0)); // c
alert(stringName.charAt(stringName.length-1)); // y
alert(stringName.charAt(1000) == ''); // true



#  charCodeAt
요약
index에 해당하는 문자의 unicode 값을 리턴

문법
string.charCodeAt(index)
인자
index - 필수, 0보다 큰 정수

설명
유니코드는 모든 시스템에서 일관되게 문자를 표현하기 위한 산업표준이다.
charCodeAt은 주어진 index에 해당하는 유니코드 값을 리턴하는데 이 값은 unicode가 지원되는 모든 시스템에서 동일한 문자를 가르킨다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = '생활코딩'
alert(stringName.charCodeAt(0)); // 493373 
// http://www.unicode.org/charts/PDF/UAC00.pdf 에서 '생'을 찾아보면 'C0DD'인데 이것은 16진수다. 
// 이를 10진수로 변환하면 493373이 된다

395로5168

# 웹브라우저와 javascript

JavaScript
HTML을 프로그래밍적으로 제어한다. 


<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
        #selected{
            color:red;
        }
        .dark {
            background-color:black;
            color:white;
        }
        .dark #selected{
            color:yellow;
        }
    </style>
</head>
<body>
    <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li id="selected">JavaScript</li>
    </ul>
    <input type="button" onclick="document.body.className='dark'" value="dark" />
</body>
</html>



//
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
    <input type="button" id="hw" value="hello world">
    <script type="text/javascript">
        var hw = document.getElementById('hw');
        hw.addEventListener('click', function(){
            alert('Hello world');
        })
    </script>
</body>
</html>




///

<!DOCTYPE html>
<html>
<body>
    <input type="button" id="hw" value="Hello world" />
    <script type="text/javascript" src="script2.js"></script>
</body>
</html>


* script2.js
var hw = document.getElementById('hw');
hw.addEventListener('click', function(){
    alert('Hello world');
})




window.onload = function(){
    var hw = document.getElementById('hw');
    hw.addEventListener('click', function(){
        alert('Hello world');
    })
}
//window.onload = function(){} 
//html 모두를 웹브라우저에 실행후 마지막에 호출



# 전역객체
<!document html>
<html>
<script>
    alert('Hell world');
    window.alert('Hello World');
</script>
<body>
</body>
</html>

// Location 객체

// URL Parsing
console.log(location.protocol, location.host, location.port, location.pathname, location.search, location.hash)


//현재 문서를 http://egoing.net으로 이동한다.
location.href = 'http://egoing.net';
location = 'http://egoing.net';

# 리로드
location.href=location.href
location.reload();


# Navigator 객체
객체의 모든 프로퍼티를 열람할 수 있다.
console.dir(navigator);
console.dir(navigator.appName);
console.dir(navigator.appVersion);
console.dir(navigator.userAgent);
console.dir(navigator.platform);



//Object.keys라는 메소드는 객체의 key 값을 배열로 리턴하는 Object의 메소드다. 이 메소드는 ECMAScript5에 추가되었기 때문에 오래된 자바스크립트와는 호환되지 않는다. 아래의 코드를 통해서 호환성을 맞출 수 있다. 

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
    if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
    }

    var result = [], prop, i;

    for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
        result.push(prop);
        }
    }

    if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
        if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
        }
        }
    }
    return result;
    };
}());
}


//
<!DOCTYPE html>
<html>
<style>li {padding:10px; list-style: none}</style>
<body>
<ul>
    <li>
        첫번째 인자는 새 창에 로드할 문서의 URL이다. 인자를 생략하면 이름이 붙지 않은 새 창이 만들어진다.<br />
        <input type="button" onclick="open1()" value="window.open('demo2.html');" />
    </li>
    <li>
        두번째 인자는 새 창의 이름이다. _self는 스크립트가 실행되는 창을 의미한다.<br />
        <input type="button" onclick="open2()" value="window.open('demo2.html', '_self');" />
    </li>
    <li>
        _blank는 새 창을 의미한다. <br />
        <input type="button" onclick="open3()" value="window.open('demo2.html', '_blank');" />
    </li>
    <li>
        창에 이름을 붙일 수 있다. open을 재실행 했을 때 동일한 이름의 창이 있다면 그곳으로 문서가 로드된다.<br />
        <input type="button" onclick="open4()" value="window.open('demo2.html', 'ot');" />
    </li>
    <li>
        세번재 인자는 새 창의 모양과 관련된 속성이 온다.<br />
        <input type="button" onclick="open5()" value="window.open('demo2.html', '_blank', 'width=200, height=200, resizable=yes');" />
    </li>
</ul>
 
<script>
function open1(){
    window.open('demo2.html');
}
function open2(){
    window.open('demo2.html', '_self');
}
function open3(){
    window.open('demo2.html', '_blank');
}
function open4(){
    window.open('demo2.html', 'ot');
}
function open5(){
    window.open('demo2.html', '_blank', 'width=200, height=200, resizable=no');
}
</script>
</body>
</html>


//제어 대상을 찾기
document.getElementsByTagName
document.getElementsByClassName
document.getElementById
document.querySelector 
document.querySelectorAll




# document.getElementsByTagName
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var ul = document.getElementsByTagName('ul')[0];
    var lis = ul.getElementsByTagName('li');
    for(var i=0; lis.length; i++){
        lis[i].style.color='red';   
    }
</script>


# document.getElementsByClassName
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<script>
    var lis = document.getElementsByClassName('active');
    for(var i=0; i < lis.length; i++){
        lis[i].style.color='red';   
    }
</script>
</body>
</html>


# document.getElementById
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li id="active">CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    li.style.color='red';
</script>
</body>
</html>


# document.querySelector
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>
 
<script>
    var li = document.querySelector('li');
    li.style.color='red';
    var li = document.querySelector('.active');
    li.style.color='blue';
</script>
</body>
</html>


//document.querySelectorAll
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>

<script>
    var lis = document.querySelectorAll('li');
    for(var name in lis){
        lis[name].style.color = 'blue';
    }
</script>
</body>
</html>



#  jQuery

$ = jQuery function
$('li').css('color','red');
는 <li style="color:red"> 이다.

<!DOCTYPE html>
<html>
<head>
    <style>
    #demo{width:200px;float: left; margin-top:120px;}
    #execute{float: left; margin:0; font-size:0.9em;}
    #execute{padding-left: 5px}
    #execute li{list-style: none}
    #execute pre{border:1px solid gray; padding:10px;}
    </style>
</head>
<body>
<ul id="demo">
    <li class="active">HTML</li>
    <li id="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<ul id="execute">
    <li>
        <pre>
var lis = document.getElementsByTagName('li');
for(var i=0; i&lt;lis.length; i++){
    lis[i].style.color='red';   
</pre>
        <pre>
$('li').css('color', 'red')     </pre>
        <input type="button" value="execute" onclick="$('li').css('color', 'red')" />
    </li>
    <li>
        <pre>
var lis = document.getElementsByClassName('active');
for(var i=0; i &lt; lis.length; i++){
    lis[i].style.color='red';   
}</pre>
        <pre>
$('.active').css('color', 'red')</pre>
        <input type="button" value="execute" onclick="$('.active').css('color', 'red')" />
    </li>
    <li>
        <pre>
var li = document.getElementById('active');
li.style.color='red';
li.style.textDecoration='underline';</pre>
        <pre>
$('$active').css('color', 'red').css('textDecoration', 'underline');
        </pre>
        <input type="button" value="execute" onclick="$('#active').css('color', 'red').css('textDecoration', 'underline')" />
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</body>
</html>


#  HTMLElement

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    console.log(li.constructor.name);
    var lis = document.getElementsByTagName('li');
    console.log(lis.constructor.name);
</script>

document.getElementById : 리턴 데이터 타입은 HTMLLIELement
document.getElementsByTagName : 리턴 데이터 타입은 HTMLCollection

실행결과가 하나인 경우 HTMLLIELement, 복수인 경우 HTMLCollection을 리턴하고 있다. 


# HTMLELement
<a id="anchor" href="http://opentutorials.org">opentutorials</a>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="list">JavaScript</li>
</ul>
<input type="button" id="button" value="button" />
<script>
    var target = document.getElementById('list');
    console.log(target.constructor.name);

    var target = document.getElementById('anchor');
    console.log(target.constructor.name);

    var target = document.getElementById('button');
    console.log(target.constructor.name);
</script>


interface HTMLLIElement : HTMLElement {
           attribute DOMString       type;
           attribute long            value;
};


다음은 HTMLAnchroElement이다.

interface HTMLAnchorElement : HTMLElement {
           attribute DOMString       accessKey;
           attribute DOMString       charset;
           attribute DOMString       coords;
           attribute DOMString       href;
           attribute DOMString       hreflang;
           attribute DOMString       name;
           attribute DOMString       rel;
           attribute DOMString       rev;
           attribute DOMString       shape;
           attribute long            tabIndex;
           attribute DOMString       target;
           attribute DOMString       type;
  void               blur();
  void               focus();
};




target.href = 'http://misterharu.com';


# HTMLCollection

<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
console.group('before');
var lis = document.getElementsByTagName('li');
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
console.group('after');
lis[1].parentNode.removeChild(lis[1]);
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
</script>
</body>
</html>



# jQuery 

<ul>
    <li>html</li>
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    var li = $('li');
    li.map(function(index, elem){
        console.log(index, elem);
        $(elem).css('color', 'red');
    })
</script>




# jQuery 객체 API
var t = document.getElementById('active');


주요기능

식별자

문서내에서 특정한 엘리먼트를 식별하기 위한 용도로 사용되는 API

Element.classList
Element.className
Element.id
Element.tagName

조회
엘리먼트의 하위 엘리먼트를 조회하는 API

Element.getElementsByClassName
Element.getElementsByTagName
Element.querySelector
Element.querySelectorAll

속성
엘리먼트의 속성을 알아내고 변경하는 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);


# 식별자 API

Element.tagName - 해당 엘리먼트의 태그 이름을 알아낸다. 태그 이름을 변경하지는 못한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
console.log(document.getElementById('active').tagName)
</script>

//Element.id - 문서에서 id는 단 하나만 등장할 수 있는 식별자다. 아래 예제는 id의 값을 읽고 변경하는 방법을 보여준다
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
console.log(active.id);
active.id = 'deactive';
console.log(active.id);
</script>

//Element.className - 클래스는 여러개의 엘리먼트를 그룹핑할 때 사용한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
// class 값을 변경할 때는 프로퍼티의 이름으로 className을 사용한다.
active.className = "important current";
console.log(active.className);
// 클래스를 추가할 때는 아래와 같이 문자열의 더한다.
active.className += " readed"
</script>


//Element.classList - className에 비해서 훨씬 편리한 사용성을 제공한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
function loop(){
    for(var i=0; i<active.classList.length; i++){
        console.log(i, active.classList[i]);
    }
}
#  클래스를 추가
</script>
<input type="button" value="DOMTokenList" onclick="console.log(active.classList);" />
<input type="button" value="조회" onclick="loop();" />
<input type="button" value="추가" onclick="active.classList.add('marked');" />
<input type="button" value="제거" onclick="active.classList.remove('important');" />
<input type="button" value="토글" onclick="active.classList.toggle('current');" />


//active.classList.add('haru'); 추가
//active.classList.remove('haru'); 삭제
//active.classList.toggle('haru'); 토글(있으면 삭제, 없으면 추가)




# 조회 API
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script>
    var list = document.getElementsByClassName('marked');
    console.group('document');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();

    console.group('active');
    var active = document.getElementById('active');     
    var list = active.getElementsByClassName('marked');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();
</script>



# 속성 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script>
var t = document.getElementById('target');
console.log(t.getAttribute('href')); //http://opentutorials.org
t.setAttribute('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
console.log(t.hasAttribute('title')); // true, title 속성의 존재여부를 확인한다.
t.removeAttribute('title'); // title 속성을 제거한다.
console.log(t.hasAttribute('title')); // false, title 속성의 존재여부를 확인한다.
</script>


# 속성과 프로퍼티
<p id="target">
    Hello world
</p>
<script>
    var target = document.getElementById('target');
    // attribute 방식
    target.setAttribute('class', 'important');
    // property 방식
    target.className = 'important';
</script>





<a id="target" href="./demo1.html">ot</a>
<script>
//현재 웹페이지가 http://localhost/webjs/Element/attribute_api/demo3.html 일 때 
var target = document.getElementById('target');
// http://localhost/webjs/Element/attribute_api/demo1.html 
console.log('target.href', target.href);
// ./demo1.html 
console.log('target.getAttribute("href")', target.getAttribute("href"));
</script>



# jQuery 속성 제어 API

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
var t = $('#target');
console.log(t.attr('href')); //http://opentutorials.org
t.attr('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
t.removeAttr('title'); // title 속성을 제거한다.
</script>


# attribute와 property
DOM과 마찬가지로 jQuery도 속성(attribute)과 프로퍼티를 구분한다. 속성은 attr, 프로퍼티는 prop 메소드를 사용한다.

<a id="t1" href="./demo.html">opentutorials</a>
<input id="t2" type="checkbox" checked="checked" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
//  현재 문서의 URL이 아래와 같다고 했을 때
//  http://localhost/jQuery_attribute_api/demo2.html
var t1 = $('#t1');
console.log(t1.attr('href')); // ./demo.html 
console.log(t1.prop('href')); // http://localhost/jQuery_attribute_api/demo.html 
 
var t2 = $('#t2');
console.log(t2.attr('checked')); // checked
console.log(t2.prop('checked')); // true
</script>



<div id="t1">opentutorials</div>
<div id="t2">opentutorials</div>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
$('#t1').prop('className', 'important'); 
$('#t2').prop('class', 'current');  
</script>



# jQuery 조회 범위 제한

# selector context
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $( ".marked", "#active").css( "background-color", "red" );
</script>

//실행 결과

<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked" style="background-color: red;">DOM</li>
            <li class="marked" style="background-color: red;">BOM</li>
        </ul>
    </li>
</ul>

같은 코딩
$( "#active .marked").css( "background-color", "red" );





# .find()
$( "#active").find('.marked').css( "background-color", "red" );

$('#active').css('color','blue').find('.marked').css( "background-color", "red" );

# find를 너무 복잡하게 사용하면 코드를 유지보수하기 어렵게 된다. 



# Node 관계 API

Node.childNodes
자식노드들을 유사배열에 담아서 리턴한다.
Node.firstChild
첫번째 자식노드
Node.lastChild
마지막 자식노드
Node.nextSibling
다음 형제 노드
Node.previousSibling
이전 형제 노드


<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
var s = document.getElementById('start');
console.log(1, s.firstChild); // #text
var ul = s.firstChild.nextSibling
console.log(2, ul); // ul
console.log(3, ul.nextSibling); // #text
console.log(4, ul.nextSibling.nextSibling); // script
console.log(5, ul.childNodes); //text, li, text, li, text, li, text
console.log(6, ul.childNodes[1]); // li(html)
console.log(7, ul.parentNode); // body
</script>
</body>


# 노드 종류 API

노드 작업을 하게 되면 현재 선택된 노드가 어떤 타입인지를 판단해야 하는 경우가 있다. 이런 경우에 사용할 수 있는 API가 nodeType, nodeName이다. 

Node.nodeType
node의 타입을 의미한다. 
Node.nodeName
node의 이름 (태그명을 의미한다.)

# Node Type
노드의 종류에 따라서 정해진 상수가 존재한다. 아래는 모든 노드의 종류와 종류에 따른 값을 출력하는 예제다.
for(var name in Node){
   console.log(name, Node[name]);
}
# 결과
ELEMENT_NODE 1 
ATTRIBUTE_NODE 2 
TEXT_NODE 3 
CDATA_SECTION_NODE 4 
ENTITY_REFERENCE_NODE 5 
ENTITY_NODE 6 
PROCESSING_INSTRUCTION_NODE 7 
COMMENT_NODE 8 
DOCUMENT_NODE 9 
DOCUMENT_TYPE_NODE 10 
DOCUMENT_FRAGMENT_NODE 11 
NOTATION_NODE 12 
DOCUMENT_POSITION_DISCONNECTED 1 
DOCUMENT_POSITION_PRECEDING 2 
DOCUMENT_POSITION_FOLLOWING 4 
DOCUMENT_POSITION_CONTAINS 8 
DOCUMENT_POSITION_CONTAINED_BY 16 
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC 32

# 함수가 자기 자신을 호출하는 것을 재귀함수라고 하는데 본 예제는 재귀 함수의 예를 보여준다.







# 노드 종류 API

<!DOCTYPE html>
<html>
<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
function traverse(target, callback){
    if(target.nodeType === 1){
        //if(target.nodeName === 'A')
        callback(target);
        var c = target.childNodes;
        for(var i=0; i<c.length; i++){
            traverse(c[i], callback);       
        }   
    }
}
traverse(document.getElementById('start'), function(elem){
    console.log(elem);
});
</script>
</body>
</html>


# jQuery 노드 변경 API

<div class="target">
    content1
</div>
 
<div class="target">
    content2
</div>
 
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('.target').before('<div>before</div>');
    $('.target').after('<div>after</div>');
    $('.target').prepend('<div>prepend</div>');
    $('.target').append('<div>append</div>');
</script>


# 제거
# 제거와 관련된 API는 remove와 empty가 있다. remove는 선택된 엘리먼트를 제거하는 것이고 empty는 선택된 엘리먼트의 텍스트 노드를 제거하는 것이다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="remove target 1" id="btn1" />
<input type="button" value="empty target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').remove();
    })
    $('#btn2').click(function(){
        $('#target2').empty();
    })
</script>


# 바꾸기
replaceAll과 replaceWith는 모두 노드의 내용을 교체하는 API이다. replaceWith가 제어 대상을 먼저 지정하는 것에 반해서 replaceAll은 제어 대상을 인자로 전달한다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="replaceAll target 1" id="btn1" />
<input type="button" value="replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('<div>replaceAll</div>').replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith('<div>replaceWith</div>');
    })
</script>


# 복사
<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<div id="source">source</div>
 
<input type="button" value="clone replaceAll target 1" id="btn1" />
<input type="button" value="clone replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#source').clone().replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith($('#source').clone());
    })
</script>



# 이동
<div class="target" id="target1">
    target 1
</div>
 
<div id="source">source</div>
 
<input type="button" value="append source to target 1" id="btn1" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').append($('#source'));
    })
</script>



# 문자열로 노드 제어
# innerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerHTML = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>

# outerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.outerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.outerHTML = "<ol><li>JavaScript Core</li><li>BOM</li><li>DOM</li></ol>";
    }
</script>



# innerText, outerText
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerText);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerText = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>


# insertAdjacentHTML()

<ul id="target">
    <li>CSS</li>
</ul>
<input type="button" onclick="beforebegin();" value="beforebegin" />
<input type="button" onclick="afterbegin();" value="afterbegin" />
<input type="button" onclick="beforeend();" value="beforeend" />
<input type="button" onclick="afterend();" value="afterend" />
<script>
    function beforebegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforebegin','<h1>Client Side</h1>');
    }
    function afterbegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterbegin','<li>HTML</li>');
    }
    function beforeend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforeend','<li>JavaScript</li>');
    }
    function afterend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterend','<h1>Server Side</h1>');
    }
</script>



# 값 API
<ul>
    <li id="target">html</li> 
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script>
    var t = document.getElementById('target').firstChild;
    console.log(t.nodeValue);
    console.log(t.data);
</script>


# 조작 API
appendData()
deleteData()
insertData()
replaceData()
substringData()

<!DOCTYPE html>
<html>
<head>
    <style>
    #target{
        font-size:77px;
        font-family: georgia;
        border-bottom:1px solid black;
        padding-bottom:10px;
    }
    p{
        margin:5px;
    }
    </style>
</head>
<body>
<p id="target">Cording everybody!</p>
<p> data : <input type="text" id="datasource" value="JavaScript" /></p>
<p>   start :<input type="text" id="start" value="5" /></p>
<p> end : <input type="text" id="end" value="5" /></p>
<p><input type="button" value="appendData(data)" onclick="callAppendData()" />
<input type="button" value="deleteData(start,end)" onclick="callDeleteData()" />
<input type="button" value="insertData(start,data)" onclick="callInsertData()" />
<input type="button" value="replaceData(start,end,data)" onclick="callReplaceData()" />
<input type="button" value="substringData(start,end)" onclick="callSubstringData()" /></p>
<script>
    var target = document.getElementById('target').firstChild;
    var data = document.getElementById('datasource');
    var start = document.getElementById('start');
    var end = document.getElementById('end');
    function callAppendData(){
        target.appendData(data.value);
    }
    function callDeleteData(){
        target.deleteData(start.value, end.value);
    }
    function callInsertData(){
        target.insertData(start.value, data.value); 
    }
    function callReplaceData(){
        target.replaceData(start.value, end.value, data.value);
    }
    function callSubstringData(){
        alert(target.substringData(start.value, end.value));
    }
</script>
</body>
</html>


#  요소의 크기와 위치 
#  getBoundingClientRect()
#  offsetParent
# ClientWidth, ClientHeight

<style>
    body{
        padding:0;
        margin:0;
    }
    #target{
        width:100px;
        height:100px;
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
</style>
<div id="target">
    Coding
</div>
<script>
var t = document.getElementById('target');
console.log(t.getBoundingClientRect());
console.log(t.offsetParent);
</script>


# getBoundingClientRect의 width 값을 IE는 제공하지 않는다.


# Viewport
1초에 한번씩 getBoundingClientRect의 top 속성과 window.pageYOffset의 값이 출력된다.

<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
    <div>
        <div id="target">
            Coding
        </div>
    </div>

<script>
var t = document.getElementById('target');
setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset);
}, 1000)
</script>


# 오래된 브라우저에서는 pageYOffset 대신 scrollTop 속성을 사용해야 한다.


# 문서의 좌표
그럼 문서의 좌표를 알고 싶으면 어떻게 해야 하나? 뷰포트의 좌표에 스크롤된 정도를 더해서 알 수 있다. 아래와 같이 코드를 조금 수정했다

setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset, 'document y:', t.getBoundingClientRect().top+window.pageYOffset);
}, 1000)


# 스크롤
<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
<input type="button" id="scrollBtn" value="scroll(0, 1000)" />
<script>
    document.getElementById('scrollBtn').addEventListener('click', function(){
        window.scrollTo(0, 1000);
    })
</script>
<div>
    <div id="target">
        Coding
    </div>
</div>



1920*1080

# 스크린의 크기
window.inner*은 뷰포트의 크기를 나타내고, screen.*은 스크린의 크기를 나타낸다.

<script>
console.log('window.innerWidth:', window.innerWidth, 'window.innerHeight:', window.innerHeight);
console.log('screen.width:', screen.width, 'screen.height:', screen.height);
</script>


# 이벤트란?
이벤트(event)는 어떤 사건을 의미한다. 브라우저에서의 사건이란 사용자가 클릭을 했을 '때', 스크롤을 했을 '때', 필드의 내용을 바꾸었을 '때'와 같은 것을 의미한다. 

<!DOCTYPE html>
<html>
<body>
    <input type="button" onclick="alert(window.location)" value="alert(window.href)" />
    <input type="button" onclick="window.open('bom.html')" value="window.open('bom.html')" />
</body>
</html>

onclick 속성의 자바스크립트 코드(alert(window.location))는 사용자가 이 버튼을 클릭 했을 '때' 실행된다. 즉 js 개발자는 어떤 일이 발생했을 때 실행 되어야 하는 코드를 등록하고, 브라우저는 그 일이 발생했을 때 등록된 코드를 실행하게 된다. 이러한 방식을 이벤트 프로그래밍이라고 한다.

# event target
<input type="button" onclick="alert(window.location)" value="alert(window.href)" />

# event type
이벤트의 종류를 의미한다. 위의 예제에서는 click이 이벤트 타입이다. 그 외에도 scroll은 사용자가 스크롤을 움직였다는 이벤트이고, mousemove는 마우스가 움직였을 때 발생하는 이벤트이다.

# event handler
이벤트가 발생했을 때 동작하는 코드를 의미한다. 위의 예제에서는 alert(window.location)이 여기에 해당한다.


# inline
인라인(inline) 방식으로 이벤트를 등록하는 방법을 알아보자. 인라인 방식은 이벤트를 이벤트 대상의 태그 속성으로 지정하는 것이다. 다음은 버튼을 클릭했을 때 Hello world를 경고창으로 출력한다.

<input type="button" onclick="alert('Hello world');" value="button" />
이벤트가 발생한 대상을 필요로하는 경우 this를 통해서 참조할 수 있다.


<!--자기 자신을 참조하는 불편한 방법-->
<input type="button" id="target" onclick="alert('Hello world, '+document.getElementById('target').value);" value="button" />
<!--this를 통해서 간편하게 참조할 수 있다-->
<input type="button" onclick="alert('Hello world, '+this.value);" value="button" />

인라인 방식은 태그에 이벤트가 포함되기 때문에 이벤트의 소재를 파악하는 것이 편리하다. 하지만 정보인 HTML과 제어인 JavaScript가 혼재된 형태이기 때문에 바람직한 방법이라고 할수는 없다. 


# 프로퍼티 리스너

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>MisterHaru Clan Scrim</title>
        <style>
    
        </style>
    </head>
    <body>
        <input type="button" id="target" value="button" />

        <script>
            var t = document.getElementById('target');
            t.onclick = function(event){
                var event = event || window.event;
                //alert('Hello World, '+event.target.value)
                console.dir(event);
                console.log(event.target);
            }
        </script>
    </body>
</html>

# 이벤트 객체
이벤트가 실행된 맥락의 정보가 필요할 때는 이벤트 객체를 사용한다. 이벤트 객체는 이벤트가 실행될 때 이벤트 핸들러의 인자로 전달된다. 
<body>
    <input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        alert('Hello world, '+event.target.value)
    }
</script>

//ie8 이하 버전에서는 이벤트 객체를 핸들러의 인자가 아니라 전역객체의 event 프로퍼티로 제공한다. 또한 target 프로퍼티도 지원하지 않는다. 아래는 이 문제를 해소하기 위한 코드다.
<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        var event = event || window.event;
        var target = event.target || event.srcElement;
        alert('Hello world, '+target.value)
    }
</script>


# addEventListener()
addEventListener은 이벤트를 등록하는 가장 권장되는 방식이다. 이 방식을 이용하면 여러개의 이벤트 핸들러를 등록할 수 있다.


<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    });
</script>


이 방식은 ie8이하에서는 호환되지 않는다. ie에서는 attachEvent 메소드를 사용해야 한다. 

var t = document.getElementById('target');
if(t.addEventListener){
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    }); 
} else if(t.attachEvent){
    t.attachEvent('onclick', function(event){
        alert('Hello world, '+event.target.value);
    })
}

이 방식의 중요한 장점은 하나의 이벤트 대상에 복수의 동일 이벤트 타입 리스너를 등록할 수 있다는 점이다. 

<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert(1);
    });
    t.addEventListener('click', function(event){
        alert(2);
    });
</script>

이벤트 객체를 이용하면 복수의 엘리먼트에 하나의 리스너를 등록해서 재사용할 수 있다. 

<input type="button" id="target1" value="button1" />
<input type="button" id="target2" value="button2" />
<script>
    var t1 = document.getElementById('target1');
    var t2 = document.getElementById('target2');
    function btn_listener(event){
        switch(event.target.id){
            case 'target1':
                alert(1);
                break;
            case 'target2':
                alert(2);
                break;
        }
    }
    t1.addEventListener('click', btn_listener);
    t2.addEventListener('click', btn_listener);
</script>



## 이벤트 전파(버블링과 캡처링)

<html>
    <head>
        <style>
            html{border:5px solid red;padding:30px;}
            body{border:5px solid green;padding:30px;}
            fieldset{border:5px solid blue;padding:30px;}
            input{border:5px solid black;padding:30px;}
        </style>
    </head>
    <body>
        <fieldset>
            <legend>event propagation</legend>
            <input type="button" id="target" value="target">          
        </fieldset>
        <script>
        function handler(event){
            var phases = ['capturing', 'target', 'bubbling']
            console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
        }
        document.getElementById('target').addEventListener('click', handler, true);
        document.querySelector('fieldset').addEventListener('click', handler, true);
        document.querySelector('body').addEventListener('click', handler, true);
        document.querySelector('html').addEventListener('click', handler, true);
        </script>
    </body>
</html>

//실행결과
INPUT HTML capturing
INPUT BODY capturing
INPUT FIELDSET capturing
INPUT INPUT target

이벤트가 부모에서부터 발생해서 자식으로 전파되고 있다. 이러한 방식을 capturing이라고 한다

document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', handler, false);
document.querySelector('html').addEventListener('click', handler, false);

//아래처럼 코드를 변경해보자.
function handler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
}
function stophandler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
    event.stopPropagation();
}
document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', stophandler, false);
document.querySelector('html').addEventListener('click', handler, false);


//실행결과
INPUT INPUT target
INPUT FIELDSET bubbling
INPUT BODY bubbling

//stopPropagation


# 기본동작의 취소

//inline
이벤트의 리턴값이 false이면 기본 동작이 취소된다.

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org" onclick="if(document.getElementById('prevent').checked) return false;">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org" onsubmit="if(document.getElementById('prevent').checked) return false;">
            <input type="submit" />
    </form>
</p>


//property 방식
리턴 값이 false이면 기본동작이 취소된다

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org">
            <input type="submit" />
    </form>
</p>
<script>
    document.querySelector('a').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };
    
    document.querySelector('form').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };

</script>

//addEventListener 방식
이 방식에서는 이벤트 객체의 preventDefault 메소드를 실행하면 기본 동작이 취소된다.

<p>
            <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
        </p>
        <p>
            <a href="http://opentutorials.org">opentutorials</a>
        </p>
        <p>
            <form action="http://opentutorials.org">
                    <input type="submit" />
            </form>
        </p>
        <script>
            document.querySelector('a').addEventListener('click', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });
            
            document.querySelector('form').addEventListener('submit', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });

        </script>


# 이벤트 타입
	
<input type="button" onclick="alert(1);" />

//폼
//submit
submit은 폼의 정보를 서버로 전송하는 명령인 submit시에 일어난다.

form 태그에 적용된다.

아래 예제는 전송 전에 텍스트 필드에 값이 입력 되었는지를 확인한다. 만약 값이 입력되지 않았다면 전송을 중단한다.

<form id="target" action="result.html">
    <label for="name">name</label> <input id="name" type="name" />
    <input type="submit" />
</form>
<script>
var t = document.getElementById('target');
t.addEventListener('submit', function(event){
    if(document.getElementById('name').value.length === 0){
        alert('Name 필드의 값이 누락 되었습니다');
        event.preventDefault();
    }
});
</script>


# event.preventDefault();

//change
change는 폼 컨트롤의 값이 변경 되었을 때 발생하는 이벤트다.

input(text,radio,checkbox), textarea, select 태그에 적용된다.

<p id="result"></p>
<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('change', function(event){
    document.getElementById('result').innerHTML=event.target.value;
});
</script>


//blur, focus
focus는 엘리먼트에 포커스가 생겼을 때, blur은 포커스가 사라졌을 때 발생하는 이벤트다. 

다음 태그를 제외한 모든 태그에서 발생한다. <base>, <bdo>, <br>, <head>, <html>, <iframe>, <meta>, <param>, <script>, <style>, <title>

<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('blur', function(event){
    alert('blur');  
});
t.addEventListener('focus', function(event){
    alert('focus'); 
});
</script>



# 문서 로딩
웹페이지를 프로그래밍적으로 제어하기 위해서는 웹페이지의 모든 요소에 대한 처리가 끝나야 한다. 이것을 알려주는 이벤트가 load, DOMContentLoaded이다.

아래 코드의 실행결과는 null이다. <p id="target">Hello</p>가 로딩되기 전에 자바스크립트가 실행되었기 때문이다.

<html>
    <head>
        <script>
            window.addEventListener('load', function(){
                console.log('load');
            })
            window.addEventListener('DOMContentLoaded', function(){
                console.log('DOMContentLoaded');
            })
        </script>
    </head>
    <body>
        <p id="target">Hello</p>
    </body>
</html>


# 마우스
//이벤트 타입
웹브라우저는 마우스와 관련해서 다양한 이벤트 타입을 지원한다.

click
클릭했을 때 발생하는 이벤트. 
dblclick
더블클릭을 했을 때 발생하는 이벤트
mousedown
마우스를 누를 때 발생
mouseup
마우스버튼을 땔 때 발생
mousemove
마우스를 움직일 때
mouseover
마우스가 엘리먼트에 진입할 때 발생
mouseout
마우스가 엘리먼트에서 빠져나갈 때 발생
contextmenu
컨텍스트 메뉴가 실행될 때 발생


# //키보드 조합  https://www.opentutorials.org/

<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>li {padding:10px; list-style: none}</style>
</head>

<body>

    
    <style>
        body{
            padding:0;
            margin:0;
        }
        div{
            border:50px solid #1065e6;
            padding:50px;
            margin:50px;
        }
        #target{
            width:100px;
            height:2000px;
        }
    </style>
    <input type="button" id="scrollBtn" value="scroll(0, 1000)" />
    <script>
        document.getElementById('scrollBtn').addEventListener('click', function(){
            window.scrollTo(0, 1000);
        })
    </script>
    <div>
        <div id="target">
            Coding
        </div>
    </div>
</body>
</html>



# 코드잇 자바스크립트 수업 내용

# 함수

function expressMultiplication(a, b) {
  console.log(String(a) + " * " + String(b) + " = " + String(a * b));
}
// 테스트 코드
expressMultiplication(3, 4);
expressMultiplication(3, 2);
expressMultiplication(7, 5);
expressMultiplication(8, 9);
expressMultiplication(5, 5);
expressMultiplication(9, 9);

</> 실행 결과
3 * 4 = 12
3 * 2 = 6
7 * 5 = 35
8 * 9 = 72
5 * 5 = 25
9 * 9 = 81


# return
return: 돌려주다
미국 단위인 '인치(inch)'를 '센티미터(cm)'로 변환 시켜주는 함수 inchToCentimeter를 작성했습니다.

(1)  function inchToCentimeter(inch) {
(2)      var centimeter = inch * 2.54;  // 1 inch = 2.54cm
(3)      return centimeter;             // cm로 계산한 결괏값 돌려주기
(4)  }
(5)  
(6)  var result1 = inchToCentimeter(2); // 2 inch를 cm로 바꾼 값
(7)  var result2 = inchToCentimeter(3); // 3 inch를 cm로 바꾼 값
(8) 
(9)  console.log(result1);
(10) console.log(result2);
(11) console.log(inchToCentimeter(1) + inchToCentimeter(5));
5.08
7.62
15.24
코드를 보면 return이라는 게 있죠? 'return'은 한국말로 '돌려주다'입니다. 누가 누구에게 무엇을 돌려준다는 얘기일까요?

6번 줄을 보시면 inchToCentimeter 함수가 호출됩니다.
inch의 값으로 2가 들어가기 때문에 centimeter에는 2 * 2.54인 5.08이 들어갑니다.
3번 줄에서 return centimeter를 하기 때문에 inchToCentimeter 함수는 5.08을 '돌려주게' 됩니다.
함수를 호출한 부분인 inchToCentimeter(2)는 5.08을 '돌려받아서', inchToCentimeter(2)가 5.08로 대체된다고 보시면 됩니다. 따라서 result1에는 5.08이 저장됩니다.
7번 줄에도 함수 호출이 있고, 11번 줄에는 함수 호출이 두 개가 있습니다. 콘솔에 7.62와 15.24가 출력되는 과정 이해 되시나요?


======

function calculateRectangleArea(x, y) {
    var ares = x * y;
    return ares;
}


// 테스트 코드
var area1 = calculateRectangleArea(3, 4); // 가로 3, 세로 4인 직사각형의 넓이 계산
var area2 = calculateRectangleArea(5, 8); // 가로 5, 세로 8인 직사각형의 넓이 계산
var area3 = calculateRectangleArea(7, 2); // 가로 7, 세로 2인 직사각형의 넓이 계산

console.log('Area1: ' + area1 + ', Area2: ' + area2 + ', Area3: ' + area3);


# 정답
function calculateRectangleArea(x, y) {
    return x * y;
}

# 형 변환 함수
우리도 이미 내장 함수를 쓴 적이 있습니다.

바로 형 변환 함수!

String(3);
Number('7');
첫 줄의 함수 이름은 String이고, 파라미터로 숫자 3을 받고, 문자열 '3'을 리턴해주는 거죠. 두 번째 줄의 함수 이름은 Number이고, 파라미터로 문자열 '7'을 받고 숫자 7을 리턴해줍니다.

이 두 함수는 분명 우리가 선언을 안 했는데도 잘 작동하네요. 자바스크립트 내부에서 미리 선언을 해준 것입니다. 숫자를 문자열로, 또는 문자열을 숫자로 바꾸는 함수는 누구에게나 필요할 것 같아서 이미 구현되어 있습니다.

# parseInt 함수
Number 함수와 비슷한 parseInt라는 함수도 있는데요. Number와는 조금 다르게, 파라미터가 '100세'처럼 숫자랑 문자가 섞여 있으면 숫자만 꺼내서 변환시켜줍니다.

parseInt('100세');
parseInt('세100');
100
NaN
하지만 보시다시피 숫자가 앞에 있어야 제대로 작동합니다. parseInt('세100')을 했을 때 나오는 NaN은 'Not a Number(숫자가 아니다)'의 약자입니다.

# 그 외의 내장 함수
alert, prompt, console.log도 자바스크립트에서 미리 준비해둔 함수들입니다. 내장 함수를 잘 알아두면 우리의 코딩 시간을 단축할 수 있겠죠?

이 외에도 다양한 내장 함수가 준비되어있지만 사용법은 동일합니다. 보통은 필요할 때 즉석에서 찾아보고 활용하는 경우가 많습니다.


String()	숫자를 문자열로 변환해주는 함수.
Number()	문자열을 숫자로 변환해주는 함수.
parseInt()	문자열 안에서 정수를 뽑아주는 함수.
parseFloat()	문자열 안에서 숫자(소수 포함)를 뽑아주는 함수.
alert()	사용자에게 메시지를 띄워주는 함수.
prompt()	사용자에게 메시지를 띄우고, 문자열을 입력받는 함수.
confirm()	사용자에게 메시지를 띄우고, 확인과 취소 중 하나를 누르게 하는 함수.





# if문
<script>
var inputNumber = window.prompt("한 자리 숫자를 적어주세요.");

if (inputNumber === '7') {
    alert('Lucky!');
}   else if (inputNumber === '0') {
    alert('Zero');
}   else if (inputNumber === '1') {
    alert('One');
}   else {
    alert('Unlucky!');
}
</script>

# 14가 6의 배수인지 확인
var num = 14;
if (num % 2 === 0 && num % 3 === 0) {
    console.log(num + '는 6의 배수입니다.');
} else {
    console.log(num + '는 6의 배수가 아닙니다.');
}

## 숫자를 입력 받을수 있도록 재 코딩
var inputNumber = window.prompt("6의 배수를 적어주세요.");

if (inputNumber % 2 === 0 && inputNumber % 3 === 0) {
    console.log(inputNumber + '는 6의 배수입니다.');
} else {
    console.log(inputNumber + '는 6의 배수가 아닙니다.');
}



<script>

function whatShouldICallYou(myAge, myGender, yourAge, yourGender) {
    // 나의 나이, 나의 성별, 상대방의 나이, 상대방의 성별
    // 총 4개의 정보를 활용해서 호칭을 결정해보세요.
if (myAge === yourAge){
    return "친구";
} else if (myAge > yourAge) {
    if (yourGender === "male") {
    return "남동생";
} else if (yourGender === "female") {
    return "여동생";
} 
} else if (myGender === "male") {
    if (yourGender === "male") {
    return "형";
    } else if (yourGender === "female") {
    return "누나";
    }
} else if (myGender === "female") {
    if (yourGender === "male") {
    return "오빠";
    } else if (yourGender === "female") {
    return "언니";
    }
}
}
// 테스트 코드
var result1 = whatShouldICallYou(23, 'male', 25, 'female');
var result2 = whatShouldICallYou(21, 'female', 21, 'female');
var result3 = whatShouldICallYou(25, 'female', 22, 'male');

console.log(result1);
console.log(result2);
console.log(result3);

</script>


# switch문
// switch 문 뒤에 break를 꼭 넣어 줘야 한다. 그렇지 않으면 뒤쪽에 모두 alert가 표시 된다.


switch (inputNumber) {
    case '0':
        alert('Zero!');
        break;
    case '1':
        alert('Oneo!');
        break;
    case '7':
        alert('Lucky!');
        break;
    default:
        alert('Unlucky!');
        break;
}


# 파이썬은  switch문이 없으므로 if문으로 작성해야 한다. 자바스크립트에서만 스위치문 사용

# for반복문

for (초기화부분; 조건부분; 추가동작부분) {
    동작부분
}

for ( let i = 1; i <= 10; i++) {
    console.log('${i} 미스터하루');
}




# 문제 : 주어진 높이(height)에 맞게 *로 삼각형을 그려주는 함수 printTriangle을 써봅시다. 출력 결과는 아래를 참고해주세요.


높이: 5
*
**
***
****
*****
높이: 3
*
**
***
높이: 1
*


function printTriangle(height) {
    // 이 함수 안에서 console.log를 직접 사용하여
    // 직접 출력까지 완료해야 합니다.
    // 이 함수는 return 값이 없습니다.
    text = '';
    for(var i = 0; i < height; i = i + 1){
        text = text + '*';
        console.log(text);
    }
}

// 테스트 코드
console.log('높이: 5');
printTriangle(5);

console.log('높이: 3');
printTriangle(3);

console.log('높이: 1');
printTriangle(1);



# 문제

1등만 기억하는 세상을 타파하기 위해, 2등을 찾아보는 프로그램을 만들기로 했습니다.

파라미터로 배열 arr을 받고, arr에서 두 번째로 큰 숫자를 리턴시켜주는 함수 getSecondBiggestNumber를 작성해주세요.

코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

7
80
6


function getSecondBiggestNumber(arr) {
    // 코드를 작성하세요.
    var first = arr[0];
    var second = arr[1];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] > first) {
            second = first;
            first = arr[i];
        } else if (arr[i] > second) {
            second = arr[i]
        }
    }
    return second;
}

// 테스트 코드
console.log(getSecondBiggestNumber([4, 7, 2, 1, 9, 3, 6, 5]));
console.log(getSecondBiggestNumber([80, 2, 44, 21, 92, 3, 51]));
console.log(getSecondBiggestNumber([4, 7, 6, 5]));


# for of반복문

var brand = ['NIKE', 'ADIDA', 'REEBOK'];

for (var value of brands) {
    console.log(value);
}

=====

for (var [변수] of brands) {
    console.log(변수);
}



for...in문과 for...of문의 차이
우선 for...in문과 for...of문의 차이부터 살펴봅시다.

var arr =  ['Americano', 'Latte', 'Tea'];

// for...of
for (var v of arr) {
  console.log(v);
}

console.log('---');

// for...in
for (var k in arr) {
  console.log(k);
}
Americano
Latte
Tea
---
0
1
2
차이점이 보이시나요?

배열은 여러 개의 index-value 쌍으로 이루어졌다고 볼 수 있는데요. 위 코드의 arr배열의 경우에 index는 0, 1, 2이고, value는 'Americano', 'Latte', 'Tea'입니다.

출력된 결과를 보시면 알 수 있듯 for...of문은 배열의 value에 직접 접근하는 반면, for...in문은 index에 접근합니다.

for...in문으로 value에 접근하기 위해서는 이렇게 바꿔줘야겠죠?

// for...in
for (var k in arr) {
  console.log(arr[k]);
}
Americano
Latte
Tea



# while 반복문
var brands = ['apple', 'coca-cola', 'starbucks', 'amazon', 'disney', 'BMW'];

var i = 0;

while (i < 6) {
    console.log(brands[i]);
    i++
}


# break문
만약 while문의 조건부분과 상관 없이 반복문에서 나오고 싶으면 break문을 쓰면 됩니다.

var i = 100;

while (true) {
    // i가 23의 배수면 반복문을 끝냄
    if (i % 23 == 0) {
        break;
    }
    i = i + 1;
}

console.log(i);

115


# continue문
만약 현재 진행되고 있는 수행부분을 중단시키고 바로 조건부분을 다시 확인하고 싶으면 continue문을 쓰면 됩니다.

var i = 0;

while (i < 15) {
    i = i + 1;

    // i가 홀수면 console.log(i) 안하고 바로 조건부분으로 돌아감
    if (i % 2 == 1) {
        continue;
    }
    console.log(i);
}


2
4
6
8
10
12
14

# 로그인 모듈
사용자에게 아이디와 비밀번호를 입력받아서 '로그인' 시키는 모듈을 아래 두 가지 방법으로 만들어봅시다:

1. 다섯 번의 기회만 주는 모듈
2. 성공할 때까지 기회를 무제한으로 주는 모듈

# 횟수 제한 (for문)
// 최대 다섯 번의 기회를 준다
for (var i = 0; i < 5; i++) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    break;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

# 무제한 (while문)

// 로그인 성공 여부를 보관하는 변수
var login = false;

// 로그인에 성공할 때까지 반복
while (!login) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    login = true;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

//for문과 while문의 차이를 눈치 채셨나요? 물론 이분법적으로 나눌 수 있는 얘기는 아니지만, 일반적으로 반복 횟수가 예측 가능할 때에는 for문을 사용하는 것이 더 눈에 잘 들어옵니다. 반대로 반복 횟수를 예측할 수 없으면 while문을 쓰는 것이 더 적합한 경우가 많겠죠?



#문제

0! = 1
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
6! = 6 * 5 * 4 * 3 * 2 * 1 = 720
파라미터로 정수 n을 받고 n!을 계산해서 리턴해주는 함수 factorial을 작성해주세요.

코드를 잘 작성하셨다면 아래와 같이 출력되어야 합니다.
3628800
120
6
1


function factorial(num) {
    var factorialValue = 1;
    // 코드를 작성하세요.
    if (num > 1) {
        for(var i = 1; i <= num; i++){
            factorialValue = factorialValue * i;
        }
    }
    return factorialValue;
}

console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));



더 간단하게 작성

function factorial(n) {
    var result = 1;

    for (var i = 1; i <= n; i++) {
        result = result * i;
    }
    return result;
}

// 테스트 코드
console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));


# 배열 만들기 I
배열에 push 메소드를 사용하면 배열 마지막 칸에 값이 추가됩니다
var arr = [2, 3, 5, 7];
arr.push(11);
console.log(arr);

[2, 3, 5, 7, 11]



# 문제
범위의 시작 지점(start), 끝 지점(end), 그리고 증가폭(step)을 파라미터로 받고, 그에 해당하는 배열을 리턴해주는 함수 range를 작성해주세요.


function range(start, end, step) {
    var arr = [];
    var idx = 0;

    if (start < end) {
        for (var i = start; i < end; i += step) {
            arr[idx] = i;
            idx++;
        }
    } else {
        for (var i = start; i > end; i += step) {
            arr[idx] = i;
            idx++;
        }
    }
    return arr;
}
// 테스트 코드
console.log(range(1, 10, 1));
console.log(range(-1, 10, 3));
console.log(range(10, -10, -4));

[1, 2, 3, 4, 5]
[3, 5, 7, 9]
[10, 6, 2, -2, -6]


# 문제
아래의 조건에 맞게 원래의 배열로 돌려놓는 함수 restoreArray를 만들어주세요.

2중 배열이 아닌, 하나의 배열로 통합한다.
배열 안의 배열에 있는 숫자들은 순서를 뒤바꾼다.
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]
먼저 2중 배열을 하나의 배열로 만들어봅시다.
for문을 사용하여 arr의 각 요소에 대해 length를 확인하고, 그 length만큼 다시 반복해주면서 returnArr에 추가합니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

위와 같이 작성하면 하나의 배열로 만들었지만, 순서가 뒤집히지 않았습니다.
위의 코드를 조금 더 고쳐봅시다.

두 번째 for문에서, j를 0부터 arr[i].length까지 증가시키는 것이 아니라 arr[i].length부터 0까지 감소시키면 뒤집힌 순서로 추가할 수 있습니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = arr[i].length - 1; j >= 0; j--) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]

# 문제
// 코드를 입력해 주세요.
function teraToGiga(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 + 'GB 입니다.');
}

function teraToMega(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 * 1024 + 'MB 입니다.');
}

// TB -> GB 테스트
teraToGiga(2);

// TB -> MB 테스트
teraToMega(2);


function score(kill, win){
    result = kill + wing;
    console.log(result);
}
score(10,5);


# then 메소드 제대로 익히기

Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => {
  // return response.json(); // <- Case(1)
   //return 10; // <- Case(2)
    // // <- Case(3)
    //throw new Error('failed'); // <- Case(4)
})
  .then((result) => {
    console.log(result);
  });


Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

각 케이스별 코드 앞에 있는 주석을 선택적으로 해제 및 적용해가면서 각각 어떤 결과가 출력되는지 살펴보세요.

# 해설
then 메소드가 리턴한 Promise 객체를 A라고 했을 때, 각 경우에 A는 다음과 같은 상태와 결과를 갖게 됩니다.

Case(1) : 콜백에서 Promise 객체를 리턴

콜백이 리턴한 Promise  객체를 B라고 하면 A는 B와 동일한 상태와 결과를 갖게 됩니다. 나중에 B가 fulfilled 상태가 되면 A도 똑같이 fulfilled 상태가 되고 동일한 작업 성공 결과를, 나중에 B가 rejected 상태가 되면 A도 똑같이 rejected 상태가 되고 동일한 작업 실패 정보를 가진다는 뜻입니다.

Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴

A는 fulfilled 상태가 되고, 해당 리턴값을 작업 성공 결과로 갖게 됩니다.

Case(3) : 콜백에서 아무것도 리턴하지 않음

자바스크립트에서는 함수가 아무것도 리턴하지 않으면 undefined를 리턴한 것으로 간주합니다. 
따라서 A는 fulfilled 상태가 되고, undefined를 작업 성공 결과로 갖게 됩니다.

Case(4) : 콜백 실행 중 에러 발생

A는 rejected 상태가 되고, 해당 에러 객체를 작업 실패 정보로 갖게 됩니다.

Case(5) : 콜백이 실행되지 않음

A는 호출된 then 메소드의 주인에 해당하는, 이전 Promise 객체와 동일한 상태와 결과를 가집니다.

Promise 객체 공부는 then 메소드가 그 처음과 끝이라고 해도 될 정도로, then 메소드를 정확하게 이해하는 것이 중요합니다. 지금 각각의 케이스를 잘 기억해 두면, 앞으로의 내용을 훨씬 더 쉽게 이해할 수 있을 겁니다.


Promise 객체는 크게 3가지 중 하나의 상태를 가집니다. 작업이 아직 완료되지 않았으면 pending 상태, 작업이 성공적으로 잘 완료되었다면 fulfilled 상태, 작업이 실패했다면 rejected 상태가 되는데요. 즉, 최초의 pending 상태에서 fulfilled 상태 또는 rejected 상태로 변하는 겁니다. 참고로, pending 상태에서 한번 fulfilled 상태 또는 rejected 상태가 되면 다시 다른 상태를 가질 수 없습니다.

# 문제
만약 인터넷이 안되는 상황에서 아래 코드를 실행한다면 무슨 문자열이 출력될까요?
fetch('https://jsonplaceholder.typicode.com/')
  .then((result) => { console.log('success'); }, (error) => { console.log('fail'); });

인터넷이 안 되는 상태에서는 fetch 함수의 작업이 실패하겠죠? 그럼 fetch 함수가 리턴한 Promise 객체가 rejected 상태가 되고, 이렇게 Promise 객체가 rejected 상태가 되면. then 메소드의 두 번째 콜백이 실행됩니다. 잘 기억하세요!

자바스크립트에서는 함수가 아무것도 리턴하지 않으면, undefined를 리턴한 것으로 봅니다. 따라서 콜백에서 아무것도 리턴하지 않아도 undefined를 리턴한 것으로 보아서, A는 fulfilled 상태가 되고, 작업 성공 결과로 undefined를 갖게 됩니다. Promise Chaining을 완벽하게 이해하려면 then 메소드에 관한 이런 규칙들을 제대로 이해해야 합니다.


#  catch 메소드

fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), (error) => { console.log(error); })
    .then((result) => { console.log(result); });

# then 메소드와 catch 메소드의 역할이 동일.
fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), 
    .catch((error) => { console.log(error); })
    .then((result) => { console.log(result); });


# catch 메소드를 마지막에 사용
fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.json())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });



# 어디서 발생한 에러인지 확인해보기

    .catch((error) => { 
        if(error.message === 'A'){

        }else if(error.message === 'B'){

        }else if(error.message === 'C'){

        }else{

        }
    });


====
.catch((error) => { 
    if(error instanceof TypeError){

    }else if(error instanceof CustomErrorType_A){

    }else if(error instanceof CustomErrorType_B){

    }else{

    }
});

# catch 메소드를 여러 개 쓰는 경우

우리는 이제 catch 메소드를 Promise Chain 가장 마지막에 붙임으로써, 중간에 에러가 발생해서 어느 Promise 객체가 rejected 상태가 되더라도 항상 대처할 수 있도록 해야 한다는 걸 배웠습니다. 하지만 catch 메소드를 마지막뿐만 아니라 Promise Chain 중간중간에 쓰는 경우도 존재합니다. 만약 중간에 에러가 발생해도 catch 메소드가 그 대안을 뒤로 넘겨줄 수 있으면 catch 메소드를 중간에 써도 되는데요.

아래 코드를 잠깐 봅시다.

fetch('https://friendbook.com/my/newsfeeds')
  .then((response) => response.json()) // -- A
  .then((result) => { // -- B
    const feeds = result;
    // 피드 데이터 가공...
    return processedFeeds; 
  })
  .catch((error) => { // -- C
    // 미리 저장해둔 일반 뉴스를 보여주기  
    const storedGeneralNews = getStoredGeneralNews();
    return storedGeneralNews;
  })
  .then((result) => { /* 화면에 표시 */ }) // -- D
  .catch((error) => { /* 에러 로깅 */ }); // -- E
이 코드는 어떤 SNS 웹 사이트에서 나에게 최적화된 뉴스피드(newsfeed)를 보여주는 코드라고 가정해봅시다. 만약 서버로부터 뉴스피드가 잘 조회되면 현재 코드에서 A, B, D 줄에 있는 콜백들이 잘 실행되고, 사용자에게 뉴스피드가 잘 표시되겠죠? 하지만 만약 사용자의 컴퓨터가 인터넷에 연결되어 있지 않은 상태라서 fetch 함수의 작업이 실패한다면 어떻게 될까요? 그럼 이제 이 Promise Chain의 작업은 실패했다고 생각하고, 이전에 배운 것처럼 그냥 마지막에만 catch 메소드를 두고 끝내면 되는 걸까요? 꼭 그렇지는 않습니다. 만약 작업을 살릴 수 있는 방법이 있다면 살리는 게 좋겠죠?

지금 C줄에 있는 콜백을 보세요. fetch 함수의 작업이 실패하면 C 줄의 콜백이 실행됩니다. 사실, 이 SNS 서비스의 웹 페이지에서는 사용자가 매번 뉴스피드를 볼 때마다, 나중에 오프라인 상태가 될 때를 대비해서 모든 사람이 공통으로 볼 수 있는, 텍스트로만 이루어진 최근 일반 뉴스 데이터를 갱신해서 웹 브라우저에 저장한다고 해봅시다. C줄의 콜백은 바로 이렇게 저장해둔 일반 뉴스 데이터를 그대로 가져오는 기능을 합니다. 이렇게 되면 인터넷이 안 되는 상황에서도 나만을 위한 최적화된 뉴스피드는 못 보지만 일반적인 세상 뉴스는 사용자가 볼 수 있게 되겠죠?

이렇게 Promise Chain 중에서 비록 에러가 발생했다고 해도 만약 실패한 작업 대신 다른 방법을 통해서 작업을 정상적으로 끝마칠 수 있는 상황이라면 catch 메소드를 중간에 사용하기도 합니다. 그러니까 Promise Chain 중에서 단 하나의 작업이라도 실패하면 전체 작업이 실패했다고 봐도 되는 경우에는 그냥 Promise Chain 마지막에만 catch 메소드를 써주면 되겠지만, 어떤 작업들은 에러가 발생하더라도 다른 방식으로 복구해서 살려낼 방법이 있다면 catch 메소드 안의 콜백에서 그런 복구 작업을 해주면 되는 겁니다. 지금 위 코드에서는 미리 저장해둔 일반 뉴스 데이터를 구해오는 getStoredGeneralNews 함수를 실행하는 것처럼요.

catch 메소드를 Promise Chain의 마지막에 늘 써줘야 하는 것은 맞지만, 작업을 살릴 방법이 있다면 Promise Chain 중간에 catch 메소드를 써도 된다는 사실, 잘 기억해두세요.



# finally 메소드
// catch 메소드 이후에 사용한다.

fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.text())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });
    .finally(() => { console.log('exit'); });

// catch method가 return한 Promise 객체를 rejected 함.
.catch((error) => {
    console.log(error); 
    throw new Error('from catch method');
});


#실습 설명

Promise Chain에서 늘 모든 작업이 정상적으로 수행되고 종료되는 것은 아닙니다. 모든 작업이 순차적으로 정상 수행되는 경우도 있고 중간에 문제가 생겨서 그렇지 못하는 경우도 있어요. 이 두 가지 중 어느 경우가 됐든 마지막에 항상 처리해 줘야하는 작업이 있을 때는 finally 메소드를 사용합니다.

지금 코드잇 실행기에는 어떤 웹 페이지의 로딩(loading) 아이콘에 관한 코드가 있습니다. 이 코드에서는 어떤 URL로 리퀘스트를 보내기 전에 isLoading이라는 변수의 값을 true로 설정하고, 로딩 아이콘을 띄운 후에 리퀘스트를 보내는데요.

첫 번째 then 메소드의 콜백을 보면, 리스폰스의 헤드에서 'content-type' 헤더를 찾아 그 값을 읽고 만약 'application/json'이라는 값을 포함하고 있다면 즉, 리스폰스의 바디에 JSON 포맷의 데이터가 들어있다면 이를 Deserialize해서 다음으로 넘깁니다. 하지만 'application/json' 타입이 아니라면 인위적으로 에러를 발생시킵니다.

그런데 어떤 경우든 상관없이 모든 작업이 끝나고 나면, isLoading 변수의 값은 false로 설정해 줘야 합니다. 
왜냐하면 이 isLoading 변수는 현재 사용자의 리퀘스트에 대한 처리가 이루어지고 있고, 로딩 아이콘이 화면에서 나타나있는지 여부를 나타냄으로써, 더 이상 사용자가 마우스를 아무리 클릭해도 리퀘스트를 또 보내는 것을 막고, 그 밖의 다른 작업이 시작되지 못하도록 막아야하는지를 판단하기 위한 기준으로 사용되기 때문입니다. (실무에서는 이런 변수를 사용하는 것 말고 다른 좋은 방법들도 있지만 일단은 간단한 코드로 배워 봅시다.)

어떤 경우든 마지막에 isLoading 변수의 값이 false가 되어야, 이 웹 페이지는 전체 작업의 성공 여부와 상관없이 앞으로도 정상적으로 동작할 수 있는데요. 필요한 코드를 추가해서 어떤 경우든 isLoading 변수의 값을 false로 만들고 그 값을 출력해 보세요.

참고로, 코드 상단의 URL 두 개 중에서 첫 번째는 JSON 데이터가 오는 URL이고, 두 번째는 HTML 등의 코드가 오는 URL입니다.

각 URL 앞의 주석을 번갈아 해제해서 코드를 실행해보고 isLoading 변수가 항상 false가 되는지 확인해 보세요.

let isLoading = true;

/* ..다른 코드들 */

const url = 'https://jsonplaceholder.typicode.com/users';
// const url = 'https://www.google.com';

fetch(url)
  .then((response) => {
    const contentType = response.headers.get('content-type');
    if (contentType.includes('application/json')) {
      return response.json();
    }
    throw new Error('response is not json data');
  })
  .then((result) => {
    // 리스폰스 처리
    console.log(result);
  })
  .catch((error) => {
    // 에러 처리
    console.log(error);
  })
  .finally(() => {
    isLoading = false;
    console.log(isLoading);
  });

/* ..다른 코드들 */


# 변수와 스코프

var x;  //함수 스코프 (function scope)
let y;  //블록 스코프 (block scope)
const z;  //블록 스코프 (block scope)

# 종합 정리
자바스크립트의 데이터 타입
자바스크립트에는 8가지 데이터 타입이 있습니다.

number
string
boolean
undefined
null
object
symbol
bigint
자바스크립트의 유연한 데이터 타입
자바스크립트는 데이터 타입이 유연한 프로그래밍 언어입니다. 맥락에 유연하게 변하는 데이터 타입의 특징은 처음엔 생소하고 혼란스러울 수 있지만, 잘 이해하고 활용한다면 좀 더 간결한 코드를 작성하고 빠르게 개발할 수 있는 장점이 될 수 있습니다!

Truthy 값과 Falsy 값
if, for, while 등 불린 타입의 값이 요구되는 맥락에서는 조건식이나 불린 타입의 값 뿐만아니라 다른 타입의 값도 불린 값처럼 평가될 수 있는데요. 이 때, false 처럼 평가되는 값을 falsy 값, true 처럼 평가되는 값을 truthy값이라고 부릅니다. falsy값에는 false, null, undefined, 0, NaN, ''(빈 문자열)이 있고, falsy값을 제외한 값들은 모두 truthy값이 됩니다.

만약 falsy와 truthy값을 명확하게 확인하고 싶다면 Boolean 함수를 사용해서 직접 boolean 타입으로 형 변환 해볼 수도 있습니다.

// falsy
Boolean(false);
Boolean(null);
Boolean(undefined);
Boolean(0);
Boolean(NaN);
Boolean('');

// truthy
Boolean(true);
Boolean('codeit');
Boolean(123);
Boolean(-123);
Boolean({});
Boolean([]);
truthy와 falsy의 개념은 자바스크립트에서 불린 타입으로의 형 변환을 이해할 때 핵심이되는 개념이 잘 기억해 주세요.

독특한 방식으로 동작하는 논리 연산자
자바스크립트에서 AND와 OR연산자는 무조건 불린 값을 리턴하는게 아니라, 왼쪽 피연산자 값의 유형에 따라서 두 피연산자 중 하나를 리턴하는 방식으로 동작합니다.
AND 연산자는 왼쪽 피연산자가 falsy값일 때 왼쪽 피연산자를, 왼쪽 피연산자가 truthy값일 때 오른쪽 피연산자를 리턴하고 반대로, OR 연산자는 왼쪽 피연산자가 falsy 일 때 오른쪽 피연산자를, 왼쪽 피연산자가 truthy 일 때 왼쪽 피연산자를 리턴합니다.

console.log(null && undefined); // null
console.log(0 || true); // true
console.log('0' && NaN); // NaN
console.log({} || 123); // {}
자바스크립트의 다양한 변수 선언 방식
자바스크립트에는 다양한 변수 선언 키워드가 있습니다. 자바스크립트가 처음 등장할 때부터 사용되던 var와, 그리고 var의 부족함을 채우기위해 ES2015에서 새롭게 등장한 let과 const가 있는데요.

var 변수는 아래와 같은 특징이 있었습니다.

변수 이름 중복선언 가능,
변수 선언 전에 사용 가능(호이스팅),
함수 스코프
특히나 중복된 이름으로 선언이 가능했던 특징은 여러 사람이 협업할 때 생각보다 자주 문제가 되곤 했었는데요. 
이런 문제를 개선하기 위해 ES2015에서 let과 const가 등장했고, 다음과 같은 특징이 있습니다.

변수 이름 중복선언 불가 (SyntaxError 발생)
변수 선언 전에 사용 불가 (ReferenceError 발생)
블록 스코프
덧붙여 const 키워드는 let 키워드와 다르게 값을 재할당할 수 없다는 특징도 있습니다.
그래서 ES2015 이후부터는 var보다 let과 const 키워드 사용이 권장된다는 사실도 참고해 두시면 좋을 것 같습니다.

함수 스코프(function scope)와 블록 스코프(block scope)
var 키워드로 선언한 변수는 함수 스코프 let과 const 키워드로 선언한 변수는 블록 스코프를 가집니다.

함수 스코프란 말 그대로 함수를 기준으로 스코프를 구분한다는 뜻인데요. 그렇기 때문에 아래 코드처럼 함수 안에서 선언한 변수는 함수 안에서만 유효하게 됩니다.

function sayHi() {
  var userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

console.log(userName); // ReferenceError
하지만 함수를 제외한 for, if, while 등과 같은 문법 안에서 선언한 변수는 그 문법 밖에서도 계속 유효했었기 때문에 때로는 중복선언등의 문제가 생겨나기도 했는데요.
이런 문제를 해결하기 위해 let과 const 키워드와 함께 블록 스코프가 등장하게 된 겁니다.

for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 5
블록 스코프는 중괄호로 감싸진 코드 블록에 따라 유효 범위를 구분하게 되는데요. 아래 코드에서 볼 수 있듯이 함수와 다른 문법들 뿐만아니라, 그냥 중괄호로 감싸진 코드 블록으로도 유효 범위가 구분되는 모습을 확인할 수 있습니다.

function sayHi() {
  const userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

for (let i = 0; i < 5; i++) {
  console.log(i);
}

{
  let language = 'JavaScript';
}

console.log(userName); // ReferenceError
console.log(i); // ReferenceError
console.log(language); // ReferenceError

# 함수를 만드는 방법
function 함수이름(파라미터) {
    동작;
    return 리턴값;
}
함수 호출;

# 함수를 변수에 할당 하는 방법
const printCodeit = function () {
    console.log('Codeit');
};

printCodeit();


// 함수에 할당하는 방법은 호이스팅이 불가하다. 에러발생

printCodeit();

const printCodeit = function () {
    console.log('Codeit');
};


# 함수호출을 위쪽으로 끌어 올리는 방법을 호이스팅(Hoisting)

printCodeit();

function printCodeit() {
    console.log('Codeit');
};



# 이름이 있는 함수 표현식
Named Function Expression (기명 함수 표현식)
함수 표현식으로 함수를 만들 때는 선언하는 함수에 이름을 붙여줄 수도 있는데요.
이름이 있는 함수 표현식, 즉 기명 함수 표현식이라고 부릅니다.
함수 표현식으로 함수가 할당된 변수에는 자동으로 name이라는 프로퍼티를 가지게 되는데요.

const sayHi = function () {
  console.log('Hi');
};

console.log(sayHi.name); // sayHi
이렇게 이름이 없는 함수를 변수에 할당할 때는 변수의 name 프로퍼티는 변수 이름 그 자체를 문자열로 가지게 됩니다. 하지만 함수에 이름을 붙여주게 되면, name 속성은 함수 이름을 문자열로 갖게 되는데요.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

console.log(sayHi.name); // printHiInConsole
이 함수 이름은 함수 내부에서 함수 자체를 가리킬 때 사용할 수 있고 함수를 외부에서 함수를 호출할 때 사용할 수는 없습니다.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

printHiInConsole(); // ReferenceError
기명 함수 표현식은 일반적으로 함수 내부에서 함수 자체를 가리킬 때 사용되는데요. 아래 코드를 살펴봅시다.

let countdown = function(n) {
  console.log(n);

  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

countdown(5);
아규먼트로 숫자 값을 전달하고 전달받은 그 값이 0이 될 때까지 하나씩 값을 줄이면서 자기 자신을 호출하는 countdown이라는 함수를 함수 표현식으로 작성해봤는데요. 이런 식으로 자기 자신을 부르는 함수를 재귀 함수(Recursive function)라고 부릅니다.
그런데 만약 이 함수를 복사하려고 다른 변수에 똑같이 담았다가, countdown 변수에 담긴 값이 변하게 되면 문제가 발생하는데요.

let countdown = function(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // TypeError
에러코드실행화면

마지막 줄에서 myFunction 함수를 호출했을 때, 함수가 실행되긴 하지만, 6번줄 동작을 수행할 때 호출하려는 countdown 함수가 이미 12번에서 null 값으로 변경되었기 때문에 함수가 아니라는 TypeError가 발생한 것이죠!
이런 상황을 방지하기 위해서 함수 내부에서 함수 자신을 사용하려고 하면 함수표현식에서는 반드시 기명 함수 표현식을 사용하는 것이 좋습니다.

let countdown = function printCountdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    printCountdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // 정상적으로 동작
정상코드실행화면

함수 표현식을 작성할 때, 함수에 이름을 지정할 수 있다는 점과 특히 이렇게 함수 내에서 함수를 가리켜야 할 때는 꼭 함수 이름을 작성해주는 것이 안전하다는 점. 잘 기억해 두시면 좋을 것 같습니다.



# 즉시 실행 함수 (IIFE)

지금까지 함수를 선언하는 다양한 방법에 대해 살펴봤는데요.
함수를 선언하는 것은 함수를 실행하는 것과 다르다는 사실, 모두 알고 계시죠?

function sayHi() {
  console.log('Hi!');
}
  
sayHi();
일반적으로는 이렇게 함수를 먼저 선언한 다음,선언된 함수 이름 뒤에 소괄호를 붙여서 함수를 실행하는데요.
그런데 때로는 함수가 선언된 순간에 바로 실행을 할 수도 있습니다.

즉시 실행 함수
(function () {
  console.log('Hi!');
})();
보시는 것처럼 함수선언 부분을 소괄호로 감싼 다음에 바로 뒤에 함수를 실행하는 소괄호를 한 번 더 붙여주는 방식인데요.
이렇게 하면 함수가 선언된 순간 바로 실행이 되는 겁니다.

이렇게 함수 선언과 동시에 즉시 실행되는 함수를 가리켜 즉시 실행 함수 (표현)이라고 부르는데요.
영어로는 Immediately Invoked Function Expression, 줄여서 IIFE라고 부릅니다.

(function (x, y) {
  console.log(x + y);
})(3, 5);
그리고 즉시 실행 함수도 일반 함수처럼 파라미터를 작성하고, 함수를 호출할 때 아규먼트를 전달할 수도 있는데요.
한 가지 주의할 점은 즉시 실행 함수는 함수에 이름을 지어주더라도 외부에서 재사용할 수 없다는 겁니다.

(function sayHi() {
  console.log('Hi!');
})();

sayHi(); // ReferenceError
그래서 일반적으로는 이름이 없는 익명 함수를 사용하는데요.
다만, 이름이 있는 함수 표현식 레슨에서도 살펴봤던 것처럼 함수 내부에서 자기 자신을 호출하는 재귀적인 구조를 만들고자 할 땐 이름이 필요할 수도 있으니까 이 부분은 참고해 주세요!

(function countdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
})(5);
즉시 실행 함수의 활용
즉시 실행 함수는 말 그대로 선언과 동시에 실행이 이뤄지기 때문에 일반적으로 프로그램 초기화 기능에 많이 활용됩니다.

(function init() {
  // 프로그램이 실행 될 때 기본적으로 동작할 코드들..
})();
혹은 재사용이 필요 없는, 일회성 동작을 구성할 때 활용하기도 하는데요.

const firstName = 'Young';
const lastName = 'Kang';

const greetingMessage = (function () {
  const fullName = `${firstName} ${lastName} `;

  return `Hi! My name is ${fullName}`;
})();
이렇게 함수의 리턴값을 바로 변수에 할당하고 싶을 때 활용할 수 있습니다.

그리고, 전역변수와 지역변수의 개념 알고 계시죠?
즉시 실행 함수에서 사용하는 변수들은 함수 내에서만 유효하기 때문에 이런 점을 활용하면, 일시적으로 사용할 변수의 이름들을 조금 자유롭게 작성할 수도 있다는 점. 잘 기억해 두세요!

# 고차 함수 (Higher Order Function)
function getPrintHi() {
    return function () {
        console.log('Hi!?');
    };
};
const sayHi = getPrintHi();

sayHi();

=== 바로 호출도 가능
getPrintHi()();

// = 일급 함수(First Class Function)


# Parameter

function greeting(name) {
    console.log('Hi! My name is ${name}!');
}

greeting('JavaScript');


# 아규먼트(argument)

function greeting(파라미터) {
    console.log('Hi! My name is ${name}!');
}

greeting('아규먼트');

// 파라미터가 있는 함수를 호출할 때 빈 아규먼트를 호출하게 되면 undefined를 호출한다.
greeting(); 

# 파라미터 값을 지정하면 파라미터 값을 호출한다.

function greeting(name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
}
greeting();
// Hi! My name is Codeit!

# 파라미터 값을 지정하게 되면 우측 마지막에 작성을 한다. 그렇지 않으면 undefined가 호출됨.
# function greeting(interest, name = 'Codeit')
function greeting(name = 'Codeit', interest) {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}
greeting();
// Hi! My name is Codeit!
// I like undefined!



function greeting(interest, name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}

greeting('Java');


# Arguments
// 함수에 for문을 이용해서 아규먼트를 불러 올수 있다.
# 변수로 argument 사용을 해서는 안된다.
function printArguments(a, b, c) {
    for (const arg of arguments) {
        console.log(arg);
    }
    console.log{'--------------'};
};

printArguments('tony', 'Mark', 'Koby');
printArguments('Captain');
printArguments('suri', 'kack', 'joy', 'noel');


# Rest Parameter
// 다수의 파라미터를 사용할 경우 가장 마지막에 사용.(first, second, ...args)
function printArguments(...args) {
    for (const arg of args) {
        console.log(arg);
    }
    console.log{'--------------'};
};

# splice method
function printArguments(...args) {
    console.log(args.splice(0, 2));
    console.log(arguments.splice(0, 2));
    console.log{'--------------'};
};


# 실습 설명
유튜브나 블로그에서 새로운 전자제품을 리뷰하는 콘텐츠를 보면 우스갯소리로 1세대는 거르는게 답이다.라는 말을 심심찮게 들을 수 있습니다.
그동안 새로운 버전으로 출시되는 제품들은 대부분 잔고장이나 버그들이 많았기 때문인데요.

rest parameter를 활용해서 함수를 호출할 때 여러 개의 아규먼트를 전달할 경우 첫 번째 아규먼트는 무시하고 두 번째 아규먼트 부터 하나씩 콘솔에 출력하는 ignoreFirst 함수를 완성해 주세요!

2세대
3세대
강아지
고양이
9
18
19
30
34
40
# 해설
일단 당장 주어진 코드를 보면, 함수 선언 부분은 없고 ignoreFirst함수를 호출만 3번 하고 있습니다. 함수를 호출할 때 아규먼트는 문자열이기도하고 숫자이고 한데요. 전달하는 값의 개수도 모두 제각각 입니다. 이런 상황에서 rest parameter를 어떻게 활용하면 좋을까요?

이번 과제는 생각보다 간단하게 해결할 수 있는데요. 심지어 해결하는 방법도 다양합니다. 이번 해설에서는 두 가지 정도로 다뤄볼텐데요.

일단 첫 번째는 rest parameter가 arguments 객체와는 다르게 배열이라는 점을 응용하는 겁니다. 그래서 아규먼트로 전달하는 값들 중 가장 첫 번째를 제외한 값들을 콘솔에 출력해야 하니, 가장 첫 요소를 제거해 주는 배열의 shift 메소드를 활용하는 방식인데요. shift 메소드로 첫 요소를 제거한 다음 for of문을 통해 각 요소를 콘솔에 출력하면 다음과 같이 작성할 수 있습니다.

// 여기에 코드를 작성하세요
function ignoreFirst(...rest) {
  rest.shift();

  for (const el of rest) {
    console.log(el);
  }
}

ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);
두 번째 방법은 rest parameter를 일반 파라미터와 함께 사용할 때의 특징을 활용하는 건데요. 일반 파라미터와 함께 사용할 때는 항상 가장 오른편에 작성해야 한다는 점 모두 알고계시죠? 함수를 호출할 때 전달하는 아규먼트들은 앞쪽에 선언된 일반 파라미터에 먼저 할당되고, 나머지 값들이 rest parameter에 배열로 모이는 특징을 활용해서 파라미터 하나를 먼저 선언해 두고 두 번째 파라미터를 rest parater로 작성해서 for of문을 활용하면 다음과 같이 작성할 수 있습니다.

// 여기에 코드를 작성하세요
function ignoreFirst(first, ...rest) {
  for (const el of rest) {
    console.log(el);
  }
}

ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);
이 밖에도 다양한 방법으로 해결해 볼 수 있을 것 같은데요. rest parameter의 특징을 잘 활용해서 또 어떤 방식을 활용하면 좋을지 여러분도 한번 고민해 보세요!

// 여기에 코드를 작성하세요
function ignoreFirst(...rest) {
  rest.shift();
  
  for (const arg of rest) {
    console.log(arg);
  }
}


ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);




# 실습 설명
겉바속촉(겉은 바삭하고 속은 촉촉한), 아바라(아이스 바닐라 라떼), 얼죽아(얼어 죽어도 아이스), 별다줄 (별걸 다 줄인다) 등 우리 일상생활에 여러 단어가 조합된 단어를 앞 글자만 따서 다시 한번 더 줄여쓴 줄임말들이 넘쳐나고 있는데요.
arguments 객체를 활용해서 함수를 호출할 때 전달하는 단어들의 첫 글자만 따서 줄임말을 만들어주는 firstWords 함수를 완성해 주세요.

실습 결과
코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

나없고
아바라
만반잘부
결자해지
빨주노초파남보

# 작성
function firstWords() {
  let word = '';

  for(const arg of arguments) {
    word += arg[0];
  }

  console.log(word);
}

firstWords('나만', '없어', '고양이');
firstWords('아니', '바나나말고', '라면먹어');
firstWords('만두', '반으로', '잘라먹네', '부지런하다');
firstWords('결국', '자바스크립트가', '해피한', '지름길');
firstWords('빨간색', '주황색', '노란색', '초록색', '파란색', '남색', '보라색');



# 태그 이름으로 태그 선택하기

지금까지 id와 class 속성을 이용해서 JavaScript로 HTML 태그를 선택하는 방법에 대해 알아봤는데요.
document.getElementsByTagName('태그이름')메소드를 활용하면 태그 이름으로 태그를 선택할 수 있습니다.

const btns = document.getElementsByTagName('button');

이렇게 하면 HTML 문서 내에 있는 모든 button 태그를 선택하게 됩니다.

태그이름으로태그선택하기

document.getElementsByClassName('class')메소드와 마찬가지로 태그 이름으로 요소를 찾는 경우에 여러 개의 요소가 선택될 수 있기 때문에 메소드 이름에 Element(s), s가 있고, 실행결과 역시 HTMLCollection을 리턴한다는 점도 함께 기억해 두시면 좋을 것 같습니다.

참고로 css 선택자처럼 '*' 값을 전달하게 되면 모든 태그를 선택할 수도 있는데요.

const btns = document.getElementsByTagName('button');
const allTags = document.getElementsByTagName('*');
하지만, css 스타일링을 할 때도 태그 이름으로 스타일링을 하는 경우는 거의 없죠?

마찬가지로 명확한 의도가 없이 이렇게 많은 요소들을 한꺼번에 다루게 되면 예상치 못한 실수를 할 가능성이 있기 때문에 자바스크립트에서도 많이 사용되는 메소드는 아닙니다.


# Arrow Function
# 1
const getTwice = function(number) {
    return number * 2;
};

console.log(getTwice(6));

# 2
function getTwice(number) {
    return number * 2;
}
console.log(getTwice(6));


# 3
const getTwice = number => number * 2;

console.log(getTwice(6));

# 4
const getTwice = (a, b) => {
    const result = a + b;
    return result;
};

console.log(getTwice(6, 7));

# 5 Arrow Function으로 변환하기
const getObject = function(a, b, c) {
  return { 0: a, 1: b, 3: c };
}

// const getObject = (a, b, c) => ({ 0: a, 1: b, 3: c });
기존의 함수 선언 방식을 화살표 함수로 변환하면 몇 가지 조건에 따라 축약된 표현들을 사용할 수가 있는데요.

파라미터가 하나일 때 파라미터를 감싸는 소괄호 부분을 생략할 수 있습니다. 하지만, 주어진 문제의 함수는 파라미터가 3개이기 때문에 소괄호를 생략할 수는 없겠죠?

여기서 한 가지 주의해야 할 부분이 있습니다. 함수 내부의 동작이 return 문 하나밖에 없지만 return 값이 객체일 때 무작정 중괄호를 생략해 버리면, 객체를 표현하는 중괄호를 함수의 동작 부분을 구분하는 중괄호로 해석해 버려서 오류가 발생하기 때문입니다. 
그래서 이런 경우에는 객체를 표현하는 중괄호 바깥에 소괄호를 한 번 더 감싸주어야 한다.

# this

function getFullName() {
    return '${this.firstName} ${this.lastName}';
}

const user = {
    firstName: 'Tess'.
    lastName: 'Jang',
    getFullName: getFullName,
};

const admin = {
    firstName: 'Alex'.
    lastName: 'Kim',
    getFullName: getFullName,
};

console.log(user.getFullName());
console.log(admin.getFullName());

# 종합 정리
함수 선언
자바스크립트에서 함수는 다양한 방식으로 선언할 수 있습니다.
가장 일반적인 방법은 function 키워드를 통해 함수를 선언하는 방식인데요.

// 함수 선언
function sayHi() {
  console.log('Hi!');
}
이렇게 작성하는 방식을 함수 선언(function declaration)이라고 합니다.

함수 표현식
그리고 자바스크립트에서 함수는 값으로 취급될 수도 있기 때문에 변수에 할당해서 함수를 선언할 수도 있습니다.

// 함수 표현식
const sayHi = function () {
  console.log('Hi!');
};
이렇게 함수를 값으로 다루는 방식을 함수 표현식 (function expression)이라고 합니다.

다양한 함수의 형태
자바스크립트에서 함수는 값으로 취급되는데요. 이런 특징은 코드를 작성할 때 다양한 형태로 활용될 수 있습니다.

// 변수에 할당해서 활용
const printJS = function () {
  console.log('JavaScript');
};

// 객체의 메소드로 활용
const codeit = {
  printTitle: function () {
    console.log('Codeit');
  }
}

// 콜백 함수로 활용
myBtn.addEventListener('click', function () {
  console.log('button is clicked!');
});

// 고차 함수로 활용
function myFunction() {
  return function () {
    console.log('Hi!?');
  };
};
파라미터의 기본값
자바스립트에서 함수의 파라미터는 기본값을 가질 수가 있는데요. 기본값이 있는 파라미터는 함수를 호출할 때 아규먼트를 전달하지 않으면, 함수 내부의 동작은 이 파라미터의 기본값을 가지고 동작하게 됩니다.

function sayHi(name = 'Codeit') {
  console.log(`Hi! ${name}`);
}

sayHi('JavaScript'); // Hi! JavaScript
sayHi(); // Hi! Codeit
arguments 객체
자바스크립트 함수 안에는 arguments라는 독특한 객체가 존재합니다.
arguments 객체는 함수를 호출할 때 전달한 아규먼트들을 배열의 형태로 모아둔 유사 배열 객체인데요. 특히, 함수를 호출할 때 전달되는 아규먼트의 개수가 불규칙적일 때 유용하게 활용될 수 있습니다.

function printArguments() {
  // arguments 객체의 요소들을 하나씩 출력
  for (const arg of arguments) {
    console.log(arg); 
  }
}

printArguments('Young', 'Mark', 'Koby');
참고로 arguments라는 객체를 활용하고자 한다면 함수 안에서 사용할 파라미터나 변수, 함수의 이름을 arguments라고 짓는 것은 피하는게 좋겠죠?

Rest Parameter
arguments 객체를 이용하는 것 말고도 불규칙적으로 전달되는 아규먼트를 다루는 방법이 있는데요. 파라미터 앞에 마침표 세 개를 붙여주면, 여러 개로 전달되는 아규먼트들을 배열로 다룰 수가 있게 됩니다.
그리고 arguments객체는 유사 배열이기 때문에 배열의 메소드를 활용할 수 없는 반면, rest parameter는 배열이기 때문에 배열의 메소드를 자유롭게 사용할 수 있다는 장점이 있습니다.

function printArguments(...args) {
  // args 객체의 요소들을 하나씩 출력
  for (const arg of args) {
    console.log(arg); 
  }
}

printArguments('Young', 'Mark', 'Koby');
rest parameter는 다른 일반 파라미터들과 함께 사용될 수도 있는데요.

function printRankingList(first, second, ...others) {
  console.log('코드잇 레이스 최종 결과');
  console.log(`우승: ${first}`);
  console.log(`준우승: ${second}`);
  for (const arg of others) {
    console.log(`참가자: ${arg}`);
  }
}

printRankingList('Tommy', 'Jerry', 'Suri', 'Sunny', 'Jack');
이름 그대로 앞에 정의된 이름 그대로 앞에 정의된 파라미터에 argument를 먼저 할당하고 나머지 argument를 배열로 묶는 역할을 하기 때문에 일반 파라미터와 함께 사용할 때는 반드시 가장 마지막에 작성해야 한다는 점을 꼭 기억해 주세요!

Arrow Function
arrow function은 익명 함수를 좀 더 간결하게 표현할 수 있도록 ES2015에서 새롭게 등장한 함수 선언 방식입니다.
아래 코드와 같이 표현식으로 함수를 정의할 때 활용될 수도 있고 콜백 함수로 전달할 때 활용할 수도 있습니다.

// 화살표 함수 정의
const getTwice = (number) => {
  return number * 2;
};

// 콜백 함수로 활용
myBtn.addEventListener('click', () => {
  console.log('button is clicked!');
});
화살표 함수는 다양한 상황에 따라 축약형으로 작성될 수 있는데요.
아래 코드와 주석을 한 번 참고해 주세요!

// 1. 함수의 파라미터가 하나 뿐일 때
const getTwice = (number) => {
  return number * 2;
};

// 파라미터를 감싸는 소괄호 생략 가능
const getTwice = number => {
  return number * 2;
};

// 2. 함수 동작 부분이 return문만 있을 때
const sum = (a, b) => {
  return a + b;
};

// return문과 중괄호 생략 가능
const sum = (a, b) => a + b;



그리고 Arrow function이 일반 함수와 몇 가지 차이점이 있는데요.
가장 대표적인 차이점은 arguments 객체가 없고, this가 가리키는 값이 일반 함수와 다르다는 점입니다.
arrow function을 사용할 땐 이런 부분을 잘 고려해야 된다는 점을 잊지 마세요!

this
자바스크립트에는 this라는 조금 특별한 키워드가 있습니다.
웹 브라우저에서 this가 사용될 때는 전역 객체, Window 객체를 가지게 됩니다. 하지만 객체의 메소드를 정의하기 위한 함수 안에선 메소드를 호출한 객체를 가리키게 됩니다.

const user = {
  firstName: 'Tess',
  lastName: 'Jang',
  getFullName: function () {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(user.getFullName()); // getFullName 안에서의 this는 getFullName을 호출한 user객체가 담긴다!



# Promise 객체는 왜 등장했을까?

이때까지 우리는 Promise Chaining, then/catch/finally 메소드 등 Promise 객체에 관한 많은 것들을 배웠습니다. 그런데 여기서 궁금한 점이 하나 있습니다. Promise 객체는 왜 등장한 걸까요?

사실 Promise 객체가 등장하기 전에도 비동기적인 처리를 할 수 있는 방법은 있었습니다. 
이전 노트에서 배운 setTimeout 함수나, addEventListener 메소드처럼요.

setTimeout(callback, milliseconds);
addEventListener(eventname, callback);
이것들은 모두 직접 파라미터에 콜백을 전달하는 형식으로 정의되어 있는데요. 만약 fetch 함수를 이런 식으로 만들었다면

fetch('https://first.com', callback)
fetch 함수도 이런 식으로 사용했었겠죠? 그런데 왜 이런 방법이 선택되지 않고, 굳이 Promise 객체라는 문법이 도입된 것일까요? 
그 이유는 바로 함수에 콜백을 직접 넣는 형식은 콜백 헬(callback hell)이라고 하는 문제를 일으킬 수도 있기 때문입니다.

잠깐 이 코드를 봅시다. 만약 fetch 함수가 지금과 같이 Promise 객체를 리턴하는 게 아니라 setTimeout 함수처럼 콜백을 직접 집어넣는 형식의 함수였다면 우리는 여러 비동기 작업을 순차적으로 수행해야할 때

fetch('https://first.com', (response) => {
  // Do Something
  fetch('https://second.com', (response) => {
    // Do Something
    fetch('https;//third.com', (response) => {
      // Do Something
      fetch('https;//fourth.com', (response) => {
        // Do Something
      });
    });
  });
});
이런 식의 코드를 작성해야 했을 겁니다. 지금 fetch 함수 안의 콜백에 fetch 함수가 있고 그 함수의 콜백 안에 fetch 함수가 있고 또.. 계속 이런 식으로 들어가있죠? 그런데 이 코드를 보면 어떤 느낌이 드시나요? 뭔가 읽기 어렵고 복잡해 보이죠? 한마디로 가독성이 떨어집니다. 그나마 지금은 실제 코드가 들어가야 할 자리에 "// Do Something" 이라는 주석이 들어가 있어서 괜찮지만, 실제로 필요한 코드들까지 들어가게 되면 이 코드의 가독성은 현저하게 떨어지게 되는데요. 이런 현상을 콜백 지옥 또는 콜백 헬(callback hell)이라고 합니다. 또는 지옥의 피라미드(Pyramid of Doom)라고도 합니다.

하지만 우리가 배웠던 대로 fetch 함수는 Promise 객체를 리턴하기 때문에

fetch('https://first.com')
  .then((response) => {
    // Do Something 
    return fetch('https://second.com');
  })
  .then((response) => {
    // Do Something 
    return fetch('https://third.com');
  })
  .then((response) => { 
    // Do Something 
    return fetch('https://third.com');
  });
이런 식으로 Promise Chaining을 해서 좀 더 깔끔한 코드로 여러 비동기 작업을 순차적으로 처리할 수 있는데요. 
이렇게 Promise 객체를 사용하면 callback hell 문제를 해결할 수 있습니다.

이 뿐만 아니라 기존에 콜백을 직접 넣는 방식에 비해 Promise 객체의 문법은 비동기 작업에 관한 좀 더 세밀한 개념들이 반영되어 있습니다. 이전의 방식에서는 콜백에 필요한 인자를 넣어주고 실행하면 되는 단순한 방식이었다면, Promise 객체 문법에는 pending, fulfilled, rejected 상태, 작업 성공 결과 및 작업 실패 정보(이유), then, catch, finally 메소드 등과 같은 비동기 작업에 관한 보다 정교한 설계가 문법 자체에 반영되어 있다는 것을 알 수 있습니다.

바로 이렇게 Promise 객체라는 개념은,

(1) callback hell 문제를 해결하고, 이에 더해서 
(2) 비동기 작업 처리에 관한 좀 더 세밀한 처리를 자바스크립트 문법 단에서 해결하기 위해 등장했고,

그 유명한 자바스크립트의 2015년도 표준인 ES6(=ES2015)에 추가되었습니다.

오늘날 Promise는 자바스크립트 비동기 실행에 있어서 아주 핵심적인 문법입니다.



# Promise Chaining

function removeUnnecessaryInfo(users) {
  const processedUserList= users.map((user) => {
    const keys = Object.keys(user);
    const processedUser = {};
    keys.forEach((key) => {
      if (key === 'name' || key === 'email') {
        processedUser[key] = user[key];
      }
    });
    return processedUser;
  });
  const p = new Promise((resolve) => {
    setTimeout(() => { resolve(processedUserList); }, 1000); 
  });
  return p;
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.json())
  .then((result) => removeUnnecessaryInfo(result))
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    console.log('This job will be done by server soon!');
  });



Promise Chaining을 할 때는 아래와 같은 순서로 진행합니다.

(1) 각 비동기 작업을 순차적으로 처리하기 위해서 실행할 콜백들을 then 메소드들로 앞에서 설정한다. 
(2) catch 메소드를 사용한다. (Error 발생으로 인해 어느 Promise 객체가 rejected 상태가 되더라도 대응)
(3) finally 메소드를 사용한다. (전체 작업이 성공하거나 중간에 실패하거나, 심지어 catch 메소드의 콜백에서 에러가 발생하는 경우에도 항상 실행해야 할 콜백을 등록)

Promise Chain에서 각 메소드의 전형적인 등장 순서를 잘 기억해 주세요.



# 직접 만들어보는 Promise 객체
//Promisify 파일을 만들때만 사용함.
const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('success'); }, 2000); 
});

p.then((result) => { console.log(result); });


#
const p = new Promise((resolve, reject) => {
    setTimeout(() => { reject new Error('fail'); }, 2000); 
});
p.catch((error) => { console.log(error); });


#
const p = new Promise((resolve) => {
    setTimeout(() => { resolve(processedUserList); }, 1000); 
});
    return p;
}



# Promisify
 직접 Promise 객체를 만드는 방법을 배웠습니다. 그럼 언제 이런 식으로 Promise 객체를 직접 만들게 되는 걸까요? 다양한 경우들이 있지만, 전통적인 형식의 비동기 실행 함수를 사용하는 코드를, Promise 기반의 코드로 변환하기 위해 Promise 객체를 직접 만드는 경우가 많습니다. 각각의 예시를 통해 이게 무슨 말인지 이해해봅시다.

1. setTimeout 함수 예시
예를 들어 이런 wait이라는 함수가 있다고 합시다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}
wait 함수는 특정 밀리세컨즈만큼 시간이 지난 후에 text 파라미터로 전달받은 값을 리턴하는 함수입니다. 지금 보이는 setTimeout 함수는 이전에 [알아야하는 비동기 실행 함수들] 노트에서 배웠었죠? 이 wait 함수를 Promise Chaining 코드에서 사용해볼게요.

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => { console.log(result); });
바로 이 Promise Chaining 코드에 wait 함수를 추가해볼 건데요. 이렇게 써보겠습니다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => wait(`${result} by Codeit`, 2000)) // 2초 후에 리스폰스의 내용 뒤에 'by Codeit' 추가하고 리턴
  .then((result) => { console.log(result); });
기존 코드에 두 번째 then 메소드를 추가하고, 그 안에서 wait 함수를 호출했습니다. 이렇게 쓰면 2초 후에 리스폰스의 내용 뒤에 by Codeit이라는 문구를 붙여서 출력될 것 같은데요. 정말 그렇게 되는지 확인해봅시다.

코드를 실행해보면,

jo6wlcosl-Untitled.png

리스폰스의 내용과 by Codeit이 출력되지 않았습니다. 그 대신 undefined가 출력되었는데요.

왜 그런 걸까요? 
그 이유는 바로 wait 함수에 있습니다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}
이 wait 함수는 내부에서 setTimeout 함수를 호출합니다. 그리고 setTimeout 함수의 첫 번째 파라미터로 들어간 콜백이 2초 후에 text를 리턴하죠. 그런데 여기서 혼동하면 안 되는 것은 wait 함수가

...
  .then((result) => { return wait(`${result} by Codeit`, 2000); })
...
이 두 번째 then 메소드 안의 콜백에서 실행될 때,

wait 함수는 setTimeout 함수를 실행할 뿐 아무것도 리턴하지 않는다는 사실입니다. 
setTimeout 함수 안의 콜백이 2초 후에 리턴하는 text는, wait 함수의 리턴값이 아닙니다.

이 사실에 유의해야 하는데요. wait 함수는 단지 setTimeout 함수를 실행하고 아무것도 리턴하지 않는 함수일 뿐입니다. 그리고 자바스크립트에서는 이전에 배운대로 함수에서 아무것도 리턴하지 않으면 undefined를 리턴하는 것으로 간주하기 때문에 wait 함수의 리턴값은 undefined입니다.

따라서 세 번째 then 메소드의 콜백으로 undefined가 넘어가고, 그래서 위 이미지에서 보이는 것처럼 undefined가 출력된 겁니다.

setTimeout은 비동기 실행되는 함수인데요. Promise Chaining 안에서 이렇게 비동기 실행되는 함수를 바로 사용하면, 나중에 실행되는 부분의 리턴값(여기서는 text)를 Promise Chain에서 사용할 수 없게 됩니다.

이 문제를 해결하려면 이전 영상에서 배웠던 Promise 객체를 직접 생성하는 방법을 사용하면 됩니다. wait 함수를 이렇게 수정해볼게요.

// function wait(text, milliseconds) {
//   setTimeout(() => text, milliseconds);
// }

function wait(text, milliseconds) {
  const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve(text); }, 2000);
  });
  return p;
}
지금 wait 함수 안에서 Promise 객체를 직접 생성했고, executor 함수 안에서 setTimeout 함수를 호출했습니다. 그리고 setTimeout 함수 안의 콜백에서 resolve 함수를 호출하는데 이 때 그 아규먼트로 text를 넣었습니다. 그렇다면 Promise 객체 p는 2초 후에 fulfilled 상태가 될 것이고, 그 작업 성공 결과는 파라미터 text의 값이 될 될 것입니다. wait 함수는 이제 Promise 객체 p를 리턴합니다.

자, 이 상태에서 코드를 다시 실행해보면

function wait(text, milliseconds) {
  const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve(text); }, 2000);
  });
  return p;
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => wait(`${result} by Codeit`, 2000)) // 2초 후에 리스폰스의 내용 뒤에 'by Codeit' 추가하고 리턴
  .then((result) => { console.log(result); });
fbmbi7m6k-Untitled 1.png

이번에는 약 2초 후에 리스폰스의 내용이 잘 출력되고,

5d9bljl8g-Untitled 2.png

리스폰스의 내용 맨 마지막에는 by Codeit이라는 문구가 잘 붙어서 출력되는 것을 알 수 있습니다.

방금처럼 기존의 비동기 실행 함수(여기서는 setTimeout)의 콜백이 리턴하는 값을 Promise Chain에서 사용하고 싶다면, 해당 함수를 감싸서 Promise 객체를 직접 생성하는 코드를 작성해야 합니다. 그리고 그 Promise 객체를 리턴해야 방금처럼 Promise Chain에서 해당 리턴값을 받아서 사용할 수 있습니다.

이렇게 전통적인 형식의 비동기 실행 함수를 Promise 객체로 감싸서 그 Promise 객체를 리턴하는 형식으로 만드는 작업을 Promisify(프로미스화하다)라고 하는데요. 앞으로도 이 Promisify라는 용어를 사용하겠습니다. 계속 내용을 읽어봅시다.

2. 콜백 헬(callback hell)과 Promise
이번에는 Promisify의 또 다른 예시를 보겠습니다. 그런데 이번에는 브라우저가 아니라 조금 다른 환경에서의 코드를 볼 건데요. 바로 Node.js라고 하는 환경입니다. 오늘날 자바스크립트가 실행되는 환경에는 웹 브라우저뿐만 아니라 Node.js라고 하는 것도 있습니다. 이 Node.js는 오늘날 자바스크립트를 서버에서도 실행할 수 있게 해주는 또 다른 '자바스크립트 실행 환경'인데요. 이 Node.js에서는 브라우저에서와는 또 다른 비동기 함수들이 제공됩니다. (Node.js가 뭔지 더 궁금하신 분들은 [Node.js가 무엇인가요?] 영상을 참고하세요.)

Node.js에는 다음과 같이 특정 파일의 내용을 읽기 위해 사용되는 readFile이라는 비동기 실행 메소드가 있습니다.

fs.readFile('file1.txt', 'utf8', (error, data) => {
  if (err) {
    console.log(err);
  } else {
    console.log(data);
  }
});
여기서 fs는 readFile 메소드를 가진 객체로, 파일에 관한 기능들을 갖고 있습니다. 일단 여기서 당장 중요한 내용은 아니니까 readFile 메소드에만 집중합시다. readFile 메소드는 첫 번째 파라미터로 파일의 이름, 두 번째 파라미터로 파일 해석 기준(인코딩 기준), 세 번째 파라미터로 콜백을 받는데요. readFile 함수는 파일을 읽다가 에러가 발생하면 콜백의 첫 번째 파라미터(error)에, 해당 에러 객체를 전달하고 콜백을 실행합니다. 만약 파일을 정상적으로 다 읽었으면 콜백의 두 번째 파라미터(data)에, 읽어들인 파일 내용을 전달하고 콜백을 실행하는데요.

이 readFile 메소드도, 콜백을 파라미터에 바로 넣는 비동기 실행 함수라는 점에서 setTimeout 함수, addEventListener 메소드와 비슷합니다. 그런데 이런 형식의 함수(또는 메소드)들은 한 가지 단점이 있다고 했었죠?(참고) 그건 바로 콜백 헬(callback hell) 문제입니다. 예를 들어, 위 코드에서 이제 file1.txt 파일의 내용을 출력하고 나서 그 다음에 file2.txt라는 파일의 내용을 또 출력해야한다고 해봅시다. 그럼 코드가 이렇게 되겠죠?

fs.readFile('file1.txt', 'utf8', (error1, data1) => {
  if (error1) {
    console.log(error1);
  } else {
    console.log(data1);
    fs.readFile('file2.txt', 'utf8', (error2, data2) => {
      if (error2) {
        console.log(error2);
      } else {
        console.log(data2);
      }
    });
  }
});
이렇게 코드를 쓰면 file1.txt의 내용이 출력되고, 그 다음에 file2.txt의 내용이 출력될 겁니다. 코드가 좀 복잡해졌지만 아직은 읽을만한 것 같습니다. 그런데 이제 그 다음으로 file3.txt의 내용도 출력해야 한다고 해봅시다.

그렇다면

fs.readFile('file1.txt', 'utf8', (error1, data1) => {
  if (error1) {
    console.log(error1);
  } else {
    console.log(data1);
    fs.readFile('file2.txt', 'utf8', (error2, data2) => {
      if (error2) {
        console.log(error2);
      } else {
        console.log(data2);
        fs.readFile('file3.txt', 'utf8', (error3, data3) => {
          if (error3) {
            console.log(error3);
          } else {
            console.log(data3);
          }
        });
      }
    });
  }
});
코드가 이렇게 됩니다. 이제 코드를 읽기 너무 어려워지지 않았나요?

콜백을 바로 파라미터에 집어넣는 전통적인 형식의 비동기 실행 함수들은 이런 문제가 있습니다. 바로 순차적으로 비동기 실행 함수들을 실행하려고 하면 콜백 안에 또 콜백이 있고, 그 안에 또 콜백이 있는 콜백 헬(콜백 지옥, callback hell) 현상을 초래하게 된다는 겁니다.

실제로 실무에서 개발을 하다 보면 이런 콜백 헬이 아주 큰 문제가 됩니다. 그런데 이런 함수들은 Promise 객체를 리턴하는 것도 아니고 애초에 이런 형식으로 정의되어 있기 때문에 문제를 해결하기가 어려워 보이는데요. 이 문제에 대한 대표적인 해결책이 바로 우리가 배운 Promisify입니다.

지금 이 readFile 메소드를 Promisify해보겠습니다.

function readFile_promisified(filename) {
  const p = new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (error, data) => {
      if (error) {
        reject(error); // 에러 발생 시 -> rejected
      } else {
        resolve(data); // 파일 내용 읽기 완료 -> fulfilled
      }
    });
  });
  return p;
}
이런 식으로 readFile_promisified라는 이름의 함수를 정의했는데요. 지금 함수 안에서는 Promise 객체를 직접 생성하고 있습니다. 
그리고 Promise 객체가 생성될 때 실행되는 executor 함수 안에서는 fs 객체의 readFile 메소드를 호출했습니다.

여기서 중요한 것은 작업을 수행하다가 에러가 나면 readFile 함수의 콜백에서


...                         (error, data) => {
  if (error) {
    reject(error); // 에러 발생 시 -> rejected 
  } else {
    resolve(data); // 파일 내용 읽기 완료 -> fulfilled 
  }
}
reject 함수를 호출하고, 파일의 내용을 정상적으로 다 읽었을 때는 resolve 함수를 호출한다는 사실입니다. 그리고 reject 함수의 파라미터에는 error 객체를, resolve 함수의 파라미터에는 파일의 내용인 data를 전달했는데요. 이 각각은, 생성된 Promise 객체의 작업 실패 정보 또는 작업 성공 결과가 되겠죠?

이제 readFile 메소드를 Promisify해서 만든 readFile_promisified 함수를 사용해서 위의 콜백 헬 코드에서 작성했던 내용을 똑같이 작성해봅시다.

readFile_promisified('file1.txt')
  .then((data) => { console.log(data); return readFile_promisified('file2.txt'); })
  .then((data) => { console.log(data); return readFile_promisified('file3.txt'); })
  .then((data) => { console.log(data); })
  .catch((error) => { console.log(error); });
짠! 어떤가요? 코드가 훨씬 깔끔해졌죠? readFile_promisified 함수는 Promise 객체를 리턴하기 때문에 이렇게 자유롭게 Promise Chain 안에서 사용할 수 있습니다.

이렇게 원하는 경우에는 전통적인 형식의 비동기 실행 함수를 Promisify해서 콜백 헬을 방지하고, 가독성 높은 코드를 작성할 수 있습니다.

3. Promisify를 하면 안 되는 함수들도 있습니다.
이제 기존의 전통적인 형식의 비동기 실행 함수도 원하는 경우에는 Promisify해서 콜백 헬을 방지할 수 있다는 것을 알게 되었습니다. 하지만 전통적인 형식의 비동기 실행 함수라고 해서 모두 Promisify해서 사용해도 되는 것은 아닙니다.

기존의 비동기 실행 함수들 중에서도 그 콜백을 한번만 실행하는 것들(setTimeout, readFile 등)만 Promisify해서 사용해도 되는데요.

이것들과 달리 만약 콜백을 여러 번 실행하는 함수들(setInterval, addEventListener 등)인 경우에는 이렇게 Promisify하면 안 됩니다. 왜냐하면 Promise 객체는 한번 pending 상태에서 fulfilled 또는 rejected 상태가 되고나면 그 뒤로는 그 상태와 결과가 바뀌지 않기 때문입니다. 이게 무슨 말인지 다음 코드를 보고 이해해봅시다.

const box = document.getElementById('test');
let count = 0;

function addEventListener_promisified(obj, eventName) { // 이런 Promisify는 하지 마세요
  const p = new Promise((resolve, reject) => {
    obj.addEventListener(eventName, () => { // addEventListener 메소드
      count += 1;
      resolve(count);
    });
  });
  return p;
}

addEventListener_promisified(box, 'click').then((eventCount) => { console.log(eventCount); });
이 코드에서 보이는 addEventListener_promisified 함수는 DOM 객체의 addEventListener 메소드를 Promisify한 함수인데요.

지금 Promise 객체가 생성될 때 실행되는 executor 함수 안에서는, DOM 객체에 어떤 이벤트가 발생할 때, 실행할 콜백을 등록하고 있습니다. 
특정 이벤트가 발생할 때마다 count라고 하는 변수의 값을 1씩 늘려서 resolve 함수의 파라미터로 전달해서 실행하도록 하는 내용이 들어있는데요.

마지막 코드를 보면,

addEventListener_promisified(box, 'click')
  .then((eventCount) => { console.log(eventCount); });
이렇게 addEventListener_promisified 함수의 아규먼트로 DOM 객체 box와 문자열 'click'을 넣어서 box 객체가 클릭 이벤트에 반응하도록 했습니다. 
(HTML 코드는 생략된 상태입니다.)

하지만 이 코드를 실행하고 box를 클릭해보면 
처음에 1이 딱 출력되고 나서 그 다음 count 값들은 출력되지 않습니다.

왜냐하면 pending 상태에 있던 Promise 객체(여기서는 p 객체)가 한번 fulfilled 상태 또는 rejected 상태가 되고 나면 
Promise 객체의 상태 및 결과가 고정되어 그 뒤로는 바뀌지 않기 때문입니다.

따라서 지금 위 코드에 보이는 resolve(count)라고 하는 코드가 box 버튼을 클릭할 때마다 여러 번 실행된다고 해도 p 객체가 갖고 있는 상태와 결과는 변하지 않습니다. 그래서 then 메소드 안의 콜백도 처음 클릭했을 때 딱 한번 실행되고 끝인 겁니다.

이렇게 콜백이 여러 번 실행되어야하는 비동기 실행 함수인 경우에는 Promisify를 하면 안 됩니다. Promisify를 하고 싶은 경우라도, 콜백이 딱 한 번 실행되는 함수인 경우에만 해야한다는 사실, 잘 기억하세요!




# 이미 상태가 결정된 Promise 객체
이때까지 우리는 pending 상태에 있다가 fulfilled 상태 또는 rejected 상태가 되는 Promise 객체를 직접 만드는 법을 배웠습니다. 그런데 아예 처음부터 바로 fulfilled 상태이거나 rejected 상태인 Promise 객체를 만드는 것도 가능한데요. 어떻게 할 수 있는지 살펴봅시다.

1. 이미 상태가 결정된 Promise 객체 만들기
(1) fulfilled 상태의 Promise 객체 만들기
const p = Promise.resolve('success');
Promise의 resolve라는 메소드를 사용하면 바로 fulfilled 상태의 Promise 객체를 만들 수 있습니다. 위와 같이 쓰면 fulfilled 상태이면서, 작업 성공 결과로 문자열 'success'를 가진 Promise 객체를 만들 수 있습니다.

(2) rejected 상태의 Promise 객체 만들기
const p = Promise.reject(new Error('fail'));
Promise의 reject라는 메소드를 사용하면 바로 rejected 상태의 Promise 객체를 만들 수 있습니다. 위와 같이 쓰면 rejected 상태이면서, 작업 실패 정보로, fail이라는 메시지를 가진 Error 객체를 가진 Promise 객체를 만들 수 있습니다.

Promise 객체를 직접 생성하는 방법에는 이전에 배웠던 것처럼

const p = new Promise((resolve, reject) => {

});
new 생성자와 executor 함수를 사용하는 것 말고도 resolve 메소드나, reject 메소드를 사용하는 방법도 있다는 사실을 기억하셔야 합니다. 
resolve 메소드나 reject 메소드로 생성한 Promise 객체도 이때까지 우리가 배운 것과 동일하게 작동합니다.

const p = Promise.resolve('success');
p.then((result) => { console.log(result); }, (error) => { console.log(error); });
이 코드에서는 첫 번째 콜백이 실행되어서 작업 성공 결과인 문자열 success가 출력되고

const p = Promise.reject(new Error('fail'));
p.then((result) => { console.log(result); }, (error) => { console.log(error); });
이 코드에서는 두 번째 콜백이 실행되어서 작업 실패 정보인 Error 객체의 내용이 출력되겠죠?

어떤 비동기 작업을 처리할 필요가 있다면, new 생성자와 executor 함수를 사용해서 Promise 객체를 만들어야 하지만, 그렇지 않고 바로 상태가 이미 결정된 Promise 객체를 만들고 싶을 때는 이 resolve 또는 reject 메소드를 사용합니다.

구체적으로 예를 들자면, 함수 안에서 리턴하는 값이 여러 개인 경우 모든 리턴값을 Promise 객체로 통일하고 싶을 때, 종종 resolve 또는 reject 메소드를 쓰는데요. 예를 들어,

function doSomething(a, b) {
    //~~
  if (problem) {
    throw new Error('Failed due to..'));
  } else {
    return fetch('https://~');
  }
}
이렇게 문제(problem이 falsy인 경우)가 없는 경우에만 fetch 함수를 호출해서 Promise 객체를 리턴하는 함수가 있다고 해봅시다. 만약 문제가 발생하는 경우에는 바로 Error 객체를 throw해 버리고 있죠? 만약 문제가 존재하는 경우에도 Promise 객체를 리턴하고 싶다면 reject 메소드를 써서 이렇게 작성할 수 있습니다.

function doSomething(a, b) {
  // ~~
  if (problem) {
    return Promise.reject(new Error('Failed due to..'));
  } else {
    return fetch('https://~');
  }
}
지금 문제가 있는 경우에도 에러를 바로 throw하는 게 아니라, 생성한 에러를 Promise 객체의 작업 실패 정보로 설정해서, 그 Promise 객체를 리턴하는 것으로 바꿔줬죠? 만약 어떤 함수가 어떤 상황이든 항상 Promise 객체를 리턴하는 것으로 통일하고 싶은 경우에는 resolve나 reject 메소드를 유용하게 사용할 수 있습니다.

2. Promise 객체의 작업 성공 결과 또는 작업 실패 정보
간혹 Promise 객체를 공부하는 분들 중에, Promise 객체가 pending 상태일 때 미리 then 메소드가 붙어있어야만 나중에 이 Promise 객체가 fulfilled 상태 또는 rejected 상태가 되었을 때 그 결과(작업 성공 결과 또는 작업 실패 정보)를 콜백의 파라미터로 받을 수 있고, 이미 fulfilled 상태 또는 rejected 상태가 된 Promise 객체의 경우에는 then 메소드를 붙여도 그 결과를 콜백에서 받지 못한다고 오해하는 분들이 있습니다.

하지만 방금 resolve, reject 메소드에서도 봤듯이 이미 fulfilled 또는 rejected 상태가 결정된 Promise 객체라도 then 메소드를 붙이면, 콜백에서 해당 작업 성공 결과 또는 작업 실패 정보를 받아올 수 있습니다. 시점과는 전혀 상관이 없는 개념인 겁니다.

Promise 객체의 상태가 fulfilled 또는 rejected 상태이기만 하면, 어느 시점이든, 몇 번이든 then 메소드를 붙여서 해당 결과를 가져올 수 있습니다. 예를 들어,

const p = new Promise((resolve, reject) => {
  setTimeout(() => { resolve('success'); }, 2000); // 2초 후에 fulfilled 상태가 됨
});

p.then((result) => { console.log(result); }); // Promise 객체가 pending 상태일 때 콜백 등록
setTimeout(() => { p.then((result) => { console.log(result); }); }, 5000); // Promise 객체가 fulfilled 상태가 되고 나서 콜백 등록 
이 코드를 실행하면 Promise가 pending 상태일 때 등록한 콜백이든, fulfilled 상태가 된 후에 등록한 콜백이든 잘 실행되는 것을 알 수 있습니다.
이렇게 어느 시점이든, 몇 번의 then 메소드를 붙이든 상관없이, pending 상태만 아니라면 항상 then 메소드로 Promise 객체의 결과를 추출할 수 있습니다.

Promise 객체는 항상 결과를 줄 수 있는 공급자(Provider)이고 그것의 then 메소드는 그 결과를 소비하는 콜백인 소비자(Consumer)를 설정하는 메소드라는 사실을 잘 기억하셔야 합니다. 시점과는 전혀 연관이 없으니까 오해하지 마세요!






# 조건 연산자 (Conditional operator) //반복문으로 사용 불가
# 조건 ? 조건이 truthy 할 때 표현식 : 조건이 falsy 할 때 표현식;

// 조건 ? truthy 할 때 표현식 : falsy 할 때 표현식

if (조건) {
  // 조건이 true일 때 동작
} else {
  // 조건이 false일 때 동작
}

switch (값) {
  case A:
  // 값이 A와 일치할 때 동작
    break;
  default:
  // 값과 일치하는 case가 없을 때 동작
}

# 조건 연산자
const CUT_OFF = 80;

function passChecker(score) {
    return score > CUT_OFF ? '합격' : '불합격!';
}

console.log(passChecker(75));

#if문
const CUT_OFF = 80;

function passChecker(score) {
    if (score > CUT_OFF) {
        return '합격'
    } else {
        return '불합격!';
    }
}

console.log(passChecker(75));

# 반복문
const CUT_OFF = 80;

function passChecker(score) {
    if (score > CUT_OFF) {
        const msg = '합격!';
        return msg;
    } else {
        for (let i = 0; i < 3; i++) {
            console.log(i);
        }
        return '불합격!';
    }
}

console.log(passChecker(75));


# Spread 구문 (Spread Syntax)
const number = [1, 2, 3];
console.log(...numbers);
console.log(1, 2, 3);

# Spread
const webPublishing = ['HTML', 'CSS'];
const interactiveWeb = [...webPublishing, 'JavaScript'];

interactiveWeb.push('JavaScript');

console.log(webPublishing);
console.log(interactiveWeb);

# argument문
const sumAll = (...args) => {
    let sum = 0;
    for (arg of args) {
        sum += arg;
    }
    return sum;
}

console.log(sumAll(1, 2, 3, 4));


# Spread 합칠때
const arr1 = [1, 2, 3];
const arr1 = [4, 5, 6];

const arr3 = [...arr1, ...arr2];
console.log(arr3);

const arr4 = arr1.concat(arr2);
console.log(arr4);


#
const members = ['태호', '종훈', '우재'];

const newObject = {...members };

console.log(newObject);


# 정리
객체 Spread하기
아래 코드를 살펴봅시다.

const codeit = { 
  name: 'codeit', 
};

const codeitClone = { 
  ...codeit, // spread 문법!
};

console.log(codeit); // {name: "codeit"}
console.log(codeitClone); // {name: "codeit"}
이렇게 중괄호 안에서 객체를 spread 하게되면, 해당 객체의 프로퍼티들이 펼쳐지면서 객체를 복사할 수가 있게 됩니다.

const latte = {
  esspresso: '30ml',
  milk: '150ml'
};

const cafeMocha = {
  ...latte,
  chocolate: '20ml',
}

console.log(latte); // {esspresso: "30ml", milk: "150ml"}
console.log(cafeMocha); // {esspresso: "30ml", milk: "150ml", chocolate: "20ml"}
이런 식으로 다른 객체가 가진 프로퍼티에 다른 프로퍼티를 추가해서 새로운 객체를 만들 때 활용할 수도 있겠죠?

주의 사항
배열을 Spread 하면 새로운 배열을 만들거나 함수의 아규먼트로 쓸 수 있었지만, 객체로는 새로운 배열을 만들거나 함수의 아규먼트로 사용할 수는 없습니다.

const latte = {
  esspresso: '30ml',
  milk: '150ml'
};

const cafeMocha = {
  ...latte,
  chocolate: '20ml',
}

[...latte]; // Error

(function (...args) {
  for (const arg of args) {
    console.log(arg);
  }
})(...cafeMocha); // Error
그렇기 때문에 객체를 spread할 때는 반드시 객체를 표현하는 중괄호 안에서 활용해야 한다는 점. 잘 기억해 두시면 좋을 것 같습니다!


#문제
const snacks = ['원카칩', '꿀버터칩', '헛스윙칩', '태양칩', '야채시간'];
const drinks = ['사이다', '콜라', '우유', '물', '커피', '레몬에이드'];

function printArguments(...args) {
  for (const arg of args) {
    console.log(arg);
  }
}

// 1. Spread 구문을 활용해서 snacks와 drinks 배열을 각각 mySnacks와 myDrinks 변수에 복사해 주세요
const mySnacks = [...snacks];
const myDrinks = [...drinks];

mySnacks.splice(2, 3);
myDrinks.splice(1);

// 2. Spread 구문을 활용해서 mySnacks와 myDrinks 순서로 두 배열을 합쳐서 myChoice 변수에 할당해 주세요
const myChoice = [...mySnacks, ...myDrinks];

// 3. Spread 구문을 활용해서 myChoice의 각 요소들을 printArguments 함수의 아규먼트로 전달해 주세요
printArguments(...myChoice);


# 옵셔널 체이닝 (Optional Chaining)
바로 ECMAScript2020에서 등장한 옵셔널 체이닝이라는 접근 방법입니다. 일반적으로 객체의 프로퍼티는 점 표기법을 통해서 접근하게 되는데요.

function printCatName(user) {
  console.log(user.cat.name);
}

const user1 = {
  name: 'Captain',
  cat: {
    name: 'Crew',
    breed: 'British Shorthair',
  }
}

printCatName(user1); // Crew

객체를 활용해서 데이터를 표현하다 보면 이렇게 중첩된 객체를 작성하게 될 일이 빈번하고, 함수에서도 이런 중첩 객체의 프로퍼티를 활용할 일이 많은데요.
중첩된 객체의 프로퍼티에 접근하는 방법은 이미 다 알고 계시죠? 함수 printCatName은 user 파라미터에 중첩된 cat객체의 name 프로퍼티를 콘솔에 출력해주는 함수입니다.

그런데, 이렇게 중첩 객체를 다룰 때 한가지 조심해야 될 부분이 있습니다.

const user2 = {
  name: 'Young',
}

console.log(user2.cat); // undefined
printCatName(user2); // TypeError: Cannot read property 'name' of undefined
여러 가지 상황에 맞춰 데이터를 다루다 보면 때로는 우리가 예상한 프로퍼티를 가지고 있지 않을 수도 있는데요.
cat 프로퍼티를 가지고 있지 않은 user2는 cat 프로퍼티가 undefined이기 때문에 user2.cat.name에 접근하려는 순간 에러가 발생하게 됩니다.

그래서 printCatName과 같이 중첩된 객체의 프로퍼티를 다룰 때는 user.cat.name에 접근하기 전에 user.cat이 null 혹은 undefined가 아니라는 것을 검증하고 접근해야 에러를 방지할 수가 있는데요.

function printCatName(user) {
  console.log(user.cat && user.cat.name);
}
if문을 활용할 수도 있지만, 일반적으로는 간결하게 AND 연산자를 활용해서 이 문제를 해결하곤 했었습니다.
그런데 이마저도 객체의 이름이나 프로퍼티의 이름이 길어질수록 가독성이 나빠지는 문제가 있는데요, 이런 상황에 훨씬 더 코드를 간결하게 사용할 수 있는 문법이 바로 옵셔널 체이닝(Optional Chaining)입니다.

function printCatName(user) {
  console.log(user.cat?.name);
}
위 코드에서 볼 수 있는 것처럼 물음표와 마침표를 붙여 사용하는 부분이 바로 옵셔널 체이닝 연산자(?.)인데요.
만약 옵셔널 체이닝 연산자 왼편의 프로퍼티 값이 undefined 또는 null이 아니라면 그다음 프로퍼티 값을 리턴하고 그렇지 않은 경우에는 undefined를 반환하는 문법입니다.

옵셔널 체이닝 연산자의 동작 원리를 삼항 연산자를 통해 구체적으로 표현하면 다음과 같이 작성할 수 있는데요.

function printCatName(user) {
  console.log((user.cat === null || user.cat === undefined) ? undefined : user.cat.name);
}
이렇게 보니 옵셔널 체이닝 연산자가 어떻게 동작하는지 이해가 되죠?
이전에 배운 null 병합 연산자와 함께 활용하면 다음과 같이 응용할 수도 있습니다.

function printCatName(user) {
  console.log(user.cat?.name ?? '함께 지내는 고양이가 없습니다.');
}

const user2 = {
  name: 'Young',
}

printCatName(user2); // 함께 지내는 고양이가 없습니다.
이후 레슨에서 자세히 다루겠지만 자바스크립트에서 에러를 방지하는 일은 굉장히 중요한데요.
중첩된 객체를 다룰 때 에러를 방지하기 위해 다양한 방식을 활용할 수 있지만 옵셔널 체이닝 연산자를 활용하면 훨씬 더 간결하게 코드를 작성할 수 있다는 점! 잘 기억해 두세요!


# Destructuring (구조 분해)
//Destructuring 문법을 활용하면 배열의 각 요소를 여러 변수에 개별적으로 할당할 수 있습니다. Destructuring 문법은 rest 문법을 활용할 수도 있고, 변수들끼리 서로 값을 바꿀 때도 유용하게 활용할 수 있는데요.


// 1. Destructuring 문법을 활용해서 numbers 배열의 각 요소를 one, two, three라는 변수에 할당해보세요
const numbers = [1, 2, 3];
const [one, two, three] = numbers;



// 2. Destructuring 문법을 활용해서 TV는 livingRoom, 나머지 요소들(배열)은 kitchen 변수에 할당해 주세요
const products = ['TV', '식탁', '냉장고', '전기밥솥', '전자레인지', '오븐', '식기세척기'];
const [livingRoom, ...kitchen] = products;



// 3. Destructuring 문법을 활용해서 두 변수의 값을 서로 바꿔주세요
let firstName = 'Kang';
let lastName = 'Young';
[firstName, lastName] = [lastName, firstName];



// 테스트 코드
console.log(one);
console.log(two);
console.log(three);
console.log(livingRoom);
console.log(kitchen[1]);
console.log(firstName);
console.log(lastName);



# Destructuring 연습



// 1. Destructuring 문법을 사용해서 title, artist, year, medium 변수에 myBestArt 객체의 각 프로퍼티를 할당해 주세요
const myBestArt = {
    title: '별이 빛나는 밤에',
    artist: '빈센트 반 고흐',
    year: 1889,
    medium: '유화',
}

const { title, artist, year, medium } = myBestArt;



// 2. Destructuring 문법을 활용해서 myBestSong의 프로퍼티 중 title과 artist는 각각 songName과 singer라는 변수에, 나머지는 rest라는 변수에 객체로 할당해 주세요
const myBestSong = {
    title: '무릎',
    artist: '아이유(IU)',
    release: '2015.10.23.',
    lyrics: '모두 잠드는 밤에...'
}

const { title: songName, artist: singer, ...rest } = myBestSong;



// 3. printMenu 함수 안에 잘못 작성된 Destructuring 코드를 수정해 주세요
const menu1 = { name: '아메리카노' };
const menu2 = { name: '바닐라 라떼', ice: true };
const menu3 = { name: '카페 모카', ice: false };

function printMenu(menu) {
    //  menu 파라미터로 전달되는 객체에 ice 프로퍼티가 없을 경우 기본값은 true여야 합니다
    const { name, ice = true } = menu;

    console.log(`주문하신 메뉴는 '${ice ? '아이스' : '따뜻한'} ${name}'입니다.`);
}



// 테스트 코드
console.log(title);
console.log(artist);
console.log(year);
console.log(medium);
console.log(songName);
console.log(singer);
console.log(rest);
printMenu(menu1);
printMenu(menu2);
printMenu(menu3);


# 에러와 에러 객체
throw error;
throw new Error('에러가 발생했습니다.');

// 에러 종류 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Error

## try catch문
try {
    // 코드
} catch (error) {
    console.log('에러 후'); // 에러가 발생했을 때 동작할 코드
}
// error & err & e 라고 사용하기도 함.

try {
    // 코드
} catch (e) {
    console.log('에러 후'); // 에러가 발생했을 때 동작할 코드
    console.log(e);  //console.error(e); 에러문으로 확인 가능
    console.log(e.name);
    console.log(e.message);
}


# finally문

try {
  // 실행할 코드
} catch (err) {
  // 에러가 발생했을 때 실행할 코드
} finally {
  // 항상 실행할 코드
}

# 
  for (const member of members) {
    console.log(member);
  }
}

try {
  printMembers('영훈', '윤수', '동욱');
} catch (err) {
  alert('에러가 발생했습니다!');
  console.error(err);
} finally {
  const end = new Date();
  const msg = `코드 실행을 완료한 시각은 ${end.toLocaleString()}입니다.`;
  console.log(msg);
}


# finally문에서의 에러 처리는?

try {
  try {
    // 실행할 코드
  } catch (err) {
    // 에러가 발생했을 때 실행할 코드
  } finally {
    // 항상 실행할 코드
  }
} catch (err) {
  // finally문에서 에러가 발생했을 때 실행할 코드
}


## 종합 정리
조건부 연산자 (Conditional operator)
삼항 연산자 (Ternary operator)라고도 불리는 이 연산자는 자바스크립트에서 세 개의 피연산자를 가지는 유일한 연산자 입니다.

if문과 같은 원리로 조건에 따라 값을 결정할 때 활용되는데요.

const cutOff = 80;

const passChecker = (score) => score > cutOff ? '합격입니다!' : '불합격입니다!';

console.log(passChecker(75));
간단한 조건식의 경우에는 if문 보다 훨씬 더 간결하게 표현할 수 있는 장점이 있지만 내부에 변수나 함수를 선언한다거나 반복문 같은 표현식이 아닌 문장은 작성할 수 없다는 한계가 있기 때문에 if문을 완벽하게 대체할 수는 없다는 점. 꼭 기억해 주세요!

Spread 구문
여러 개의 값을 묶어놓은 배열이나 객체와 같은 값은 바로 앞에 마침표 세 개를 붙여서 펼칠 수가 있습니다.

const webPublishing = ['HTML', 'CSS'];
const interactiveWeb = [...webPublishing, 'JavaScript'];

console.log(webPublishing);
console.log(interactiveWeb);

const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const arr3 = [...arr1, ...arr2];
console.log(arr3);
Spread 구문은 배열이나 객체를 복사하거나 혹은 복사해서 새로운 요소들을 추가할 때 유용하게 활용 될 수 있습니다.
참고로 배열은 객체로 펼칠 수 있지만 객체는 배열로 펼칠 수 없다는 부분도 잘 기억해 두시면 좋을 것 같습니다.

const members = ['태호', '종훈', '우재'];
const newObject = { ...members };

console.log(newObject); // {0: "태호", 1: "종훈", 2: "우재"}

const topic = {
  name: '모던 자바스크립트',
  language: 'JavaScript', 
}
const newArray = [...topic]; // TypeError!
모던한 프로퍼티 표기법
ES2015 이후부터는 자바스크립트에서 변수나 함수룰 활용해서 프로퍼티를 만들 때 프로퍼티 네임과 변수나 함수 이름이 같다면 다음과 같이 축약해서 사용할 수 있습니다.

function sayHi() {
  console.log('Hi!');
}

const title = 'codeit';
const birth = 2017;
const job = '프로그래밍 강사';

const user = {
  title, 
  birth, 
  job, 
  sayHi,
};

console.log(user); // {title: "codeit", birth: 2017, job: "프로그래밍 강사", sayHi: ƒ}
그리고 메소드를 작성할 때도 다음과 같이 function 키워드를 생략할 수가 있습니다.

const user = {
  firstName: 'Tess',
  lastName: 'Jang',
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(user.getFullName()); // Tess Jang
뿐만아니라 아래 코드와 같이 대괄호를 활용하면 다양한 표현식으로 프로퍼티 네임을 작성할 수도 있으니까 잘 기억해 두셨다가 유용하게 활용해 보세요!

const propertyName = 'birth';
const getJob = () => 'job';

const codeit = {
  ['topic' + 'name']: 'Modern JavaScript',
  [propertyName]: 2017,
  [getJob()]: '프로그래밍 강사',
};

console.log(codeit);
구조 분해 Destructuring
배열과 객체와 같이 내부에 여러 값을 담고 있는 데이터 타입을 다룰 때 Destructuring 문법을 활용하면, 배열의 요소나 객체의 프로퍼티 값들을 개별적인 변수에 따로 따로 할당해서 다룰 수가 있습니다.

// Array Destructuring
const members = ['코딩하는효준', '글쓰는유나', '편집하는민환'];
const [macbook, ipad, coupon] = members;

console.log(macbook); // 코딩하는효준
console.log(ipad); // 글쓰는유나
console.log(coupon); // 편집하는민환

// Object Destructuring
const macbookPro = {
  title: '맥북 프로 16형',
  price: 3690000,
};

const { title, price } = macbookPro;

console.log(title); // 맥북 프로 16형
console.log(price); // 3690000
함수에서 default parater, rest parameter를 다루듯이 Destructuring 문법을 활용할 때도 기본값과 rest 문법을 활용할 수 있습니다.

// Array Destructuring
const members = ['코딩하는효준', '글쓰는유나', undefined, '편집하는민환', '촬영하는재하'];
const [macbook, ipad, airpod = '녹음하는규식', ...coupon] = members;

console.log(macbook); // 코딩하는효준
console.log(ipad); // 글쓰는유나
console.log(airpod); // 녹음하는규식
console.log(coupon); // (2) ["편집하는민환", "촬영하는재하"]

// Object Destructuring
const macbookPro = {
  title: '맥북 프로 16형',
  price: 3690000,
  memory: '16 GB 2667 MHz DDR4',
  storage: '1TB SSD 저장 장치',
};

const { title, price, color = 'silver', ...rest } = macbookPro;

console.log(title); // 맥북 프로 16형
console.log(price); // 3690000
console.log(color); // silver
console.log(rest); // {memory: "16 GB 2667 MHz DDR4", storage: "1TB SSD 저장 장치"}
에러와 에러 객체
자바스크립트에서 에러를 다루는 일은 굉장히 중요하다고 할 수 있는데요.
자바스크립트에서 에러가 발생하면 그 순간 프로그램 자체가 멈춰버리고 이후의 코드가 동작하지 않기 때문입니다.

그리고 에러가 발생하면 에러에 대한 정보를 name과 message라는 프로퍼티로 담고 있는 에러 객체가 만들어지는데요.
대표적인 에러 객체는 SyntaxError, ReferenceError, TypeError 입니다.

에러 객체는 직접 만들 수도 있는데요.
new 키워드와 에러 객체 이름을 딴 함수를 통해 에러 객체를 만들 수 있고, throw 키워드로 에러를 발생시킬 수 있습니다.

throw new TypeError('타입 에러가 발생했습니다.');
try...catch문
try...catch문은 자바스크립트에서 대표적인 에러 처리 방법입니다.

try {
  // 실행할 코드
} catch (error) {
  // 에러 발생 시 동작할 코드
}
try문 안에서 실행할 코드를 작성하고, try문에서 에러가 발생한 경우에 실행할 코드를 catch 문 안에 작성하면 되는데요.
이 때 try문에서 발생한 에러 객체가 catch문의 첫 번째 파라미터로 전달됩니다. 만약, try문에서 에러가 발생하지 않을 경우 catch문의 코드는 동작하지 않습니다.

그리고 try...catch문에서 에러의 유무와 상관없이 항상 동작해야할 코드가 필요하다면 finally문을 활용할 수 있습니다.

try {
  // 실행할 코드
} catch (error) {
  // 에러가 발상했을 때 실행할 코드
} finally {
  // 항상 실행할 코드
}

# 배열 메소드 I: forEach와 map

const members = ['영훈', '윤수', '동욱', '태호'];

for (let member of members) {
    console.log('${member}님이 입장하셨습니다.');
}

members.forEach(function (member) {
    console.log('${member}님이 입장하셨습니다.');
});


## 문제 풀이

# 실습 설명
꼼꼼하기로 소문난 태순이는 하루를 시작하기 전에 그 날 해야할 일들을 정리하는 것을 좋아합니다.
처음에는 다이어리에 작성하다가 할 일 정리 프로그램을 만들어 보기로 했는데요.
일단은 배열 안의 객체의 형태로 오늘 해야 할 일들을 정리해두고 화면에 그려보는 기능부터 개발하려고 합니다.

태순이를 도와서 HTML DOM 메소드와 forEach 메소드를 통해 data 변수에 담긴 할 일들을 화면에 띄워보세요.
단, 아래의 조건들을 잘 지켜주셔야 합니다.

forEach 메소드를 활용해주세요.
할 일들은 li태그로 만들어 주세요.
할 일들은 기본적으로 item 이라는 클래스를 가지고 있어야 합니다.
할 일 중에서 isClear 프로퍼티가 true인 할 일은 done 이라는 클래스도 추가해 주세요.
할 일들에 1부터 시작하는 번호를 매겨주세요. (ex) 1. 게임하기 2. 쇼핑하기 3. ...)
할 일들은 <ul class="list"></ul>태그 안에 넣어주세요.



# 해설
forEach 메소드는 배열의 요소를 하나씩 살펴보면서 반복하는 메소드 입니다. forEach 메소드는 첫 번째 파라미터로 콜백 함수를 전달받는데요. 콜백 함수의 첫 번째 파라미터에 배열의 각 요소가 전달되고, 두 번째 파라미터에는 index가 전달 됩니다.
첫 번째 파라미터는 할 일에 대한 정보를 확인할 때 사용하고, 두 번째 파라미터는 할 일의 번호를 매길 때 활용하면 좋겠죠?

자, 그럼 주어진 조건에 따라서 순서대로 하나씩 과제를 해결해 봅시다. 일단은 1번 조건을 만족하기 위해서 data 변수에 forEach 메소드를 사용해 볼텐데요.

data.forEach((todo, i) => {

});
저는 콜백 함수의 첫 번째 파라미터 이름을 todo라고 지어주고, 두 번째 파라미터 이름은 index를 줄여서 i라고 붙여줬는데요.
조금 더 좋은 이름이 있다면 얼마든지 여러분들이 직접 작성한 이름을 사용하셔도 좋습니다.

그럼 이제 2번 조건을 위해서 li태그를 만들어 볼텐데요. document.createElement('li')을 활용하면, li태그 형태의 요소 노드를 만들 수 있습니다.

data.forEach((todo, i) => {
  const li = document.createElement('li');
});
그 다음 3번과 4번 조건은 같이 한번 해결해 볼텐데요.

data.forEach((todo, i) => {
  const li = document.createElement('li');

  if (todo.isClear) {
    li.classList.add('item', 'done');
  } else {
    li.classList.add('item');
  }
});
조건문을 활용해서 요소의 isClear 프로퍼티가 true 라면 'item'과 'done' 클래스를 추가하고, 그렇지 않은 경우에는 'item' 클래스만 추가해 주었습니다. 상황에 따라서는 이 부분을 아래와 같이 줄여서 작성할 수도 있으니 참고해 보세요!

// if 문 활용
if (todo.isClear) {
  li.classList.add('item', 'done');
} else {
  li.classList.add('item');
}

// 삼항 조건 연산자 활용
todo.isClear
  ? li.classList.add('item', 'done')
  : li.classList.add('item');

// 논리 연산자 활용
li.classList.add('item', todo.isClear && 'done');
이 밖에도 다양한 방식으로 해결할 수 있으니 여러분도 한 번 고민해 보세요.

다음은 5번 조건을 만족하기 위해서 li태그안에 내용을 추가해 볼텐데요. 콜백 함수의 (index) 파라미터와 todo 파라미터의 title 프로퍼티, 그리고 li 요소 노드의 textContent 프로퍼티를 활용해서 다음과 같이 작성할 수 있습니다.

data.forEach((todo, i) => { // 1번 조건
  const li = document.createElement('li'); // 2번 조건
  
  if (todo.isClear) { 
    li.classList.add('item', 'done'); // 4번 조건
  } else {
    li.classList.add('item'); // 3번 조건
  }

  li.textContent = `${i + 1}. ${todo.title}`; // 5번 조건
});
특히, index는 0부터 시작하니깐 + 1 부분이 필요하다는 점을 유의해 주세요.

마지막으로 6번 조건을 만족하기 위해서 append 메소드를 사용해 볼텐데요. 템플릿의 가장 첫 줄에 있는 list 변수에 <ul class="list"></ul>가 담겨있으니 이 변수를 그대로 활용하면 되겠죠?
list 변수에 append 메소드를 사용해서 마지막 6번 조건까지 만족시킨 코드를 완성해 보면 다음과 같습니다.


# 정답

const list = document.querySelector('.list');
const data = [{
    title: '자바스크립트 공부하기',
    isClear: true,
  }, {
    title: '쓰레기 분리수거',
    isClear: false,
  }, {
    title: '고양이 밥주기',
    isClear: true,
  }, {
    title: '독서하기',
    isClear: false,
  }, {
    title: '영어 공부하기',
    isClear: false,
  }
];

// 여기에 코드를 작성해 주세요.
data.forEach((todo, i) => { // 1번 조건
  const li = document.createElement('li'); // 2번 조건
  
  if (todo.isClear) {
    li.classList.add('item', 'done'); // 4번 조건
  } else {
    li.classList.add('item'); // 3번 조건
  }

  li.textContent = `${i + 1}. ${todo.title}`; // 5번 조건
  list.appendChild(li); // 6번 조건
});


# 실습 설명
오늘 코드잇 커뮤니티 게시판에 아래의 배열 안에 숨겨진 인물을 찾으라는 퀴즈가 올라왔습니다.

['YUMMY', 'COUNT', 'ABUSE', 'SOUND', 'SWING']

평소 추리 소설을 좋아하는 종훈이는 잠깐의 고민으로 이 속에 YOUNG (강영훈의 닉네임)이 숨겨져 있다는 걸 찾아냈는데요.
템플릿에 주어진 배열의 map 메소드를 활용해서 'Y', 'O', 'U', 'N', 'G'을 추출한 새로운 배열을 answer 변수에 담아주세요.

셜록_훈즈

# 실습 결과
코드를 잘 작성했다면 아래와 같은 결과가 출력되어야 합니다.

[ 'Y', 'O', 'U', 'N', 'G']



# 해설
결과적으로 이번 과제는 주어진 배열의 각 요소에서, 그 요소에 해당하는 index 번째의 글자를 추출해내는 것이 관건입니다. 이런 상황에서는 map 메소드를 활용하면 간단하게 해결할 수가 있는데요.

map 메소드는 forEach와 비슷하게 아규먼트로 전달한 콜백 함수를 배열의 길이 만큼 반복해서 실행하는 메소드입니다. forEach 메소드와 다른 점은 콜백 함수가 리턴하는 값을 가지고 새로운 배열을 만들어 리턴한다는 점입니다. 그리고 콜백 함수의 첫 번째 파라미터에는 배열의 요소가, 두 번째 파라미터에는 index가 전달된다는 점을 활용하면 다음과 같이 코드를 작성할 수 있어요.

모범 답안 1
const quiz = ['YUMMY', 'COUNT', 'ABUSE', 'SOUND', 'SWING'];

// 여기에 코드를 작성하세요
const answer = quiz.map((word, i) => {
  return word[i];
});

// 테스트 코드
console.log(answer);
자바스크립트에서는 문자열도 indexing이 가능하다는 사실 잊지 않으셨죠? 참고로 이 코드의 경우에는 콜백 함수 내부에 단순히 return 문 하나만 있기 때문에 다음과 같이 간결하게 작성할 수도 있습니다.

모범 답안 2
const quiz = ['YUMMY', 'COUNT', 'ABUSE', 'SOUND', 'SWING'];

// 여기에 코드를 작성하세요
const answer = quiz.map((word, i) => word[i]);

// 테스트 코드
console.log(answer);
혹시 왜 이런 문법이 가능한건지 기억나지 않으신다면 Arrow Function 레슨을 복습해 보세요!




# 배열 메소드 II: filter와 find

const devices = [
  { name: 'GalaxyNote', brand: 'Samsung' },
  { name: 'MacbookPro', brand: 'Apple' },
  { name: 'iPad', brand: 'Apple' },
  { name: 'MacbookPro', brand: 'Apple' },
  { name: 'Gram', brand: 'LG' },
  { name: 'MacbookPro', brand: 'Apple' },
  { name: 'ZenBook', brand: 'Asus' },
];

# filter
const apples = devices.filter((el) => el.brand === 'Apple');

console.log(apples);

##
const myLaptop = devices.filter((el) => el.brand === 'Gram');

console.log(...myLaptop);

# find // 조건이 맞는 값을 찾으면 이후 반복되지 않고 종료
# 존재하지 않는 값을 찾을 경우 undefined가 출력 된다.
const myLaptop = devices.find((el) => el.name === 'Gram');

console.log(myLaptop);

const myLaptop = devices.find((el) => el.brand === 'Gram');

console.log(myLaptop);



# 서울 김서방 찾지 않기
# === 똑같은 값을 찾기 / !== 같지 않는 값을 찾기

const seoul = ['김영훈', '김윤수', '김동욱', '강대위', '김영준',
  '김규식', '김태호', '김효신', '손효준', '김현승', '김재하', '김유나',
  '김재훈', '김혜선', '김민환', '김규리', '김소원', '김우재', '최영준',
  '김태순', '김종훈', '김성환', '김승용', '김지혜', '이승욱', '김도현',
  '김승규', '윤하은', '김유진', '김정민', '김혜정', '김예진', '김여진',
  '김성희', '김혜수', '김인선', '김상필', '김혜진', '서상원', '김상혜',
  '김민기', '김그루', '김희지'];

// 여기에 코드를 작성하세요
const notKims = seoul.filter((name) => {
  return name[0] !== '김';
});

console.log(notKims); // (6) ["강대위", "손효준", "최영준", "이승욱", "윤하은", "서상원"]


##
const notKims = seoul.filter((name) => {
  return name[0] !== '김';
});
# 위 코드에서 Arrow Function을 좀 더 간결하게 작성하면 다음과 같이 줄일 수도 있습니다.
const notKims = seoul.filter((name) => name[0] !== '김');




# 이메일 찾기

실습 설명
주어진 템플릿 속의 data 변수에는 '주식회사 고두잇'의 유저 정보가 담겨 있는데요.
유저 이름과 전화번호를 입력하면, 해당하는 유저의 이메일을 찾아주는 기능을 만들고자 합니다.

find 메소드를 활용해서 입력받은 유저 이름과 전화번호가 일치하는 객체를 찾아 user 변수에 할당해 주세요!

findEmail 함수가 제대로 완성된다면, 각 input 태그에 적절한 값을 입력했을 때 해당하는 이메일을 잘 찾아줄 겁니다!


# 해설
이번 과제는 생각보다 간단하게 해결할 수가 있는데요.
find 메소드는 배열에서 콜백 함수가 리턴하는 조건을 만족하는 가장 첫 번째 요소를 리턴해주는 메소드입니다. 그래서 find 메소드에 전달하는 콜백 함수의 리턴 조건만 잘 정리해주면 됩니다.
findEmail 함수의 코드를 자세히 살펴보면 nameValue 변수에 nameInput 태그에 입력된 값을, phoneValue 변수에 phoneInput 태그에 입력된 값을 담아주고 있죠.
find 메소드를 통해서 data 배열 안에 있는 각 요소 중에서 userName과 phoneNumber 프로퍼티 값이 이 두 변수의 값과 일치하는 값을 찾아주면 됩니다.

# 모범 답안
해당 조건을 만족하도록 코드를 작성하면 다음과 같이 작성할 수 있습니다.



const nameInput = document.querySelector('#user-name');
const phoneInput = document.querySelector('#phone-number');
const findBtn = document.querySelector('#find');

const data = [
  { userName: '막대기', phoneNumber: '01012341111', email: 'stick@go_do_it.kr' },
  { userName: 'young', phoneNumber: '01012342222', email: 'kang@go_do_it.kr' },
  { userName: '코린이', phoneNumber: '01012343333', email: 'corin2@go_do_it.kr' },
  { userName: 'captain', phoneNumber: '01012344444', email: 'crew@go_do_it.kr' },
  { userName: 'YH', phoneNumber: '01012345555', email: 'whyH@go_do_it.kr' },
  { userName: '망고쥬스', phoneNumber: '01012346666', email: 'drinkMango@go_do_it.kr' },
  { userName: 'nemoming', phoneNumber: '01012347777', email: 'ractAngle@go_do_it.kr' },
  { userName: '강그루', phoneNumber: '01012348888', email: 'riverTree@go_do_it.kr' },
  { userName: '개룩발룩', phoneNumber: '01012349999', email: 'checkShirts@go_do_it.kr' },
  { userName: '오렌지쥬스', phoneNumber: '01012341010', email: 'delmonte@go_do_it.kr' },
];

function findEmail() {
  const nameValue = nameInput.value;
  const phoneValue = phoneInput.value;

  // 여기에 코드를 작성하세요
  const user = data.find((memberInfo) => nameValue === memberInfo.userName && phoneValue === memberInfo.phoneNumber);


  const message = user
    ? `${user.userName}님의 이메일은 ${user.email} 입니다.`
    : '이메일을 찾을 수 없습니다. 입력 정보를 다시 확인해 주세요.';

  alert(message);
}

findBtn.addEventListener('click', findEmail);

find 메소드를 통해서 일치하는 데이터가 없으면 user 변수에는 undefined 값이 담기게 되고 이어지는 message 변수에는 조건 연산자에서 false에 해당하는 메시지가 담기게 되겠죠?
반대로 입력값과 일치하는 데이터가 있으면 해당 객체가 user 변수에 담기고 message 변수에는 조건 연산자에서 true에 해당하는 메시지가 담기면서 이메일을 찾아주는 경고창이 나타나게 됩니다.

코드를 완성한 다음 여러분이 직접 한 번 테스트해 보세요!



# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>이메일 찾기</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="main">
    <h2 class="title">이메일 찾기</h2>
    <input id="user-name" class="input" type="text" placeholder="User Name">
    <input id="phone-number" class="input" type="text" placeholder="Phone Number">
    <button id="find" class="btn">Find</button>
  </div>
  <script src="index.js"></script>
</body>
</html>

# style.css
* {
  box-sizing: border-box;
}

body {
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100vh;
	margin: 0;
	padding: 0;
  background-image: url('imgs/background.jpg');
  background-position: right;
	background-size: cover;
	background-repeat: no-repeat;
}

body::after {
	display: block;
	content: '';
	width: 100%;
	height: 100%;
	position: absolute;
	top: 0;
	left: 0;
	background-color: #ababac;
	opacity: 0.3;
	z-index: -1;
}

.main {
	width: 360px;
	min-height: 350px;
	margin: 40px;
  padding: 20px 0;
  background-color: rgba(235, 236, 240, .95);
  box-shadow: 0px 0px 10px #BABECC;
  border-radius: 8px;
  text-align: center;
}

.title {
	margin: 20px auto 35px;
	font-size: 32px;
	font-weight: 900;
  color: #545454;
  text-shadow: 1px 1px 1px #FFFFFF;
}

.input {
  display: block;
  width: 80%;
  height: 50px;
  margin: 10px auto;
  padding: 10px 20px;
  font-size: 16px;
  text-shadow: 1px 1px 0 #ffffff;
  box-shadow: inset 2px 2px 5px #BABECC, inset -5px -5px 10px #FFFFFF;
  background-color: #EBECF0;
  border: none;
  border-radius: 320px;
  transition: all 0.2s ease-in-out;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
}

.input:focus {
  box-shadow:  inset 1px 1px 2px #BABECC, inset -1px -1px 2px #FFFFFF;
}

.btn {
  width: 80%;
  height: 50px;
  margin-top: 20px;
  border: none;
  border-radius: 320px;
  font-size: 20px;
  font-weight: 600;
  color: #545454;
  text-shadow: 1px 1px 0 #ffffff;
  box-shadow: -5px -5px 20px #FFFFFF, 5px 5px 20px #BABECC;
  transition: all 0.2s ease-in-out;
  cursor: pointer;
  outline: none;
}

.btn:hover {
  box-shadow: -2px -2px 5px #FFFFFF, 2px 2px 5px #BABECC;
}

.btn:active {
  box-shadow: inset 1px 1px 2px #BABECC, inset -1px -1px 2px #FFFFFF;
}


### index.js
const nameInput = document.querySelector('#user-name');
const phoneInput = document.querySelector('#phone-number');
const findBtn = document.querySelector('#find');

const data = [
  { userName: '막대기', phoneNumber: '01012341111', email: 'stick@go_do_it.kr' },
  { userName: 'young', phoneNumber: '01012342222', email: 'kang@go_do_it.kr' },
  { userName: '코린이', phoneNumber: '01012343333', email: 'corin2@go_do_it.kr' },
  { userName: 'captain', phoneNumber: '01012344444', email: 'crew@go_do_it.kr' },
  { userName: 'YH', phoneNumber: '01012345555', email: 'whyH@go_do_it.kr' },
  { userName: '망고쥬스', phoneNumber: '01012346666', email: 'drinkMango@go_do_it.kr' },
  { userName: 'nemoming', phoneNumber: '01012347777', email: 'ractAngle@go_do_it.kr' },
  { userName: '강그루', phoneNumber: '01012348888', email: 'riverTree@go_do_it.kr' },
  { userName: '개룩발룩', phoneNumber: '01012349999', email: 'checkShirts@go_do_it.kr' },
  { userName: '오렌지쥬스', phoneNumber: '01012341010', email: 'delmonte@go_do_it.kr' },
];

function findEmail() {
  const nameValue = nameInput.value;
  const phoneValue = phoneInput.value;

  // 여기에 코드를 작성하세요
  const user = data.find((memberInfo) => nameValue === memberInfo.userName && phoneValue === memberInfo.phoneNumber);


  const message = user
    ? `${user.userName}님의 이메일은 ${user.email} 입니다.`
    : '이메일을 찾을 수 없습니다. 입력 정보를 다시 확인해 주세요.';

  alert(message);
}

findBtn.addEventListener('click', findEmail);


# 배열 메소드 III: some과 every

// some과 every
const number = [1, 3, 5, 7, 9];

// some: 조건과 만족하는 요소가 1개 이상 있는지
const someReturn = numbers.some((el) => el > 5);

// every: 모든 요소가 조건을 만족하는지 (조건을 만족하지 않는 요소가 1개 이상 있는지)
const everyReturn = numbers.every((el) => el > 5);

console.log('some:', someReturn);
console.log('every:', everyReturn);

//출력
//some: true
//every: false

const someReturn = numbers.some((el, i) => {
  console.log('some', i);
  return el > 5;
});

console.log('some:', someReturn);


# 이중 스파이가 있다.
# 해설
some 메소드는 조건을 만족하는 요소가 1개 이상 있는지 확인하는 메소드이고, 반대로 every 메소드는 모든 요소가 조건을 만족하는지를 확인하는 메소드입니다.
그런데 동작방식을 좀 더 살펴보면, every 메소드는 조건을 만족하지 않는 요소가 1개 이상 있는지 확인하는 메소드라고 생각할 수도 있는데요. 
걀과적으로 이 두 메소드는 콜백 함수가 리턴하는 조건에 따라 true 혹은 false를 리턴합니다.

일단은 team 파라미터의 members 배열 속에 이중 스파이가 있는지 없는지 확인해야겠죠? some 메소드를 활용해서 각 팀의 맴버들 중에 스파이가 아닌 사람을 찾아내려면 다음과 같이 작성할 수 있는데요.

function checkSpy(team) {
  // 여기에 코드를 작성하세요
  const result = team.members.some((member) => member !== '스파이');

  console.log(message);
}
team의 members에 접근한 다음(team.members), some 메소드를 활용해서 멤버의 이름이 스파이가 아닌지(member !== '스파이')를 확인한 결과를 result 변수에 담았습니다. 
그러면 result는 멤버중에 이중 스파이가 1명이라도 있으면 true를, 이중 스파이가 없으면 false 값을 가지게 되겠죠? 
이제 이 값을 가지고 message 변수에 적절한 문장을 담아주면 됩니다. 가장 단순한 방법은 미리 message 변수를 선언하고 if문을 활용하는 방식인데요.

function checkSpy(team) {
  // 여기에 코드를 작성하세요
  const result = team.members.some((member) => member !== '스파이');
  let message = '';

  if (result) {
    message = `[주의!] 팀 ${team.codeName} 에 이중 스파이가 있습니다!`;
  } else {
    message = `팀 ${team.codeName} 에는 이중 스파이가 없습니다.`;
  }

  console.log(message);
}
하지만 이런 상황에서 이전에 배웠던 조건 연산자를 활용하면 훨씬 더 코드가 간결하게 작성할 수 있고, 변수를 선언함과 동시에 조건에 맞는 값을 바로 할당할 수 있어서 let 키워드로 미리 변수를 선언하고 값을 재할당하는 번거로움도 해소할 수 있습니다.

function checkSpy(team) {
  // 여기에 코드를 작성하세요
  const result = team.members.some((member) => member !== '스파이');
  const message = result
    ? `[주의!] 팀 ${team.codeName} 에 이중 스파이가 있습니다!`
    : `팀 ${team.codeName} 에는 이중 스파이가 없습니다.`;

  console.log(message);
}
훨씬 코드가 간결해졌죠? 이런 상황에서 조건 연산자를 활용할 수 있다는 점도 잘 참고해 두시면 좋을 것 같습니다. 그리고 한 가지 더 살펴보면 이런 상황에서 Destructuring도 활용할 수 있는데요.

function checkSpy(team) {
  // 여기에 코드를 작성하세요
  const { codeName, members } = team;
  const result = members.some((member) => member !== '스파이');
  const message = result
    ? `[주의!] 팀 ${codeName} 에 이중 스파이가 있습니다!`
    : `팀 ${codeName} 에는 이중 스파이가 없습니다.`;

  console.log(message);
}
코드가 한 줄 더 추가되긴 했지만 members와 codeName을 사용할 때 조금 더 간결하게 작성할 수 있다는 장점이 있습니다.

끝으로 이 과제를 every로도 해결할 수 있는데요.

function checkSpy(team) {
  // 여기에 코드를 작성하세요
  const { codeName, members } = team;
  const result = members.every((member) => member === '스파이');
  const message = result
    ? `팀 ${codeName} 에는 이중 스파이가 없습니다.`
    : `[주의!] 팀 ${codeName} 에 이중 스파이가 있습니다!`;

  console.log(message);
}
every 메소드를 활용해서 모든 멤버들이 '스파이'인지를 확인한 다음 결과에 따라 message의 값을 할당해 주면 되겠죠?


# 배열 메소드 IV: reduce

// reduce
const numbers = [1, 2, 3, 4];

numbers.reduce((acc, el, i, arr) => {
  return nextAccValue;
}, initialAccValue);


# acc : Accumulator(누산기)


const numbers = [1, 2, 3, 4];

const sumAll = numbers.reduce((acc, el, i, arr) => {
  console.log('${i}번 index의 요소로 콜백함수가 동작중입니다.');
  console.log('acc:', acc);
  console.log('el:', el);
  console.log('-----------');

  return acc + el;
}, 0);

console.log('sumAll:', sumAll);


# , 0); 초기값을 지정하지 않으면 index 1번부터 출력된다. reduce 마지막 0번 인덱스를 지정해 주는것이 좋다.


# 실습 설명

상원이는 세계적인 기업에서 인턴 및 개발자로서 다양한 경력을 쌓은 훌륭한 인재입니다.
Microhard 에서의 경력을 마지막으로 잠시 휴식기간을 가졌던 상원이는 다시금 세계적인 기업들과 함께 성장하기 위해 그동안의 경력을 바탕으로 코드잇에 입사를 지원하고자 하는데요.
이력서를 정리하던 중 그동안 자신이 얼마나 일을 했었는지 새삼 궁금해져 데이터를 만들었습니다.

reduce 메소드를 활용해서 상원이가 일한 경력(개월 수)을 합산한 값을 totalCareer 변수에 담아주세요.

코드를 잘 작성하셨다면 다음과 같은 결과가 출력되어야 합니다.

# 실습 결과
상원이의 경력은 총 55개월입니다.

# 해설
reduce 메소드를 활용하면 누적값을 좀 더 편리하게 작성할 수 있습니다. reduce 메소드는 일반적으로 두 개의 파라미터를 활용하는데요. 첫 번째 파라미터에 반복 동작할 콜백 함수를 전달하고, 두 번째는 초깃값을 전달하게 됩니다.

상원이의 경력을 누적으로 계산해야 되니깐, 일단 초깃값은 0으로 두고 매번 실행하는 콜백함수는 첫 번째 파라미터에 각 요소의 month 프로퍼티 값을 더해서 리턴해 주면 되는데요.

const totalCareer = data.reduce((acc, el) => {
  return acc + el.month;
}, 0);
이렇게 작성하면 첫 번째 반복 때는 콜백 함수의 첫 번째 파라미터(acc)에 초깃값 0이 전달되면서 0 + 3 이 리턴되고, 두 번째 반복 때는 이전 콜백 함수가 리턴한 3 이 첫 번째 파라미터(acc)에 전달되니깐, 3 + 12 가 리턴되겠죠? 최종적으로는 모든 요소들의 month 프로퍼티를 더한 값이 리턴되니깐 totalCareer 변수에는 55 가 할당됩니다.

참고로 이 코드는 Arrow Function에서 return 문만 있기 때문에 다음과 같이 축약해서 사용할 수도 있습니다.

# 모범 답안
const data = [ 
  { company: 'Naber', month: 3 },
  { company: 'Amajohn', month: 12 },
  { company: 'Coogle', month: 10 },
  { company: 'Ittel', month: 6 },
  { company: 'Sasung', month: 4 },
  { company: 'CaCao', month: 3 },
  { company: 'Microhard', month: 17 },
];

// 여기에 코드를 작성하세요
const totalCareer = data.reduce((acc, el) => acc + el.month, 0);

console.log(`상원이의 경력은 총 ${totalCareer}개월입니다.`);


# sort 메소드
배열에서 sort라는 메소드를 활용하면 배열을 정렬할 수 있습니다.
sort 메소드에 아무런 아규먼트도 전달하지 않을 때는 기본적으로 유니코드에 정의된 문자열 순서에 따라 정렬됩니다.

const letters = ['D', 'C', 'E', 'B', 'A'];
const numbers = [1, 10, 4, 21, 36000];

letters.sort();
numbers.sort();

console.log(letters); // (5) ["A", "B", "C", "D", "E"]
console.log(numbers); // (5) [1, 10, 21, 36000, 4]
그렇기 때문에 numbers에 sort 메소드를 사용한 것 처럼, 숫자를 정렬할 때는 우리가 상식적으로 이해하는 오름차순이나 내림차순 정렬이 되지 않습니다.

그럴 땐 sort 메소드에 다음과 같은 콜백함수를 아규먼트로 작성해주면 되는데요.

const numbers = [1, 10, 4, 21, 36000];

// 오름차순 정렬
numbers.sort((a, b) => a - b);
console.log(numbers); // (5) [1, 4, 10, 21, 36000]

// 내림차순 정렬
numbers.sort((a, b) => b - a);
console.log(numbers); // (5) [36000, 21, 10, 4, 1]
sort 메소드를 사용할 때 한 가지 주의해야될 부분은 메소드를 실행하는 원본 배열의 요소들을 정렬한다는 점입니다.
그래서 한 번 정렬하고 나면 정렬하기 전의 순서로 다시 되돌릴 수 없으니, 그런 경우에는 미리 다른 변수에 복사해두는 것이 좋겠죠!?


# reverse 메소드

reverse 메소드는 말 그대로 배열의 순서를 뒤집어 주는 메소드 입니다.
reverse 메소드는 별도의 파라미터가 존재하지 않기 때문에 단순히 메소드를 호출해주기만 하면 배열의 순서가 뒤집히는데요.
sort 메소드와 마찬가지로 원본 배열의 요소들을 뒤집어 버린다는 점은 꼭 주의헤야 합니다.

const letters = ['a', 'c', 'b'];
const numbers = [421, 721, 353];

letters.reverse();
numbers.reverse();

console.log(letters); // (3) ["b", "c", "a"]
console.log(numbers); // (3) [353, 721, 421]



# Map과 Set

객체는 property name을 통해 이름이 있는 여러 값들을 묶을 때 활용할 수 있고,
배열은 index를 통해 순서가 있는 여러 값들을 묶을 때 유용하게 활용할 수 있습니다.

그런데 ES2015에서 객체와 비슷한 Map과 배열과 비슷한 Set이라는 데이터 구조가 새롭게 등장했는데요.
각각 어떤 특징들을 가지고 있는지 간단하게 살펴보도록 합시다.

# Map
Map은 이름이 있는 데이터를 저장한다는 점에서 객체와 비슷합니다.
하지만, 할당연산자를 통해 값을 추가하고 점 표기법이나 대괄호 표기법으로 접근하는 일반 객체와 다르게 
Map은 메소드를 통해서 값을 추가하거나 접근할 수 있는데요.

new 키워드를 통해서 Map을 만들 수 있고 아래와 같은 메소드를 통해 Map 안의 여러 값들을 다룰 수 있습니다.

map.set(key, value): key를 이용해 value를 추가하는 메소드.
map.get(key): key에 해당하는 값을 얻는 메소드. key가 존재하지 않으면 undefined를 반환.
map.has(key): key가 존재하면 true, 존재하지 않으면 false를 반환하는 메소드.
map.delete(key): key에 해당하는 값을 삭제하는 메소드.
map.clear(): Map 안의 모든 요소를 제거하는 메소드.
map.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)
// Map 생성
const codeit = new Map();

// set 메소드
codeit.set('title', '문자열 key');
codeit.set(2017, '숫자형 key');
codeit.set(true, '불린형 key');

// get 메소드
console.log(codeit.get(2017)); // 숫자형 key
console.log(codeit.get(true)); // 불린형 key
console.log(codeit.get('title')); // 문자열 key

// has 메소드
console.log(codeit.has('title')); // true
console.log(codeit.has('name')); // false

// size 프로퍼티
console.log(codeit.size); // 3

// delete 메소드
codeit.delete(true);
console.log(codeit.get(true)); // undefined
console.log(codeit.size); // 2

// clear 메소드
codeit.clear();
console.log(codeit.get(2017)); // undefined
console.log(codeit.size); // 0
문자열과 심볼 값만 key(프로퍼티 네임)로 사용할 수 있는 일반 객체와는 다르게
Map 객체는 메소드를 통해 값을 다루기 때문에, 다양한 자료형을 key로 활용할 수 있다는 장점이 있습니다.

# Set
Set은 여러 개의 값을 순서대로 저장한다는 점에서 배열과 비슷합니다.
하지만, 배열의 메소드는 활용할 수 없고 Map과 비슷하게 Set만의 메소드를 통해서 값을 다루는 특징이 있는데요.

Map과 마찬가지로 new 키워드로 Set을 만들 수 있고 아래와 같은 메소드를 통해 Set 안의 여러 값들을 다룰 수 있습니다.

set.add(value): 값을 추가하는 메소드. (메소드를 호출한 자리에는 추가된 값을 가진 Set 자신을 반환.)
set.has(value): Set 안에 값이 존재하면 true, 아니면 false를 반환하는 메소드.
set.delete(value): 값을 제거하는 메소드. (메소드를 호출한 자리에는 셋 내에 값이 있어서 제거에 성공하면 true, 아니면 false를 반환.)
set.clear(): Set 안의 모든 요소를 제거하는 메소드.
set.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)
// Set 생성
const members = new Set();

// add 메소드
members.add('영훈'); // Set(1) {"영훈"}
members.add('윤수'); // Set(2) {"영훈", "윤수"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}

// has 메소드
console.log(members.has('동욱')); // true
console.log(members.has('현승')); // false

// size 프로퍼티
console.log(members.size); // 4

// delete 메소드
members.delete('종훈'); // false
console.log(members.size); // 4
members.delete('태호'); // true
console.log(members.size); // 3

// clear 메소드
members.clear();
console.log(members.size); // 0
한가지 특이한 점은 일반 객체는 프로퍼티 네임으로, Map은 get메소드로, 그리고 배열은 index를 통해서 개별 값에 접근할 수 있었는데요.
한 가지 특이한 점은 Set에는 개별 값에 바로 접근하는 방법이 없다는 점입니다.

// Set 생성
const members = new Set();

// add 메소드
members.add('영훈'); // Set(1) {"영훈"}
members.add('윤수'); // Set(2) {"영훈", "윤수"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}

for (const member of members) {
  console.log(member); // 영훈, 윤수, 동욱, 태호가 순서대로 한 줄 씩 콘솔에 출력됨.
}
그래서 위 코드와 같이 반복문을 통해서 전체요소를 한꺼번에 다룰 때 반복되는 그 순간에 개별적으로 접근할 수가 있습니다.
그런데, 이런 특징을 가지고도 Set이 유용하게 사용되는 경우가 있는데요.
바로, 중복을 허용하지 않는 값들을 모을 때입니다.

Set은 중복되는 값을 허용하지 않는 독특한 특징이 있는데요.

// Set 생성
const members = new Set();

// add 메소드
members.add('영훈'); // Set(1) {"영훈"}
members.add('윤수'); // Set(2) {"영훈", "윤수"}
members.add('영훈'); // Set(2) {"영훈", "윤수"}
members.add('영훈'); // Set(2) {"영훈", "윤수"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}
members.add('동욱'); // Set(4) {"영훈", "윤수", "동욱", "태호"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}
최초에 추가된 순서를 유지하면서, 나중에 중복된 값을 추가하려고 하면 그 값은 무시하는 특징이 있습니다.

처음 Set을 생성할 때 아규먼트로 배열을 전달할 수도 있는데요.
이런 특징을 활용해서 배열 내에서 중복을 제거한 값들의 묶음을 만들 때 Set을 활용하기도 합니다.

const numbers = [1, 3, 4, 3, 3, 3, 2, 1, 1, 1, 5, 5, 3, 2, 1, 4];
const uniqNumbers = new Set(numbers);

console.log(uniqNumbers); // Set(5) {1, 3, 4, 2, 5}



# 종합 정리

forEach 메소드
배열의 요소를 하나씩 살펴보면서 반복 작업을 하는 메소드입니다. forEach 메소드는 첫 번째 아규먼트로 콜백 함수를 전달받는데요. 콜백 함수의 파라미터에는 각각 배열의 요소, index, 메소드를 호출한 배열이 전달됩니다. (index와 array는 생략가능)

const numbers = [1, 2, 3];

numbers.forEach((element, index, array) => {
  console.log(element); // 순서대로 콘솔에 1, 2, 3이 한 줄씩 출력됨.
});
map 메소드
forEach와 비슷하게 배열의 요소를 하나씩 살펴보면서 반복 작업을 하는 메소드 입니다. 단, 첫 번째 아규먼트로 전달하는 콜백 함수가 매번 리턴하는 값들을 모아서 새로운 배열을 만들어 리턴하는 특징이 있습니다.

const numbers = [1, 2, 3];
const twiceNumbers = numbers.map((element, index, array) => {
  return element * 2;
});

console.log(twiceNumbers); // (3) [2, 4, 6]
filter 메소드
filter 메소드는 배열의 요소를 하나씩 살펴보면서 콜백함수가 리턴하는 조건과 일치하는 요소만 모아서 새로운 배열을 리턴하는 메소드입니다.

const devices = [
  {name: 'GalaxyNote', brand: 'Samsung'},
  {name: 'MacbookPro', brand: 'Apple'},
  {name: 'Gram', brand: 'LG'},
  {name: 'SurfacePro', brand: 'Microsoft'},
  {name: 'ZenBook', brand: 'Asus'},
  {name: 'MacbookAir', brand: 'Apple'},
];

const apples = devices.filter((element, index, array) => {
  return element.brand === 'Apple';
});

console.log(apples); // (2) [{name: "MacbookPro", brand: "Apple"}, {name: "MacbookAir", brand: "Apple"}]
find 메소드
find 메소드는 filter 메소드와 비슷하게 동작하지만, 배열의 요소들을 반복하는 중에 콜백함수가 리턴하는 조건과 일치하는 가장 첫번째 요소를 리턴하고 반복을 종료하는 메소드 입니다.

const devices = [
  {name: 'GalaxyNote', brand: 'Samsung'},
  {name: 'MacbookPro', brand: 'Apple'},
  {name: 'Gram', brand: 'LG'},
  {name: 'SurfacePro', brand: 'Microsoft'},
  {name: 'ZenBook', brand: 'Asus'},
  {name: 'MacbookAir', brand: 'Apple'},
];

const myLaptop = devices.find((element, index, array) => {
  console.log(index); // 콘솔에는 0, 1, 2까지만 출력됨.
  return element.name === 'Gram';
});

console.log(myLaptop); // {name: "Gram", brand: "LG"}
some 메소드
some 메소드는 배열 안에 콜백함수가 리턴하는 조건을 만족하는 요소가 1개 이상 있는지를 확인하는 메소드 입니다. 배열을 반복하면서 모든 요소가 콜백함수가 리턴하는 조건을 만족하지 않는다면 false를 리턴하고, 배열을 반복하면서 콜백함수가 리턴하는 조건을 만족하는 요소가 등장한다면 바로 true를 리턴하고 반복을 종료합니다.

const numbers = [1, 3, 5, 7, 9];

// some: 조건을 만족하는 요소가 1개 이상 있는지
const someReturn = numbers.some((element, index, array) => {
  console.log(index); // 콘솔에는 0, 1, 2, 3까지만 출력됨.
  return element > 5;
});

console.log(someReturn); // true;
every 메소드
every 메소드는 배열 안에 콜백 함수가 리턴하는 조건을 만족하지 않는 요소가 1개 이상 있는지를 확인하는 메소드 입니다.
배열을 반복하면서 모든 요소가 콜백함수가 리턴하는 조건을 만족한다면 true를 리턴하고, 배열을 반복하면서 콜백함수가 리턴하는 조건을 만족하지 않는 요소가 등장한다면 바로 false를 리턴하고 반복을 종료합니다.

const numbers = [1, 3, 5, 7, 9];

// every: 조건을 만족하지 않는 요소가 1개 이상 있는지
const everyReturn = numbers.every((element, index, array) => {
  console.log(index); // 콘솔에는 0까지만 출력됨.
  return element > 5;
});

console.log(everyReturn); // false;
reduce 메소드
reduce 메소드는 누적값을 계산할 때 활용하는 조금 독특한 메소드 입니다. reduce 메소드는 일반적으로 두 개의 파라미터를 활용하는데요.
첫 번째는 반복동작할 콜백함수입니다. 매번 실행되는 콜백함수의 리턴값이 다음에 동작할 콜백함수의 첫번째 파라미터로 전달되는데요. 결과적으로 마지막 콜백함수가 리턴하는 값이 reduce 메소드의 최종 리턴값이 되는겁니다.
이 때 reduce 메소드의 두 번째 파라미터로 전달한 초기값이 첫 번째로 실행될 콜백함수의 가장 첫 번째 파라미터로 전달되는 것이죠.

const numbers = [1, 2, 3, 4];

// reduce
const sumAll = numbers.reduce((accumulator, element, index, array) => {
  return accumulator + element;
}, 0);

console.log(sumAll); // 10
처음에는 조금 복잡할 수 있지만, 원리를 잘 이해하고나면 유용하게 활용할 수 있으니 포기하지 마시고 잘 기억해 주세요!

sort 메소드
배열에서 sort라는 메소드를 활용하면 배열을 정렬할 수 있습니다.
sort 메소드에 아무런 아규먼트도 전달하지 않을 때는 기본적으로 유니코드에 정의된 문자열 순서에 따라 정렬됩니다.

const letters = ['D', 'C', 'E', 'B', 'A'];
const numbers = [1, 10, 4, 21, 36000];

letters.sort();
numbers.sort();

console.log(letters); // (5) ["A", "B", "C", "D", "E"]
console.log(numbers); // (5) [1, 10, 21, 36000, 4]
그렇기 때문에 numbers에 sort 메소드를 사용한 것 처럼, 숫자를 정렬할 때는 우리가 상식적으로 이해하는 오름차순이나 내림차순 정렬이 되지 않습니다. 그럴 땐 sort 메소드에 다음과 같은 콜백함수를 아규먼트로 작성해주면 되는데요.

const numbers = [1, 10, 4, 21, 36000];

// 오름차순 정렬
numbers.sort((a, b) => a - b);
console.log(numbers); // (5) [1, 4, 10, 21, 36000]

// 내림차순 정렬
numbers.sort((a, b) => b - a);
console.log(numbers); // (5) [36000, 21, 10, 4, 1]
sort 메소드를 사용할 때 한 가지 주의해야될 부분은 메소드를 실행하는 원본 배열의 요소들을 정렬한다는 점입니다. 그래서 한 번 정렬하고 나면 정렬하기 전의 순서로 다시 되돌릴 수 없으니까, 원본 배열의 순서가 필요하다면 미리 다른 변수에 복사해두는 것이 좋겠죠!?

reverse 메소드
reverse 메소드는 말 그대로 배열의 순서를 뒤집어 주는 메소드 입니다. reverse 메소드는 별도의 파라미터가 존재하지 않기 때문에 단순히 메소드를 호출해주기만 하면 배열의 순서가 뒤집히는데요. sort 메소드와 마찬가지로 원본 배열의 요소들을 뒤집어 버린다는 점은 꼭 주의헤야 합니다.

const letters = ['a', 'c', 'b'];
const numbers = [421, 721, 353];

letters.reverse();
numbers.reverse();

console.log(letters); // (3) ["b", "c", "a"]
console.log(numbers); // (3) [353, 721, 421]
Map
Map은 이름이 있는 데이터를 저장한다는 점에서 객체와 비슷합니다. 하지만, 할당연산자를 통해 값을 추가하고 점 표기법이나 대괄호 표기법으로 접근하는 일반 객체와 다르게 Map은 메소드를 통해서 값을 추가하거나 접근할 수 있는데요.
new 키워드를 통해서 Map을 만들 수 있고 아래와 같은 메소드를 통해 Map 안의 여러 값들을 다룰 수 있습니다.

map.set(key, value): key를 이용해 value를 추가하는 메소드.
map.get(key): key에 해당하는 값을 얻는 메소드. key가 존재하지 않으면 undefined를 반환.
map.has(key): key가 존재하면 true, 존재하지 않으면 false를 반환하는 메소드.
map.delete(key): key에 해당하는 값을 삭제하는 메소드.
map.clear(): Map 안의 모든 요소를 제거하는 메소드.
map.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)
// Map 생성
const codeit = new Map();

// set 메소드
codeit.set('title', '문자열 key');
codeit.set(2017, '숫자형 key');
codeit.set(true, '불린형 key');

// get 메소드
console.log(codeit.get(2017)); // 숫자형 key
console.log(codeit.get(true)); // 불린형 key
console.log(codeit.get('title')); // 문자열 key

// has 메소드
console.log(codeit.has('title')); // true
console.log(codeit.has('name')); // false

// size 프로퍼티
console.log(codeit.size); // 3

// delete 메소드
codeit.delete(true);
console.log(codeit.get(true)); // undefined
console.log(codeit.size); // 2

// clear 메소드
codeit.clear();
console.log(codeit.get(2017)); // undefined
console.log(codeit.size); // 0
문자열과 심볼 값만 key(프로퍼티 네임)로 사용할 수 있는 일반 객체와는 다르게 Map 객체는 메소드를 통해 값을 다루기 때문에, 다양한 자료형을 key로 활용할 수 있다는 장점이 있습니다.

Set
Set은 여러 개의 값을 순서대로 저장한다는 점에서 배열과 비슷합니다. 하지만, 배열의 메소드는 활용할 수 없고 Map과 비슷하게 Set만의 메소드를 통해서 값을 다루는 특징이 있는데요.
Map과 마찬가지로 new 키워드로 Set을 만들 수 있고 아래와 같은 메소드를 통해 Set 안의 여러 값들을 다룰 수 있습니다.

set.add(value): 값을 추가하는 메소드. (메소드를 호출한 자리에는 추가된 값을 가진 Set 자신을 반환.)
set.has(value): Set 안에 값이 존재하면 true, 아니면 false를 반환하는 메소드.
set.delete(value): 값을 제거하는 메소드. (메소드를 호출한 자리에는 셋 내에 값이 있어서 제거에 성공하면 true, 아니면 false를 반환.)
set.clear(): Set 안의 모든 요소를 제거하는 메소드.
set.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)
// Set 생성
const members = new Set();

// add 메소드
members.add('영훈'); // Set(1) {"영훈"}
members.add('윤수'); // Set(2) {"영훈", "윤수"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}

// has 메소드
console.log(members.has('동욱')); // true
console.log(members.has('현승')); // false

// size 프로퍼티
console.log(members.size); // 4

// delete 메소드
members.delete('종훈'); // false
console.log(members.size); // 4
members.delete('태호'); // true
console.log(members.size); // 3

// clear 메소드
members.clear();
console.log(members.size); // 0
한가지 특이한 점은 일반 객체는 프로퍼티 네임으로, Map은 get메소드로, 그리고 배열은 index를 통해서 개별 값에 접근할 수 있었는데요. 한 가지 특이한 점은 Set에는 개별 값에 바로 접근하는 방법이 없다는 점입니다.

// Set 생성
const members = new Set();

// add 메소드
members.add('영훈'); // Set(1) {"영훈"}
members.add('윤수'); // Set(2) {"영훈", "윤수"}
members.add('동욱'); // Set(3) {"영훈", "윤수", "동욱"}
members.add('태호'); // Set(4) {"영훈", "윤수", "동욱", "태호"}

for (const member of members) {
  console.log(member); // 영훈, 윤수, 동욱, 태호가 순서대로 한 줄 씩 콘솔에 출력됨.
}
그래서 위 코드와 같이 반복문을 통해서 전체요소를 한꺼번에 다룰 때 반복되는 그 순간에 개별적으로 접근할 수가 있습니다.
그런데, 이런 특징을 가지고도 Set이 유용하게 사용되는 경우가 있는데요. 바로, 중복을 허용하지 않는 값들을 모을 때입니다.

Set은 중복되는 값을 허용하지 않는 독특한 특징이 있는데요. Set 객체에 요소를 추가할 때 이미 Set 객체 안에 있는 값(중복된 값)을 추가하려고 하면 그 값은 무시되는 특징이 있습니다.
처음 Set을 생성할 때 아규먼트로 배열을 전달할 수가 있는데요. 이런 특징을 활용해서 배열 내에서 중복을 제거한 값들의 묶음을 만들 때 Set을 활용할 수 있습니다.

const numbers = [1, 3, 4, 3, 3, 3, 2, 1, 1, 1, 5, 5, 3, 2, 1, 4];
const uniqNumbers = new Set(numbers);

console.log(uniqNumbers); // Set(5) {1, 3, 4, 2, 5}



# 자바스크립트 모듈
# 모듈이란?

모듈화(Modularization)
모듈(Module)

// 모듈 파일의 조건
const title = 'CodeitPrinter';

function print(value) {
  console.log(value);
}

# 모듈 파일의 조건
# 스코프가 겹쳐서 에러가 발생 하거나 문제가 발생할 수 있다.
// <script src="printer.js"></script>
// <script src="index.js"></script>

// <script type="module" src="printer.js"></script>


# Live Server 설치하기

# export
export const title = 'CodeitPrinter';

export function print(value) {
  console.log(value);
}

# import
import { title, print } from './printer.js';

print(title);



# 메뉴 추가 기능 붙이기
해설
자바스크립트의 모듈 문법은 기본적으로 export와 import입니다. 모듈 스코프를 가진 파일에서 외부로 내보내고자 하는 변수나 함수를 export 키워드를 통해 내보내고, 모듈 파일에서 내보낸 변수나 함수들은 다른 파일에서 import 키워드를 통해 가져옵니다.

add.js의 addMenu 함수를 내보내고, index.js에서 가져오려면 다음과 같이 코드를 작성하면 되겠죠?

index.js

// 여기에 코드를 작성하세요
import { addMenu } from './add.js';

const data = [];
const addBtn = document.querySelector('.add-btn');
const addInput = document.querySelector('.add-input');

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));
add.js

const addInput = document.querySelector('.add-input');
const list = document.querySelector('.list');

function add(data) {
  const inputValue = addInput.value;
  const index = data.length;

  const li = document.createElement('li');
  li.classList.add('item');
  li.innerHTML = `<b>${index + 1}</b>${inputValue}<button class="del-btn" data-index="${index}">x</div>`;
  list.append(li);

  data.push(inputValue);

  addInput.value = '';
  addInput.focus();
}

function emptyAlert() {
  alert('고민되는 메뉴를 입력해 주세요.');
  addInput.focus();
}

function maxAlert() {
  alert('메뉴는 최대 5개까지만 고민할 수 있습니다.');
  addInput.value = '';
}

// 아래 코드를 수정해 주세요
export function addMenu(data) {
  const inputValue = addInput.value;

  if (inputValue === '') {
    emptyAlert();
  } else if (data.length > 4) {
    maxAlert();
  } else {
    add(data);
  }
};



# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>오늘 뭐 먹지?</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="circle1"></div>
  <div class="circle2"></div>
  <div class="main">
    <div class="container">
      <h2 class="title">오늘 뭐 먹지?</h2>
      <div class="add-column">
        <input class="add-input" type="text">
        <button class="add-btn">Add</button>
      </div>
    </div>
    <ul class="list"></ul>
    <button class="roll-btn">Roll</button>
  </div>
  <script type="module" src="index.js"></script>
</body>
</html>

# add.js
const addInput = document.querySelector('.add-input');
const list = document.querySelector('.list');

function add(data) {
  const inputValue = addInput.value;
  const index = data.length;

  const li = document.createElement('li');
  li.classList.add('item');
  li.innerHTML = `<b>${index + 1}</b>${inputValue}<button class="del-btn" data-index="${index}">x</button>`;
  list.append(li);

  data.push(inputValue);

  addInput.value = '';
  addInput.focus();
}

function emptyAlert() {
  alert('고민되는 메뉴를 입력해 주세요.');
  addInput.focus();
}

function maxAlert() {
  alert('메뉴는 최대 5개까지만 고민할 수 있습니다.');
  addInput.value = '';
}

// 아래 코드를 수정해 주세요
export function addMenu(data) {
  const inputValue = addInput.value;

  if (inputValue === '') {
    emptyAlert();
  } else if (data.length > 4) {
    maxAlert();
  } else {
    add(data);
  }
}


# index.js
// 여기에 코드를 작성하세요
import { addMenu } from './add.js';

const data = [];
const addBtn = document.querySelector('.add-btn');
const addInput = document.querySelector('.add-input');

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));


# style.css
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
	font-family: sans-serif;
}

body {
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: 100vh;
	background-image: linear-gradient(to right top, #FFC9C9, #8CD3F9);
}

.circle1,
.circle2 {
	width: 200px;
	height: 200px;
	position: absolute;
	border-radius: 50%;
	background-image: linear-gradient(to right bottom, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.1));
}

.circle1 {
	bottom: calc(50% + 160px);
	left: calc(50% + 110px);
}

.circle2 {
	top: calc(50% + 120px);
	right: calc(50% + 130px);
}

.main {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	align-items: center;
	width: 360px;
	height: 530px;
	border-radius: 15px;
  background-image: linear-gradient(to right bottom, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
  z-index: 1;
}

.container {
	width: 100%;
	padding: 25px;
	background-image: linear-gradient(to right bottom, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
	border-radius: 15px;
	color: #658EC6;
}

.title {
	font-size: 30px;
	color: #426696;
	text-align: center;
	opacity: 0.8;
}

.add-column {
	display: flex;
	justify-content: center;
	margin-top: 15px;
}

.add-input {
	width: 200px;
	padding: 10px;
	background-color: linear-gradient(to right bottom, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
	border: none;
	border-radius: 5px;
}

.add-btn {
	padding: 10px;
	color: #FFFFFF;
	background-color: #8CD3F9;
	border: none;
	border-radius: 5px;
	font-weight: 600;
}

.list {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	width: 100%;
	height: 333px;
}

.item {
  position: relative;
	display: flex;
	align-items: center;
	width: 80%;
	height: 48px;
	margin: 7px;
	padding: 5px;
	color: #658EC6;
	background-image: linear-gradient(to right bottom, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
	border-radius: 45px;
  list-style: none;
  transition: all 1s ease-in-out;
}

.item b {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 40px;
	height: 40px;
	margin-right: 15px;
	color: #FFFFFF;
  text-align: center;
  background-color: #FFC9C9;
  border-radius: 40px;
}

.del-btn {
  position: absolute;
  top: -5px;
  right: -10px;
  width: 30px;
  height: 30px;
  border: none;
  border-radius: 50%;
  color: #FF00D9;
  font-weight: 900;
  background-color: transparent;
  background-image: linear-gradient(to right bottom, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
  transition: all 0.3s ease-in-out;
  cursor: pointer;
  opacity: 0;
}

.item:hover .del-btn {
  opacity: 1;
}

.roll-btn {
	width: 100px;
	height: 45px;
	padding: 10px;
	margin-bottom: 15px;
	font-size: 18px;
	color: #FFFFFF;
	background-color: #8CD3F9;
	border: none;
	border-radius: 5px;
  font-weight: 900;
  cursor: pointer;
}

@keyframes roll {
  0% { transform: rotateX(0deg); }
  50% { transform: rotateX(180deg); }
  100% { transform: rotateX(0deg); }
}

.rolling .item {
  height: 0;
  margin: 0;
  padding: 0 5px; 
  animation: roll .5s infinite linear;
}

.item.selected {
  animation: roll .4s 2 linear;
}



# 다른 자바스크립트 파일 내용을 import후 함수 이름을 변경 할때
# as를 사용해서 이름을 변경해준다.

import { addMenu } from './add.js';

import { addMenu as addFood } from './add.js';



# 이름 바꿔 붙이기
# 해설
모듈 문법을 활용할 때 import할 변수나 함수 이름을 조금 더 간결한 이름으로 바꾸거나, 혹은 더 구체적으로 바꾸고 싶을 수도 있습니다. 그럴 때 import 키워드를 통해 모듈을 불러올 때 as 키워드를 활용하면 import하는 대상들의 이름을 변경할 수 있는데요.
delete.js에서 export 한 deleteMenuByIndex 를 'index.js'에서 deleteMenu 라는 이름으로 import하려면 다음과 같이 코드를 작성하면 됩니다.

# 모범 답안
index.js

import { addMenu } from './add.js';
// 여기에 코드를 작성하세요
import { deleteMenuByIndex as deleteMenu } from './delete.js';

const data = [];
const addBtn = document.querySelector('.add-btn');
const addInput = document.querySelector('.add-input');
const list = document.querySelector('.list');

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));
list.addEventListener('click', ({ target }) => target.tagName === 'BUTTON' && deleteMenu(data, target.dataset.index));
이런 상황뿐만 아니라 이름을 바꿔서 import하면 여러 파일에서 불러오는 대상들의 이름이 중복되는 문제를 해결할 수도 있다는 점도 꼭 기억해 주세요!

# index.js
import { addMenu } from './add.js';
// 여기에 코드를 작성하세요
import { deleteMenuByIndex as deleteMenu } from './delete.js';

const data = [];
const addBtn = document.querySelector('.add-btn');
const addInput = document.querySelector('.add-input');
const list = document.querySelector('.list');

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));
list.addEventListener('click', ({ target }) => target.tagName === 'BUTTON' && deleteMenu(data, target.dataset.index));


# delete.js
const list = document.querySelector('.list');

function reloadMenu(data) {
  list.innerHTML = '';

  data.forEach((title, index) => {
    const li = document.createElement('li');
    li.classList.add('item');
    li.innerHTML = `<b>${index + 1}</b>${title}<button class="del-btn" data-index="${index}">x</button>`;
    list.append(li);
  });
}

export function deleteMenuByIndex(data, index) {
  data.splice(index, 1);
  reloadMenu(data);
};


# 한꺼번에 다루기
# *를 이용해서 한번에 전부 이름을 바꿀수 있다. // 와일드카드 문자(Wildcard Character)
import * as printerJS from './printer.js';
import {
  title as membersTitle,
  data as membersData
} form '/members.js';

console.log(printersJS.title);
printerJS.print(membersTitle);
printerJS.print(membersData);


# export { title, print };  // 묶여서 여러개 익스포트 가능
# export { title as printerTitle, print };   // 이름을 미리 변경하고 익스포트 가능



# 태그 정리하기
# 해설
변수나 함수 앞에 매번 export 키워드를 붙일 수도 있지만, 선언된 변수나 함수를 하나의 객체로 모아 한꺼번에 내보낼 수도 있습니다. tags.js에서 모든 변수를 한 번에 모아서 export한다면 다음과 같이 코드를 작성할 수 있는데요.

# tag.js

const addBtn = document.querySelector('.add-btn');
const addInput = document.querySelector('.add-input');
const list = document.querySelector('.list');

// 여기에 코드를 작성하세요
export { addBtn, addInput, list };
이때 as 키워드를 활용하면 이름을 변경해서 export할 수도 있다는 점도 꼭 기억해 주세요!
그리고 이렇게 export된 값들을 각 파일에서 import해주어야 프로그램이 잘 동작하겠죠?

# index.js

import { addMenu } from './add.js';
import { deleteMenu } from './delete.js';
// addBtn, addInput, list 를 import해 주세요
import { addBtn, addInput, list } from './tags.js';

const data = [];

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));
list.addEventListener('click', ({ target }) => target.tagName === 'BUTTON' && deleteMenu(data, target.dataset.index));


# add.js

// addInput, list를 import해 주세요
import { addInput, list } from './tags.js';

function add(data) {
  const inputValue = addInput.value;
  const index = data.length;

  const li = document.createElement('li');
  li.classList.add('item');
  li.innerHTML = `<b>${index + 1}</b>${inputValue}<button class="del-btn" data-index="${index}">x</div>`;
  list.append(li);

  data.push(inputValue);

  addInput.value = '';
  addInput.focus();
}

function emptyAlert() {
  alert('고민되는 메뉴를 입력해 주세요.');
  addInput.focus();
}

function maxAlert() {
  alert('메뉴는 최대 5개까지만 고민할 수 있습니다.');
  addInput.value = '';
}

export function addMenu(data) {
  const inputValue = addInput.value;

  if (inputValue === '') {
    emptyAlert();
  } else if (data.length > 4) {
    maxAlert();
  } else {
    add(data);
  }
};

# delete.js

// list를 import해 주세요
import { list } from './tags.js';

function reloadMenu(data) {
  list.innerHTML = '';

  data.forEach((title, index) => {
    const li = document.createElement('li');
    li.classList.add('item');
    li.innerHTML = `<b>${index + 1}</b>${title}<button class="del-btn" data-index="${index}">x</div>`;
    list.append(li);
  });
}

export function deleteMenu(data, index) {
  data.splice(index, 1);
  reloadMenu(data);
};


# default export  //한개만 export 할 수 있다.
default export title
default export 'codeit';

import {
  default as codeit,
  title as membersTitle,
  data as membersData
} from './delete.js';

// 디폴트 값을 밖으로 빼낼수 있다.
import codeit, {
  title as membersTitle,
  data as membersData
} from './delete.js';


export default { title, print };
//{ title: title, print: print }; 라고 볼 수 있다.



# 간결하게 기능 붙이기
# 해설
export를 할 때 default 키워드를 함께 사용하면 모듈 파일에서 기본적으로 export할 대상을 정할 수 있습니다.
이 default 키워드를 함께 활용하면, 축약형 문법으로 import를 할 수 있어서, 일반적으로 모듈 파일에서 export 대상이 하나라면, default export를 하는 것이 조금 더 간결한 코드를 구성하는 데 도움이 됩니다.

add.js, delete.js, roll.js에서 export하는 대상이 모두 하나의 함수이기 때문에 다음과 같이 코드를 작성할 수 있습니다.


# add.js

import { addInput, list } from './tags.js';

function add(data) {
  const inputValue = addInput.value;
  const index = data.length;

  const li = document.createElement('li');
  li.classList.add('item');
  li.innerHTML = `<b>${index + 1}</b>${inputValue}<button class="del-btn" data-index="${index}">x</div>`;
  list.append(li);

  data.push(inputValue);

  addInput.value = '';
  addInput.focus();
}

function emptyAlert() {
  alert('고민되는 메뉴를 입력해 주세요.');
  addInput.focus();
}

function maxAlert() {
  alert('메뉴는 최대 5개까지만 고민할 수 있습니다.');
  addInput.value = '';
}

function addMenu(data) {
  const inputValue = addInput.value;
  if (inputValue === '') {
    emptyAlert();
  } else if (data.length > 4) {
    maxAlert();
  } else {
    add(data);
  }
}

// 여기에 코드를 작성하세요
export default addMenu;


# delete.js

import { list } from './tags.js';

function reloadMenu(data) {
  list.innerHTML = '';

  data.forEach((title, index) => {
    const li = document.createElement('li');
    li.classList.add('item');
    li.innerHTML = `<b>${index + 1}</b>${title}<button class="del-btn" data-index="${index}">x</div>`;
    list.append(li);
  });
}

function deleteMenu(data, index) {
  data.splice(index, 1);
  reloadMenu(data);
}

// 여기에 코드를 작성하세요
export default deleteMenu;


# roll.js

import { addInput, list, rollBtn } from './tags.js';

function selectMenu(data) {
  list.classList.remove('rolling');
  list.innerHTML = '';

  const selectedIndex = (Math.floor(Math.random() * data.length));

  const li = document.createElement('li');
  li.classList.add('item', 'selected');
  li.innerHTML = `<b>${selectedIndex + 1}</b>${data[selectedIndex]}`;
  list.append(li);

  rollBtn.textContent = 'Clear';
}

function minAlert() {
  alert('최소 1개 이상의 메뉴를 입력해 주세요.');
  addInput.focus();
}

function clearMenu(data) {
  data.splice(0);
  list.innerHTML = '';
  rollBtn.textContent = 'Roll';
}

function rollMenu(data) {
  if (data.length === 0) {
    minAlert();
  } else if (rollBtn.textContent === 'Clear') {
    clearMenu(data);
  } else {
    list.classList.add('rolling');
    setTimeout(() => selectMenu(data), 1200);
  }
}

// 여기에 코드를 작성하세요
export default rollMenu;
그리고 이렇게 default export한 각 함수는 index.js에서 다음과 같이 import할 수 있습니다.

# index.js

import { addBtn, addInput, list, rollBtn } from './tags.js';
// default export 된 각 함수들을 import해 주세요
import addMenu from './add.js';
import deleteMenu from './delete.js';
import rollMenu from './roll.js';

const data = [];

addBtn.addEventListener('click', () => addMenu(data));
addInput.addEventListener('keypress', (e) => e.code === 'Enter' && addMenu(data));
list.addEventListener('click', ({ target }) => target.tagName === 'BUTTON' && deleteMenu(data, target.dataset.index));
rollBtn.addEventListener('click', () => list.classList.contains('rolling') || rollMenu(data));


# 복습과 활용

그동안 배운 문법만 되돌아봐도 모듈 문법은 정말 다양한 방식으로 작성될 수가 있습니다.
export를 할 때도 선언문을 export하거나

export const title = 'Module';
선언된 변수나 함수를 코드 블록으로 묶어서 export할 수도 있고,

const printer = (value) => {
  console.log(value);
};

const arrPrinter = (arr) => {
  arr.forEach((el, i) => {
    console.log(`${i + 1}. ${el}`);
  })
};

export { printer, arrPrinter };
때로는 as 키워드를 통해 이름을 변경해서 export를 할 수도 있었죠?

const printer = (value) => {
  console.log(value);
};

const arrPrinter = (arr) => {
  arr.forEach((el, i) => {
    console.log(`${i + 1}. ${el}`);
  })
};

export { printer as namedPrinter, arrPrinter };
그리고 default 키워드를 통해 표현식을 export하는 방법도 배우면서,

const title = 'Module';

export default title;
위 코드 처럼 단순히 하나의 대상을 export하는 것뿐만 아니라 아래 코드처럼 여러 대상을 객체 값으로 모아 내보내는 방식도 가능하다는 것도 배웠습니다.

const title = 'Module';

const printer = (value) => {
  console.log(value);
};

const arrPrinter = (arr) => {
  arr.forEach((el, i) => {
    console.log(`${i + 1}. ${el}`);
  })
};

export default { title, printer, arrPrinter };
그리고 import도 import 키워드 이후에 중괄호를 감싸면, 아래 코드 처럼 모듈 파일에서 export하는 항목들을 선택적으로 불러올 수 있고

import { title, data } from './modules.js';
as 키워드를 통해서 아래 코드 처럼 이름을 바꿀 수도 있었죠?

import { title as moduleTitle, data } from './modules.js';
뿐만 아니라 와일드카드 문자(*)를 통해서 아리 코드 처럼 export된 항목들을 모두 불러올 수도 있었습니다.

import * as modules from './modules.js';
그리고 아래 코드 처럼 default export된 대상을 import할 때는

import { defult as modules } from './modules.js';
아래 처럼 축약형으로 불러올 수 있다는 부분도 살펴봤었습니다.

import modules from './modules.js';
심지어 이러한 방식들을 잘 응용하면,

// (modules.js)
import module1 from './sub-module1.js';
import module2 from './sub-module2.js';
import module3 from './sub-module3.js';

export { module1, module2, module3 };
// index.js
import { module1, module2, module3 } from 'modules.js';
위 코드들 처럼 여러 개의 기능으로 잘게 나누어진 모듈을 import한 다음 다시 export하는 모듈 파일을 만들 수 있는데요. 비슷한 특징을 가진 여러 모듈 파일들을 다시 하나의 모듈 파일로 만들 수 있어서 파일 관리를 유용하게 할 수 있도록 도와줍니다.

모듈 문법은 나중에 여러분들이 자바스크립트를 기반으로 한 라이브러리나 프레임워크를 사용할 때 꼭 필요할 정도로 정말 많이 활용되기 때문에 다양한 상황들을 경험해보고 어떤 방식으로 풀어나갈지 고민하는 것이 중요한데요.

행여나 자바스크립트 코드만 다룬다고 하더라도 조금 더 효율적인 코드 작성을 위해서도 굉장히 중요한 부분이기 때문에 처음에는 다양한 표현방식 가능하다는 점이 꽤 혼란스러울 수도 있지만, 여러 번 복습을 통해서라도 잘 이해해 두시는 걸 권장해 드립니다!


## 종합 정리

# 모듈
모듈은 간단하게, 자바스크립트 파일 하나라고 할 수 있습니다.
복잡하고 많은 양의 코드를 기능에 따라 각각의 파일로 나눠 관리하면

코드를 좀 더 효율적으로 관리할 수 있고,
비슷한 기능이 필요할 때 다른 프로그램에서 재사용 할 수도 있다는 장점이 있습니다.

# 모듈 스코프
모듈 파일 안에서 선언한 변수는 외부에서 자유롭게 접근할 수 없도록 막아야 하는데요.
다시 말해 모듈은 파일 안에서 모듈 파일만의 독립적인 스코프를 가지고 있어야 합니다.

HTML파일에서 자바스크립트 파일을 불러올 때 모듈 스코프를 갖게 하려면
script태그에 type속성을 module이라는 값으로 지정해 주어야 합니다.

<body>
  <script type="module" src="index.js"></script>
</body>
모듈 문법
자바스크립트의 모듈 문법은 기본적으로 export와 import 입니다.
모듈 스코프를 가진 파일에서 외부로 내보내고자 하는 변수나 함수를 export 키워드를 통해 내보내고,
모듈 파일에서 내보낸 변수나 함수들은 다른 파일에서 import 키워드를 통해 가져옵니다.

// printer.js
export const title = 'CodeitPrinter';

export function print(value) {
  console.log(value);
};
// index.js
import { title, print } from './printer.js';

print(title);


# 이름 바꿔 import 하기
import 키워드를 통해 모듈을 불러올 때 as 키워드를 활용하면 import하는 대상들의 이름을 변경할 수 있습니다.
import 할 변수나 함수 이름을 조금 더 간결한 이름으로 바꾸거나, 혹은 더 구체적으로 바꾸고 싶을 때 활용하면 좋겠죠?
뿐만 아니라 이름을 바꿔서 import 하면 여러 파일에서 불러오는 대상들의 이름이 중복되는 문제를 해결할 수도 있습니다.

import { title as printerTitle, print, printArr } from './printer.js';
import { title, data as members } from './members.js';

printer(title);
arrPrinter(members);

# 한꺼번에 import 하기
import할 때 와일드카드 문자(*)와 as를 활용하면 모듈 파일에서 export하는 모든 대상을 하나의 객체로 불러올 수 있습니다.

import * as printerJS from './printer.js';

console.log(printerJS.title); // CodeitPrinter
console.log(printerJS.print); // ƒ print(value) { console.log(value); }

# 한꺼번에 export 하기
변수나 함수 앞에 매번 export 키워드를 붙일 수도 있지만, 선언된 변수나 함수를 하나의 객체로 모아 한꺼번에 내보낼 수도 있습니다.
이때 as 키워드를 활용하면 이름을 변경해서 export할 수도 있습니다.

const title = 'CodeitPrinter';

function print(value) {
  console.log(value);
}

function printArr(arr) {
  arr.forEach((el, i) => {
    console.log(`${i + 1}. ${el}`);
  });
}

export { title as printerTitle, print, printArr };


# default export
export를 할 때 default 키워드를 함께 사용하면 모듈 파일에서 기본적으로 export할 대상을 정할 수 있습니다.
일반적으로 모듈 파일에서 export 대상이 하나라면, 이 default 키워드를 함께 활용하는 것이 조금 더 간결한 코드를 구성하는데 도움이 되는데요.

const title = 'CodeitPrinter';

function print(value) {
  console.log(value);
}

export default print;
default export는 import할 때 기본적으로 다음과 같이 불러올 수 있지만,

import { default as printerJS } from './printer.js';

console.log(printerJS.title); // CodeitPrinter
console.log(printerJS.print); // ƒ print(value) { console.log(value); }
다음과 같이 축약형 문법으로 import 할 수도 있기 때문입니다.

import printerJS from './printer.js';

console.log(printerJS.title); // CodeitPrinter
console.log(printerJS.print); // ƒ print(value) { console.log(value); }



# css 선택자로 태그 선택하기
const myTag = document.querySelector('#myNumber');
console.log(myTag);

const myTag = document.querySelector('.color-btn');
console.log(myTag);

const myTags = document.querySelectorAll('.color-btn');
console.log(myTags);

const myTags2 = document.getElementsByClassName('.color-btn');
console.log(myTags2);


# 이벤트와 버튼 클릭

const btn = document.querySelector('#myBtn');

//이벤트 핸들링(Event Handling)
btn.onclick = function () {
  console.log('Hello Codeit!');
}

# 태그 선택 방법을 활용해서 button 태그를 선택해보면 이렇게 다양하게 선택할 수 있죠?
document.querySelector('#grade');
document.querySelector('button');
document.querySelectorAll('button')[0];
document.getElementsByTagName('button')[0];


# 인터랙티브 자바스크립트 종합 정리

# 자바스크립트로 태그 선택하기
document.getElementById('id')	//HTML id속성으로 태그 선택하기	//id에 해당하는 태그 하나
document.getElementsByClassName('class')	//HTML class속성으로 태그 선택하기	//class에 해당하는 태그 모음(HTMLCollection)
document.getElementsByTagName('tag')	//HTML 태그 이름으로 태그 선택하기	//tag에 해당하는 태그 모음(HTMLCollection)
document.querySelector('css')	//css 선택자로 태그 선택하기	//css 선택자에 해당하는 태그 중 가장 첫번째 태그 하나
document.querySelectorAll('css')	//css 선택자로 태그 선택하기	//css 선택자에 해당하는 태그 모음(NodeList)

# 유사 배열이란?
배열과 유사한 객체 ex) HTMLCollection, NodeList, DOMTokenList, ...

#특징
숫자 형태의 indexing이 가능하다.
length 프로퍼티가 있다.
배열의 기본 메소드를 사용할 수 없다.
Array.isArray(유사배열)의 리턴값은 false다.

# 이벤트와 이벤트 핸들링, 그리고 이벤트 핸들러
이벤트 : 웹 페이지에서 발생하는 대부분의 일(사건)들
  ex) 버튼 클릭, 스크롤, 키보드 입력, ...

이벤트 핸들링 : 자바스크립트를 통해 이벤트를 다루는 일

이벤트 핸들러 : 이벤트가 발생했을 때 일어나야하는 구체적인 동작들을 표현한 코드. 이벤트 리스너(Event Listener)라고도 부른다.

# 이벤트 핸들러를 등록하는 2가지 방법
4-1. 자바스크립트로 해당 DOM 객체의 onclick 프로퍼티에 등록하기
const btn = document.querySelector('#myBtn');

btn.onclick = function() {
  console.log('Hello Codeit!');
};
4-2. HTML 태그의 onclick 속성에 바로 표시하기
<button id="myBtn" onclick="console.log('Hello Codeit!')">클릭!</button>

# VSC 단축키
ctrl + D : 선택한 것과 동일한 것들을 차례로 선택 가능하다.
alt + 클릭 : 커서 위치마다 클릭해서 여러개의 커서를 생성해서 동시 작성이 가능하다.
alt + up & down : 한줄씩 위아래로 이동이 가능하다.
alt + shift + up & down : 복사해서 위아래에 생성한다.
ctrl + / : 선택 영역 전체를 코멘트로 변경이 가능하다.
alt + shift + I : 마우스 드레그 이후 전체에 마우스 커서를 생성할 수 있다.
alt + shift + 드레그 : 마우스 커서 위치에서 다른 구간 마우스 커서 생성// 드레그 혹은 클릭
ctrl + home & down : 마우스를 최상위 또는 최하위로 이동 가능.


# 브라우저도 객체다?
// window
console.log(window);
console.log(window.innerWidth);
console.log(window.innerHeight);
window.console.log();

window.close();
window.open();


# DOM (Docment Object Model) 문서 객체 모델
console.log(typeof document);

const title = document.querySelector('#title');

title.style.color = 'red';


# console.dir?
대부분의 브라우저에 있는 개발자 도구는 console.log와 console.dir메소드를 지원합니다.
두 메소드 모두 파라미터로 전달받은 값을 콘솔에 출력하는 역할을 합니다. 과연 이 둘은 어떤 차이가 있을까요?

const str = 'Codeit';
const num = 123;
const bool = true;
const arr = [1, 2, 3];
const obj = {
  name: 'Codeit',
  email: 'codeit@codeit.kr',
};

function func() {
  console.log('I love Codeit!');
}

console.log('--- str ---');
console.log(str);
console.dir(str);
console.log('--- num ---');
console.log(num);
console.dir(num);
console.log('--- bool ---');
console.log(bool);
console.dir(bool);
console.log('--- arr ---');
console.log(arr);
console.dir(arr);
console.log('--- obj ---');
console.log(obj);
console.dir(obj);
console.log('--- func ---');
console.log(func);
console.dir(func);
console.dir?-1

이렇게 다양한 유형의 값들을 만들어서 출력 결과를 놓고서 천천히 비교해봅시다.

1. 출력하는 자료형이 다르다.
console.dir?-2

먼저 문자열, 숫자, 불린 부분을 봅시다.
각 값을 출력할 때 두 번째 dir 부분에서 출력되는 값의 색이 다른 게 보이시나요? dir 메소드는 문자열 표시 형식으로 콘솔에 출력합니다.

2. log는 값 자체에, dir은 객체의 속성에!
console.dir?-3

log 메소드는 파라미터로 전달받은 값을 위주로 출력하는 반면, dir 메소드는 객체의 속성을 좀 더 자세하게 출력합니다.

dir 메소드가 출력한 부분을 자세히 보면 객체의 유형이 먼저 출력되고, 특히 함수 부분에서는 클릭해서 펼쳤을 때 함수가 가진 속성들을 더 보여주는 모습을 확인할 수 있습니다. (log 메소드는 펼쳐지지 않음)

3. log는 여러 개, dir은 하나만!
console.log(str, num, bool, arr, obj, func);
console.dir(str, num, bool, arr, obj, func);
console.dir?-4

둘 사이의 차이는 파라미터로 전달할 수 있는 값의 개수에도 있는데요.
log 메소드는 여러 값을 쉼표로 구분해서 전달하면 전달받은 모든 값을 출력하는 반면, dir 메소드는 여러 값을 전달하더라도 첫 번째 값만 출력합니다.

4. DOM 객체를 다룰 때..
const myDOM = document.body;

console.log(myDOM);
console.dir(myDOM);
console.dir?-5

지난 시간에도 확인했듯 log와 dir 메소드의 가장 큰 차이는 DOM 객체를 다룰 때 나타납니다.
값에 좀 더 중점을 둔 log 메소드는 대상을 HTML 형태로 출력하고, 객체의 속성에 좀 더 중점을 둔 dir 메소드는 대상을 객체 형태로 출력합니다.

# 마무리
지금까지 console 객체의 log 메소드와 dir 메소드의 차이점에 대해 살펴봤는데요.
콘솔에서 값 자체를 확인하고 싶다면 log메소드를, 객체의 속성들을 살펴보고 싶다면 dir 메소드를 활용하면 좋을 것 같습니다.


# DOM 트리 접근 방법

// 자식 요소 노드
console.log(myTag.children[1]);
console.log(myTag.firstElementChild);
console.log(myTag.lastElementChild);

// 부모 요소 노드
console.log(myTag.parentElement);

// 형제 요소 노드
console.log(myTag.previousElementSibling);
console.log(myTag.nextElementSibling);

// 부모 형제 노드
console.log(myTag.parentElement.nextElementSibling);


# 요소 노드에 대한 이동 프로퍼티
프로퍼티	유형	결과
element.children	자식 요소 노드	element의 자식 요소 모음(HTMLCollection)
element.firstElementChild	자식 요소 노드	element의 첫 번째 자식 요소 하나
element.lastElementChild	자식 요소 노드	element의 마지막 자식 요소 하나
element.parentElement	부모 요소 노드	element의 부모 요소 하나
element.previousElementSibling	형제 요소 노드	element의 이전(previous) 혹은 좌측(left)에 있는 요소 하나
element.nextElementSibling	형제 요소 노드	element의 다음(next) 혹은 우측(right)에 있는 요소 하나
배웠던 그대로 이 프로퍼티들은 노드 중에서도 '요소 노드'인 경우에만 존재하는 프로퍼티들입니다.
그럼 요소 노드 말고 텍스트 노드에 접근하고 싶을 땐 어떻게 해야 할까요?

# 모든 노드에 대한 이동 프로퍼티
만약 요소 노드가 아닌 다른 노드들을 이동하고 싶은 경우에는 아래와 같은 프로퍼티를 활용할 수도 있습니다.

프로퍼티	유형	결과
node.childNodes	자식 노드	node의 자식 노드 모음(NodeList)
node.firstChild	자식 노드	node의 첫 번째 자식 노드 하나
node.lastChild	자식 노드	node의 마지막 자식 노드 하나
node.parentNode	부모 노드	node의 부모 요소 하나
node.previousSibling	형제 노드	node의 이전(previous) 혹은 좌측(left)에 있는 노드 하나
node.nextSibling	형제 노드	node의 다음(next) 혹은 우측(right)에 있는 노드 하나
대부분 요소 노드의 프로퍼티 이름에서 Element라는 단어만 빠진 것 같은데요.
사실 모든 노드가 공통적으로 갖고있는 이 프로퍼티들은 특별한 경우를 제외하면 자주 사용되진 않습니다.

그 이유는 DOM 트리가 만들어질 때 생겨나는 노드들을 좀 더 자세히 살펴보면 알 수 있는데요.

# DOM 트리를 구성할 때..
브라우저가 HTML 코드를 해석할 때 각 코드들은 상황에 맞게 node를 생성하고 DOM 트리를 구성하는데,

HTML 태그는 요소 노드가 되고, 
문자들은 텍스트 노드,
그리고 주석도 주석 노드로 DOM 트리에 반영됩니다.

<!DOCTYPE HTML>
<html>
<head>
  <title>JavaScript</title>
</head>
<body>
  I Love JavaScript
  <!-- I Love Codeit -->
</body>
</html>
예를 들어 이런 코드는 아래와 같이 DOM 트리를 구성하게 되는데요.

# DOM트리여행하기

그런데 텍스트 노드 중에서 붉은 테두리가 있는 부분을 통해 알 수 있듯 태그와 태그사이에 줄 바꿈과 들여쓰기로 인한 띄어쓰기도 텍스트 노드(Text라고 표시된 부분)로 생성된 모습을 확인할 수 있습니다.

지금 예시는 간단하기 때문에 어느 정도 DOM 트리를 예상할 수 있지만, 조금만 더 코드가 복잡하거나 혹은 코드의 스타일이 일정하지 않은 경우에는 이런 줄 바꿈과 들여쓰기로 인해 생성된 텍스트 노드의 존재를 파악하기가 쉽지 않을 수 있습니다.

그래서 방금 본, 모든 노드가 공통으로 갖고 있는 프로퍼티를 활용한다면, 예상치 못한 텍스트 노드를 선택하게 되어 의도하지 않은 결과를 만들어 낼 가능성이 커지게 됩니다.

일반적으로 우리가 다루고자 하는 대상은 태그!
자바스크립트로 웹 문서를 다룰 때는 아무래도 텍스트 노드보다는 요소  노드를 다룰 경우가 더 많을 겁니다.
만약 여러분이 의도하는 대상이 HTML 태그라면 요소 노드에 대한 이동 프로퍼티를 활용하는 것이 훨씬 더 안전하겠죠?

그래도 상황에 따라서는 요소 노드가 아닌 노드들을 이동시켜야할 수도 있으니 모든 노드가 공통으로 갖고 있는 속성들도 잘 기억해주세요.



# DOM 트리 이동
doneList.parentElement.firstElementChild.nextElementSibling.children[3];
2
doneList.lastElementChild.parentElement.children[3];
doingList.children[2].nextElementSibling;
doingList.parentElement.children[1].children[3];

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>새로운 코딩 교육의 시작</title>
</head>
<body>
  <h2>진행 중인 토픽</h2>
  <ul id="doing-list">
    <li>인터랙티브 자바스크립트</li>
    <li>프로그래밍 언어 이해하기</li>
    <li>프로그래머의 세계 이해하기</li>
    <li>소프트웨어 이해하기</li>
  </ul>
  <h2>완료 한 토픽</h2>
  <ul id="done-list">
    <li>프로그래밍 시작하기 in JavaScript</li>
    <li>프로그래밍 핵심 개념 in JavaScript</li>
    <li>프로그래밍과 데이터 in JavaScript</li>
    <li>HTML/CSS 시작하기</li>
    <li>HTML/CSS 핵심 개념</li>
    <li>반응형 웹 퍼블리싱</li>
  </ul>
  <script src="index.js"></script>
</body>
</html>


# 요소 노드 프로퍼티

const myTag = document.querySelector('#List-1');

# innerHTML
console.log(myTag.innerHTML);
myTag.innerHTML = '<li>Exotic</li>';  //수정할 때 많이 사용함. // #List-1 전체 내용을 <li>Exotic</li> 로 수정함.
myTag.innerHTML += '<li>Exotic</li>';  //마지막에 추가 할수도 있음.


# outerHTML
console.log(myTag.outerHTML); //innerHTML보다 바깥쪽 부모 노드까지 포함한다.

console.log(myTag.outerHTML);
myTag.outerHTML = '<ul id="new-liost"><li>Exotic</li></ul>';  // 기존의 내용을 삭제하고 대체 된다.

# textContent
console.log(myTag.textContent);  // HTML을 제외하고 텍스트만 가져온다.
myTag.textContent = 'New text!';  // HTML 특수 문자를 입력해도 일반 텍스트로 출력한다. "<li>New text!</li>"


# inner/outerHTML, textContent 비교
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>JS with Codeit</title>
</head>
<body>
  <div id="content">
    <h2 id="title-1">Cat-1</h1>
    <ul id="list-1">
      <li>Ragdoll</li>
      <li>British Shorthair</li>
      <li>Scottish Fold</li>
      <li>Bengal</li>
      <li>Siamese</li>
      <li>Maine Coon</li>
      <li>American Shorthair</li>
      <li>Russian Blue</li>
    </ul>
    <h2 id="title-2">Cat-2</h1>
    <ul id="list-2">
      <li>Sphynx</li>
      <li>Munchkin</li>
      <li>Persian</li>
      <li>Norwegian Forset</li>
      <li>Turkish Angora</li>
      <li>Bombay</li>
      <li>Selkirk Rex</li>
      <li>Munchkin</li>
    </ul>
  </div>
  <script src="index.js"></script>
</body>
</html>
1. element.innerHTML
요소 노드 내부의 HTML 코드를 문자열로 리턴해 줍니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
const myTag = document.querySelector('#list-1');

// innerHTML
console.log(myTag.innerHTML);
innerHTMLouterHTMLtextContent

요소 안의 정보를 확인할 수도 있지만, 내부의 HTML 자체를 수정할 때 좀 더 자주 활용됩니다. (내부에 있던 값을 완전히 새로운 값으로 교체하기 때문에 주의해서 사용해야해요!)
const myTag = document.querySelector('#list-1');

// innerHTML
console.log(myTag.innerHTML);
myTag.innerHTML = '<li>Exotic</li>';
console.log(myTag.innerHTML);
innerHTMLouterHTMLtextContent-2

2. element.outerHTML
요소 노드 자체의 전체적인 HTML 코드를 문자열로 리턴해줍니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
const myTag = document.querySelector('#list-1');

// outerHTML
console.log(myTag.outerHTML);
innerHTMLouterHTMLtextContent-3

outerHTML은 새로운 값을 할당할 경우 요소 자체가 교체되어 버리기 때문에 주의해야 합니다.
const myTag = document.querySelector('#list-1');

// outerHTML
console.log(myTag.outerHTML);
myTag.outerHTML = '<ul id="new-list"><li>Exotic</li></ul>';
innerHTMLouterHTMLtextContent-4

3. element.textContent
요소 안의 내용들 중에서 HTML 태그 부분은 제외하고 텍스트만 가져옵니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
const myTag = document.querySelector('#list-1');

// textContext
console.log(myTag.textContent);
innerHTMLouterHTMLtextContent-5

새로운 값을 할당하면 innerHTML과 마찬가지로 내부의 값을 완전히 새로운 값으로 교체 합니다.
const myTag = document.querySelector('#list-1');

// textContext
console.log(myTag.textContent);
myTag.textContent = 'new text!';
innerHTMLouterHTMLtextContent-6

하지만 textContent는 말그대로 텍스트만 다루기 때문에, 특수문자도 그냥 텍스트로 처리한다는 점, 꼭 기억해주세요!
const myTag = document.querySelector('#list-1');

// textContext
console.log(myTag.textContent);
myTag.textContent = '<li>new text!</li>';


# innerHTML은 해당 요소 내부의 HTML 태그를 문자열로 리턴해 주는 프로퍼티입니다.
그리고 innerHTML은 요소 내부의 HTML 태그들끼리의 줄바꿈이나, 들여쓰기, 띄어쓰기가 있을 때 
그런 부분들도 모두 포함한다는 점을 꼭 기억해 두세요!


문제에 제시된 코드를 보면, <ul id="done-list">...</ul>을 선택한 다음 textContent에 HTML 태그와 같은 문자열을 새롭게 할당하고,textContent 프로퍼티를 콘솔에 출력하고 있는데요.

textContent은 해당 요소 내부의 HTML 태그를 제외한 문자열만 리턴해 주는 프로퍼티입니다.

textContent는 새로운 값을 할당할 수도 있는데요. 그러면 해당 값으로 요소 안의 내용이 완전히 수정되어 버립니다.

그런데 한 가지 주의해야 할 부분은 textContent는 말그대로 텍스트만 다루는 프로퍼티라서 만약 HTML 코드처럼 보이는 값으로 수정하더라도,
HTML이 아니라 일반 텍스트처럼 반영이 됩니다.

그래서 결과적으로 li태그 처럼 보이는 부분도 태그가 아닌 일반 텍스트로 처리 되기 때문에 콘솔에 textContent값을 출력해보면
새롭게 할당한 문자열이 그대로 출력됩니다.

<li>인터랙티브 자바스크립트</li>


textContent은 해당 요소 내부의 HTML 태그를 제외한 문자열만 리턴해 주는 프로퍼티입니다.
innerHTML과 마찬가지로 요소 내부의 태그들끼리의 줄 바꿈이나, 들여쓰기, 띄어쓰기가 있을 때 그런 부분들도 모두 포함합니다.

그리고 textContent과 innerHTML은 모두 새로운 값을 할당할 수 있습니다.
그러면 해당 값으로 요소 안의 내용이 완전히 수정되어 버리는데요.

특히, textContent는 말그대로 텍스트만 다루는 프로퍼티라서 만약 HTML 코드처럼 보이는 값으로 수정하더라도, HTML이 아니라 일반 텍스트처럼 반영이 된다는 점을 꼭 기억해 주세요!


# 요소 노드 추가하기
const tomorrow = docment.querySelector('#tomorrow');

# 1. 요소 노드 만들기 :docment.createElement('태그이름')
const first = docment.createElement('li');

# 2. 요소 노드 꾸미기 : textContent, innerHTML, ...
first.textContent = '처음';

# 3. 요소 노드 추가하기: NODE.prepend, append, after, before
tomorrow.prepend(first);

const last = docment.createElement('li');
last.textContent = '마지막';
tomorrow.append(last);

const prev = docment.createElement('p');
prev.textContent = '이전';
tomorrow.before('문자열');

const next = docment.createElement('p');
next.textContent = '다음';
tomorrow.after(next);


# 노드 삭제와 이동하기

# 노드 삭제하기
tomorrow.remove();
today.children[2].remove();

# 노드 이동하기  // NODE.prepend, append, after, before
today.append(tomorrow.children[1]); //tomorrow의 2번째 내용이 today 마지막 자식 요소로 이동 시킨다.
// today <- tomorrow

tomorrow.children[1].after(today.children[1]); // today의 2번째 내용이 tomorrow의 2번째 자식 요소 다음으로 이동한다.
// today -> tomorrow

tomorrow.children[2].before(today.children[1]); 
tomorrow.lastElementChild.before(today.children[1]); 


# 실습 설명
언제나 시간을 계획적으로 관리하는 부지런한 지용이는 매일 아침마다 오늘 꼭 해야할 일들을 기록하는 습관이 있습니다.
최근 자바스크립트를 배운 지용이는 할 일을 기록하는 프로그램을 만들어 보려 하는데요.

가장 기본적으로 HTML 코드는 의도한 대로 작성한 것 같은데, 자바스크립트로 할 일을 추가하는 기능은 어떻게 구현해야 할지 갈피를 못 잡고 있습니다.

지용이는 본인이 작성한 <ul id="to-do-list"></ul> 태그 안에 li 태그로 오늘 할 일들을 추가하고 싶어합니다.

어려워하는 지용이를 위해서 아래 내용을 만족하는addNewTodo함수를 완성해 주세요.

li 태그이름을 가진 요소 노드를 만든다.
그 요소 노드에 파라미터로 전달받은 오늘 할 일(text)을 담는다.
<ul id="to-do-list"></ul>태그의 마지막 자식 요소 노드로 추가한다.
코드를 잘 작성하셨다면 아래와 같은 결과가 웹 페이지에 나타나야 합니다.


# 해설
간단하게 생각하면 li 태그로 만든 요소 노드를 꾸며서, toDoList의 마지막 자식 요소로 추가하는 과제입니다.

그럼 천천히 단계별로 코드를 작성해 봅시다.

가장 먼저 li 태그를 만들어야 하니깐, document 객체의 createElement 메소드를 활용해서 파라미터에 문자열로 li를 전달하면 되겠죠?

function addNewTodo(text) {
  const li = document.createElement("li");
}
그 다음은 파라미터로 전달받은 text를 li 태그 안에 넣어주는 건데요.
이건 innerHTML이나 textContent프로퍼티에 text 값을 할당해 주면 간단하게 해결할 수 있습니다.
어떤 프로퍼티를 활용해도 상관없지만, 보통 이런 할 일들은 일반 텍스트가 전달되니깐 textContent 프로퍼티를 사용해서 코드를 작성해보면 다음과 같이 작성할 수 있습니다.

function addNewTodo(text) {
  const li = document.createElement("li");
  li.textContent = text;
}
그리고 마지막으로는 이 li태그를 toDoList에 추가하면 됩니다.
문제에서는 toDoList의 마지막 자식 요소로 추가하라고 했으니, append 메소드를 사용해서 코드를 작성해 보면 아래와 같이 작성할 수 있습니다.

# 모범 답안
const toDoList = document.querySelector('#to-do-list');

function addNewTodo(text) {
  const li = document.createElement("li");
  li.textContent = text;
  toDoList.append(li);
}

// 테스트 코드
addNewTodo('자바스크립트 공부하기');
addNewTodo('고양이 화장실 청소하기');
addNewTodo('고양이 장난감 쇼핑하기');


# HTML 속성 (HTML attribute)
const tomorrow = document. querySelector('#tomorrow');
const item = tomorrow. firstElementChild;
const link = item. firstElementChild;

# elem.getAttribute('속성'): 속성에 접근하기
console.log(tomorrow.getAttribute('href'));
console.log(item.getAttribute('class'));

# elem.setAttribute('속성', '값'): 속성 추가(수정)하기
tomorrow.setAttribute('class', 'list'); // 추가
link.setAttribute('href', 'https://www.codeit.kr'); // 수정

# elem. removeAttribute('속성'): 속성 제거하기
tomorrow.removeAttribute('href');
tomorrow.removeAttribute('class');


# HTML 속성을 다루는 메소드는 아래와 같은 메소드들이 있습니다.

속성에 접근하기: element.getAttribute('속성')
속성 추가(수정)하기: element.setAttribute('속성', '값')
속성 제거하기: element.removeAttribute('속성')

setAttribute로 undefined 값을 지정하면, class 값이 사라지는 것이 아니라, 
class 속성 값 자체가 undefined라는 class 값으로 수정되어 버립니다.
getAttribute 메소드의 실행 결과에 새로운 값을 할당하려고 하면 
ReferenceError가 발생하니깐 이 부분도 함께 참고해 주세요!


// 스타일 다루기
const today = docment.querySelector('#today');
const tomorrow = docment.querySelector('#tomorrow');

// elem.classList: add, remove,toggle
const item = tomorrow.children[1];
item.classList.add('done', 'other');
item.classList.remove('done', 'other');

item.classList.toggle('done'); //토글 기능
item.classList.toggle('done', true); //add 기능
item.classList.toggle('done', false); //remove 기능

console.log(today.classList);
console.log(today.children[1].classList);

// elem.className
today.children[1].className = 'done';

// style 프로퍼티
today.children[0].style.textDecoration = 'line-through';
today.children[0].style.backgroundColor = '#DDDDDD';


# 비표준 속성 다루기

<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>JS with Codeit</title>
</head>

<body>
  <p>할 일 : <b field="title"></b></p>
  <p>담당자 : <b field="manager"></b></p>
  <p>상태 : <b field="status"></b></p>
  <div>
    상태 변경: 
    <button class="btn" status="대기중">대기중</button>
    <button class="btn" status="진행중">진행중</button>
    <button class="btn" status="완료">완료</button>
  </div>
  <script src="index.js"></script>
</body>

</html>

# 결과 확인
위 코드를 보시면 b 태그들의 field 속성과 button 태그들의 status 라는 속성이 보이는데요. 이 두 속성은 해당 태그의 표준 속성이 아닙니다.

그리고 혹시, 위 코드의 css 부분에서 대괄호('[')를 이용한 css 선택자를 처음 보시는 분들도 있을 것 같은데요. [속성이름]처럼 대괄호를 이용하면 대괄호 안에 있는 속성이름을 가진 태그들을 선택할 수 있고 [속성이름="값"]처럼 작성하면, 좀 더 구체적으로 속성이름에 해당 값을 가진 태그들을 선택할 수도 있습니다.

아무튼, 이런 상황에서 비표준 속성은 어떤 식으로 다룰 수 있는지 한 번 살펴봅시다.

# 비표준 속성 활용하기
# 1. 선택자로 활용
가장 간단하게는 아래와 같이 querySelector로 태그를 선택할 때 css 선택자를 활용해서 태그를 선택하는 데에 활용할 수도 있습니다.

const fields = document.querySelectorAll('[field]');
console.log(fields);
비표준속성다루기

# 2. 값을 표시할 태그를 구분할 때 활용
비표준 속성은 객체 형태의 데이터가 있을 때, 각 프로퍼티 값들이 들어갈 태그를 구분하는데 활용할 수도 있습니다.

const fields = document.querySelectorAll('[field]');
const task = {
  title: '코드 에디터 개발',
  manager: 'CastleRing, Raccoon Lee',
  status: '',
};

for (let tag of fields) {
  const field = tag.getAttribute('field');
  tag.textContent = task[field];
}
비표준속성다루기-2

# 3. 스타일이나 데이터 변경에 활용
getAttribute 메소드를 활용해서 속성값을 가져오고, setAttribute 메소드를 활용해서 속성값을 설정해주는 원리로 이벤트를 통해 실시간으로 스타일을 변경하거나 데이터를 변경하는데 활용할 수 있습니다.

때로는 class를 다루는 것보다 setAttribute로 비표준 속성을 변경하는게 스타일을 다루기에 오히려 편리한 경우도 있습니다.

const fields = document.querySelectorAll('[field]');
const task = {
  title: '코드 에디터 개발',
  manager: 'CastleRing, Raccoon Lee',
  status: '',
};

for (let tag of fields) {
  const field = tag.getAttribute('field');
  tag.textContent = task[field];
}

const btns = document.querySelectorAll('.btn');
for (let btn of btns) {
  const status = btn.getAttribute('status');
  btn.onclick = function () {
    fields[2].textContent = status;
    fields[2].setAttribute('status', status);
  };
}
비표준속성다루기-3

좀 더 안전하게, dataset 프로퍼티
다양한 방식으로 활용되는 비표준 속성에는 한 가지 문제가 있습니다.
비표준 속성을 사용해 코드를 작성했을 때 시간이 지나서 나중에 그 속성이 표준으로 등록되면 문제가 발생할 수 있다는 건데요.
HTML은 아직까지도 개발자들의 요구를 반영하기 위해 계속해서 발전하는 언어입니다. 그래서 이런 경우 예기치 못한 부작용이 발생할 수 있는 것이죠.

예를 들어서, 만약 glitter라는 비표준 속성을 만들어서 glitter 속성값이 true면 마우스를 올렸을 때 주변에 별이 반짝이는 애니메이션이 동작하도록 프로그램를 설계했다고 가정해봅시다.
그런데 갑자기 glitter라는 속성이 true일 때 태그가 계속 깜빡거리는 기능을 하는 표준으로 생겨나버리면 우리가 처음에 설계한 방식대로 동작하지 않을 수 있겠죠?

그래서 비표준 속성을 사용하기 위해 미리 약속된 방식이 존재하는데요. 바로 data-* 속성입니다.

data-로 시작하는 속성은 모두 dataset이라는 프로퍼티에 저장되는데요. 예를 들어서 data-status라는 속성이 있다면, element.dataset.status라는 프로퍼티에 접근해서 그 값을 가져올 수 있는 것이죠.

그래서 본문의 코드도 아래와 같이 고치고,


<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>JS with Codeit</title>
</head>

<body>
  <p>할 일 : <b data-field="title"></b></p>
  <p>담당자 : <b data-field="manager"></b></p>
  <p>상태 : <b data-field="status"></b></p>
  <div>
    상태 변경: 
    <button class="btn" data-status="대기중">대기중</button>
    <button class="btn" data-status="진행중">진행중</button>
    <button class="btn" data-status="완료">완료</button>
  </div>
  <script src="index.js"></script>
</body>

</html>

결과 확인
자바스크립트 코드도 다음과 같이 고쳐주면,

const fields = document.querySelectorAll('[data-field]');
const task = {
  title: '코드 에디터 개발',
  manager: 'CastleRing, Raccoon Lee',
  status: '',
};

for (let tag of fields) {
  const field = tag.dataset.field;
  tag.textContent = task[field];
}

const btns = document.querySelectorAll('.btn');
for (let btn of btns) {
  const status = btn.dataset.status;
  btn.onclick = function () {
    fields[2].textContent = status;
    fields[2].dataset.status = status;
  };
}
조금 더 안전하게 비표준 속성을 활용할 수 있습니다.

동작확인하기
아래 코드를 실행해서 상태변경 버튼을 클릭해 보세요!

<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>JS with Codeit</title>
</head>

<body>
  <p>할 일 : <b data-field="title"></b></p>
  <p>담당자 : <b data-field="manager"></b></p>
  <p>상태 : <b data-field="status"></b></p>
  <div>
    상태 변경: 
    <button class="btn" data-status="대기중">대기중</button>
    <button class="btn" data-status="진행중">진행중</button>
    <button class="btn" data-status="완료">완료</button>
  </div>
  <script>
    const fields = document.querySelectorAll('[data-field]');
    const task = {
      title: '코드 에디터 개발',
      manager: 'CastleRing, Raccoon Lee',
      status: '',
    };

    for (let tag of fields) {
      const field = tag.dataset.field;
      tag.textContent = task[field];
    }

    const btns = document.querySelectorAll('.btn');
    for (let btn of btns) {
      const status = btn.dataset.status;
      btn.onclick = function () {
        fields[2].textContent = status;
        fields[2].dataset.status = status;
      };
    }
  </script>
</body>
</html>


# 브라우저와 자바스크립트 종합 정리

# 1. window 객체
window 객체는 브라우저 창을 대변하면서 자바스크립트에서 최상단에 존재하는 객체입니다.
자바스크립트 코드 어느 곳에서나 항상 접근할 수 있는 객체이기 때문에 전역 객체, 영어로는 Global Object라고 부릅니다.
어떤 프로퍼티나 메소드를 사용하든 결국 전역 객체 내부의 것이기 때문에 앞에 window.을 생략할 수도 있습니다.

# 2. DOM
DOM이란 Document Object Model의 약자로, 한국어로는 문서 객체 모델입니다.
간단하게 표현하면 웹 페이지에 나타나는 HTML 문서 전체를 객체로 표현한 것으로 생각하면 됩니다.
이때 각 객체를 노드(Node)라는 용어로 표현하고, 태그는 요소 노드, 문자는 텍스트 노드로 구분됩니다.

# 3. DOM 트리
HTML의 계층 구조는 DOM에서도 반영되는데 이러한 계층구조를 나무에 비유해서 DOM 트리라고 부릅니다.
각 노드 간의 관계는 부모, 자식, 형제라는 용어로 표현합니다.

# 4. DOM 이동 시 활용 가능한 프로퍼티
프로퍼티	유형	결과
element.children	자식 요소 노드	element의 자식 요소 모음(HTMLCollection)
element.firstElementChild	자식 요소 노드	element의 첫 번째 자식 요소 하나
element.lastElementChild	자식 요소 노드	element의 마지막 자식 요소 하나
element.parentElement	부모 요소 노드	element의 부모 요소 하나
element.previousElementSibling	형제 요소 노드	element의 이전(previous) 혹은 좌측(left)에 있는 요소 하나
element.nextElementSibling	형제 요소 노드	element의 다음(next) 혹은 우측(right)에 있는 요소 하나
node.childNodes	자식 노드	node의 자식 노드 모음(NodeList)
node.firstChild	자식 노드	node의 첫 번째 자식 노드 하나
node.lastChild	자식 노드	node의 마지막 자식 노드 하나
node.parentNode	부모 노드	node의 부모 요소 하나
node.previousSibling	형제 노드	node의 이전(previous) 혹은 좌측(left)에 있는 노드 하나
node.nextSibling	형제 노드	node의 다음(next) 혹은 우측(right)에 있는 노드 하나

# 5. 주요 요소 노드 프로퍼티
프로퍼티	내용	참고사항
element.innerHTML	요소 노드 내부의 HTML코드 문자열로 리턴	요소 안의 정보를 확인할 수도 있지만,
내부의 HTML 자체를 수정할 때 좀 더 자주 활용
element.outerHTML	요소 노드 자체의 전체적인 HTML 코드를 문자열로 리턴	outerHTML은 새로운 값을 할당하면
요소 자체가 교체되어 버리기 때문에 주의
element.textContent	요소 노드 내부의 내용들 중에서 HTML을 제외하고 텍스트만 리턴	textContent는 말그대로 텍스트만 다루기 때문에
HTML태그를 쓰더라도 모두 텍스트로 처리됨

# 6. 요소 노드 다루기
요소 노드 만들기: document.createElement('태그이름')
요소 노드 꾸미기: element.textContent, element.innerHTML, ...
요소 노드 추가 혹은 이동하기: element.prepend, element.append, element.after, element.before
요소 노드 삭제하기: element.remove()

# 7. HTML 속성 다루기
대부분의 HTML 속성은 DOM 객체의 프로퍼티로 변환이 됩니다.
하지만, 표준 속성이 아닌 경우에는 프로퍼티로 변환이 안 되는데요. 아래 메소드를 활용하면 표준이 아닌 HTML 속성들도 다룰 수 있습니다.

속성에 접근하기: element.getAttribute('속성')
속성 추가(수정)하기: element.setAttribute('속성', '값')
속성 제거하기: element.removeAttribute('속성')

# 8. 스타일 다루기
자바스크립트로 태그의 스타일을 다루는 방법에는 크게 두 가지가 있습니다.

style 프로퍼티 활용하기: element.style.styleName = 'value';
class 변경을 통해 간접적으로 스타일 적용하기: element.className, element.classList
# 8-1. classList의 유용한 메소드
메소드	내용	참고사항
classList.add	클래스 추가하기	여러 개의 값을 전달하면 여러 클래스 추가 가능
classList.remove	클래스 삭제하기	여러 개의 값을 전달하면 여러 클래스 삭제 가능
classList.toggle	클래스 없으면 추가, 있으면 삭제하기	하나의 값만 적용 가능하고,
두 번째 파라미터로 추가 또는 삭제 기능을 강제할 수 있음


# 이벤트 핸들러 등록하기 addEventListener
let btn = document.querySelector('#myBtn');

function event1() {
console. log('Hi Codeit!');
}
function event2() {
console. log('Hi again!');

}

// 이벤트 핸들러를 따로 사용
elem.addEventListener(event, handler);
btn. addEventListener('click', event1);
btn.addEventListener('click', event2);

// 이벤트 핸들러 삭제 / 이벤트 핸들러 등록 했던 내용을 그대로 사용해야 한다. 함수명을 정하고 함수명을 전달
elem.removeEventListener(event, handler);
btn. removeEventListener('click', event1);


# 다양한 이벤트

# 마우스 이벤트
이벤트 타입	설명
mousedown	마우스 버튼을 누르는 순간
mouseup	마우스 버튼을 눌렀다 떼는 순간
click	왼쪽 버튼을 클릭한 순간
dblclick	왼쪽 버튼을 빠르게 두 번 클릭한 순간
contextmenu	오른쪽 버튼을 클릭한 순간
mousemove	마우스를 움직이는 순간
mouseover	마우스 포인터가 요소 위로 올라온 순간
mouseout	마우스 포인터가 요소에서 벗어나는 순간
mouseenter	마우스 포인터가 요소 위로 올라온 순간 (버블링이 일어나지 않음)
mouseleave	마우스 포인터가 요소에서 벗어나는 순간 (버블링이 일어나지 않음)

# 키보드 이벤트
이벤트 타입	설명
keydown	키보드의 버튼을 누르는 순간
keypress	키보드의 버튼을 누르는 순간 ('a', '5' 등 출력이 가능한 키에서만 동작하며, Shift, Esc 등의 키에는 반응하지 않음)
keyup	키보드의 버튼을 눌렀다 떼는 순간

# 포커스 이벤트
이벤트 타입	설명
focusin	요소에 포커스가 되는 순간
focusout	요소로부터 포커스가 빠져나가는 순간
focus	요소에 포커스가 되는 순간 (버블링이 일어나지 않음)
blur	요소로부터 포커스가 빠져나가는 순간 (버블링이 일어나지 않음)

# 입력 이벤트
이벤트 타입	설명
change	입력된 값이 바뀌는 순간
input	값이 입력되는 순간
select	입력 양식의 하나가 선택되는 순간
submit	폼을 전송하는 순간

# 스크롤 이벤트
이벤트 타입	설명
scroll	스크롤 바가 움직일 때

# 윈도우 창 이벤트
이벤트 타입	설명
resize	윈도우 사이즈를 움직일 때 발생


# 이벤트 객체

// 이벤트 객체 (Event Object)
const myInput = document.querySelector('#myInput');
const myBtn = document.querySelector('#myBtn');

function printEvent(event) {
console.log(event);
event.target.style.color = 'red';
}

myInput.addEventListener('keydown', printEvent);
myBtn.addEventListener('click', printEvent);


# 이벤트 객체 프로퍼티
이벤트 핸들러의 첫번째 파라미터에는 자동으로 이벤트 객체가 전달된다는 걸 배웠습니다.
그리고 그 이벤트 객체는 이벤트 타입에 따라서 갖고 있는 프로퍼티들이 조금씩 다른데요.

이번 시간에는 자주 사용되는 이벤트 객체의 프로퍼티들을 한 번 정리해 봅시다.

# 1. 공통 프로퍼티
아래의 프로퍼티들은 이벤트 타입과 상관없이 모든 이벤트 객체들이 공통적으로 가지고 있는 프로퍼티입니다.

프로퍼티	설명
type	이벤트 이름 ('click', 'mouseup', 'keydown' 등)
target	이벤트가 발생한 요소
currentTarget	이벤트 핸들러가 등록된 요소
timeStamp	이벤트 발생 시각(페이지가 로드된 이후부터 경과한 밀리초)
bubbles	버블링 단계인지를 판단하는 값

# 2. 마우스 이벤트
마우스와 관련된 이벤트의 경우에는 아래와 같은 이벤트 객체의 프로퍼티들을 가지고 있습니다.

프로퍼티	설명
button	누른 마우스의 버튼 (0: 왼쪽, 1: 가운데(휠), 2: 오른쪽)
clientX, clientY	마우스 커서의 브라우저 표시 영역에서의 위치
pageX, pageY	마우스 커서의 문서 영역에서의 위치
offsetX, offsetY	마우스 커서의 이벤트 발생한 요소에서의 위치
screenX, screenY	마우스 커서의 모니터 화면 영역에서의 위치
altKey	이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey	이벤트가 발생할 때 ctrl키를 눌렀는지
shiftKey	이벤트가 발생할 때 shift키를 눌렀는지
metaKey	이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키)

# 3. 키보드 이벤트
키보드와 관련된 이벤트의 경우에는 아래와 같은 이벤트 객체의 프로퍼티들을 가지고 있습니다.

프로퍼티	설명
key	누른 키가 가지고 있는 값
code	누른 키의 물리적인 위치
altKey	이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey	이벤트가 발생할 때 ctrl키를 눌렀는지
shiftKey	이벤트가 발생할 때 shift키를 눌렀는지
metaKey	이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키)

이 프로퍼티들은 자주 사용되는 프로퍼티일 뿐 이벤트 객체의 모든 프로퍼티가 아닙니다.
혹시 이벤트 객체의 더 많은 프로퍼티들이 궁금하시다면 아래 링크를 참고해 보세요!

# 이벤트 : https://developer.mozilla.org/en-US/docs/Web/API/Event
# 마우스 이벤트 : https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
# 키보드 이벤트 : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent



# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>오늘 할 일</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="main">
    <h2 class="title">오늘 할 일</h2>
    <ul id="to-do-list" class="to-do-list">
      <li>자바스크립트 공부하기</li>
      <li>고양이 화장실 청소하기</li>
      <li>고양이 장난감 쇼핑하기</li>
    </ul>
  </div>
  <script src="index.js"></script>
</body>
</html>

# style.css
body {
  margin: 0;
  padding: 0;
	display: flex;
	align-items: center;
	justify-content: center;
}

.main {
	width: 350px;
	margin: 40px;
  padding: 30px 0;
  background-color: #FCFCFC;
  box-shadow: -5px -5px 20px #DFDFDF,  5px 5px 20px #BABECC;
  border-radius: 8px;
  text-align: center;
}

.title {
	margin: 15px auto;
	font-size: 30px;
	font-weight: 600;
	color: #9600FF;
}

#to-do-list {
  width: 280px;
	margin: 0 auto 15px;
	padding: 0;
	list-style: none;
}

#to-do-list li {
	display: flex;
	align-items: center;
	justify-content: center;
  width: 90%;
  height: 40px;
	margin: 8px auto 15px;
	border-bottom: 1px solid #9600FF;
	cursor: pointer;
}

.done {
  opacity: 0.5;
  text-decoration: line-through;
}

# 해설
이벤트 객체를 활용한 이벤트 핸들러, updateToDo 함수를 완성하는 건데요.
이 함수는 이벤트가 발생한 대상에 'done'이라는 class 속성값을 toggle하는 함수니깐, 이벤트 객체의 target을 활용하면 되겠죠?

지용이가 처음에 작성한 코드의 이벤트 핸들러를 활용해서 아래와 같이 함수를 완성해 볼 수 있습니다.

function updateToDo(event) {
  event.target.classList.toggle('done');
}
이렇게 코드를 작성한다면 이벤트가 발생한 대상(event.target)에 'done'이라는 클래스 속성값을 toggle(.classList.toggle('done'))할 수 있겠죠?

다음은 반복문을 활용해서 이벤트 핸들러를 등록해 주는 코드인데요. 일단 for문을 활용해 코드를 작성해 볼게요.

for (let i = 0; i < items.length; i++) {
  items[i].addEventListener('click', updateToDo);
}
비록 유사 배열이긴 하지만 유사 배열도 for..of문을 활용하는 데는 문제가 없기 때문에, for..of문을 활용하는 방법도 알려 드릴게요.

for (let item of items) {
  item.addEventListener('click', updateToDo);
}
이렇게 하니깐 for 키워드 다음에 소괄호 안쪽 부분이 조금 더 간결해 보이죠? 하지만 코드의 의미는 두 반복문이 모두 같기 때문에 어떻게 작성하더라도 작동하는 데는 문제 없습니다.

코드를 실행해 보면, 테스트 코드에 의해서 세 번째 할 일의 이벤트 핸들러가 삭제되어 정상적으로 동작하지 않습니다. removeEventListener도 잘 작동했네요. 반면에 이벤트 핸들러를 삭제하지 않은 첫 번째, 두 번째 할 일은 클릭할 때마다 'done'이라는 클래스 속성 값이 toggle 되면서 스타일이 잘 변하는 모습을 확인할 수가 있습니다.

# 모범 답안
const toDoList = document.querySelector('#to-do-list');
const items = toDoList.children;

// 1. updateToDo 함수를 완성해 주세요
function updateToDo(event) {
  event.target.classList.toggle('done');
}

// 2. 반복문을 활용해서 각 li태그에 이벤트 핸들러를 등록해 주세요
for (let item of items) {
  item.addEventListener('click', updateToDo);
}

// 테스트 코드
items[2].removeEventListener('click', updateToDo);



# 이벤트 버블링

const content = document.querySelector('#content');
const title = document.querySelector('#title');
const list = document.querySelector('#list');
const items = document.querySelectorAll('.item');

content.addEventListener('click', function(e) {
console.log('content Event');
console.log(e.currentTarget);
});

title.addEventListener('click', function(e) {
console.log('title Event');
console.log(e.currentTarget);
});

list.addEventListener('click', function(e) {
console.log('list Event');
console.log(e.currentTarget);
});

for (let item of items) {
item.addEventListener('click', function(e) {
console.log('item Event');
console.log(e.currentTarget);
e.stopPropagation();  // 버블링 스탑
});
}

# 버블링 스탑
[???].stopPropagation(); 


# 캡쳐링
이벤트엔 버블링 이외에도 ‘캡처링(capturing)’ 이라는 흐름이 존재합니다. 
실제 코드에서 자주 쓰이진 않지만, 상황에 따라 필요할 수도 있으니 간단하게 살펴봅시다.

먼저, 표준 DOM 이벤트에서 정의한 이벤트 흐름에는 3가지 단계가 있습니다.

캡처링 단계: 이벤트가 하위 요소로 전파되는 단계
타깃 단계: 이벤트가 실제 타깃 요소에 전달되는 단계
버블링 단계: 이벤트가 상위 요소로 전파되는 단계
버블링 단계는 이미 지난 시간에 배웠죠? 타깃 단계는 이벤트 객체의 target 프로퍼티가 되는 요소에 등록되어있던 이벤트 핸들러가 동작하는 단계인데, 쉽게 생각해서 가장 처음 이벤트 핸들러가 동작하게 되는 순간이라고 생각하시면 됩니다.

자, 그럼 이제 캡쳐링에 대해서 좀 더 알아볼까요?

캡쳐링
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>JS with Codeit</title>
  </head>
  <body>
    <div id="content">
      <h1 id="title">오늘 할 일</h1>
      <ol id="list">
        <li class="item">자바스크립트 공부</li>
        <li class="item">독서</li>
      </ol>
    </div>
    <script src="index.js"></script>
  </body>
</html>
만약 위 코드에서 자바스크립트 공부를 클릭한다면, 버블링은 li태그 부터, ol태그, div태그, body태그, html태그, document, window 객체로 이벤트가 전파가 된다는 거 알고 계시죠?
캡쳐링은 이벤트가 발생하면 가장 먼저, 그리고 버블링의 반대 방향으로 진행되는 이벤트 전파 방식입니다.

아래 이미지를 한번 보세요.

# 캡쳐링

이벤트가 발생하면 가장 먼저 window 객체에서부터 target 까지 이벤트 전파가 일어납니다. (캡쳐링 단계)
그리고 나서 타깃에 도달하면 타깃에 등록된 이벤트 핸들러가 동작하고, (타깃 단계)
이후 다시 window 객체로 이벤트가 전파됩니다. (버블링 단계)

이런 과정을 통해 각 요소에 할당된 이벤트 핸들러가 호출되는데요.

캡쳐링 단계에서 이벤트를 발생시켜야 하는 일은 매우 드문 경우입니다. 보통 타깃 단계에서 target에 등록된 이벤트 핸들러가 있으면 해당 이벤트 핸들러가 먼저 동작한 이 후에 버블링 단계에서 각 부모 요소에 등록된 이벤트 핸들러가 있으면 그 때 해당 이벤트 핸들러가 동작하는 것이 일반적인데요.

하지만 상황에 따라서는 캡쳐링 단계에서 부모 요소의 이벤트 핸들러를 동작시켜야 할 수도 있겠죠? 캡쳐링 단계에서 이벤트 핸들러를 동작시키려면, addEventListener에 세번째 프로퍼티에 true 또는 { capture:true }를 전달하면 됩니다.
아래 코드를 실행해서 각 태그들을 클릭해 보세요.

# html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>Codeit Acid Rain</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div>DIV
      <ul>UL
        <li>LI</li>
      </ul>
    </div>  
    <script>
      for (let elem of document.querySelectorAll('*')) {
        elem.addEventListener("click", e => alert(`캡쳐링 단계: ${elem.tagName}`), true);
        elem.addEventListener("click", e => alert(`버블링 단계: ${elem.tagName}`));
      }
    </script>
  </body>
</html>


# css
body * {
  margin: 10px;
  padding: 10px;
  background-color: rgba(150, 0, 255, 0.15);
}


캡쳐링과 함께 자바스크립트의 이벤트에 더 궁금한 부분이 있다면 아래 링크를 참고해 주세요!

# 참고링크
# 표준 DOM 이벤트 : https://www.w3.org/TR/DOM-Level-3-Events/
# 자바스크립트의 이벤트 순서 : https://www.quirksmode.org/js/events_order.html#link4
# addEventListner에 캡쳐링 단계 적용하기 : https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener


# 이벤트 위임 (Event Delegation)
const list = document.querySelector('#list');

list.addEventListener('click', function(e) {
  e.target.classList.toggle('done');
});

const li = document.createElement('li');
li.classList.add('item');
li.textContent = '일기 쓰기';
list.append(li);


// 부모 요소에 버블링을 등록 하면 새로 생성된 자녀 요소에도 핸들러가 적용이 된다.
// 부모 요소에서도 핸들링이 작동하기 때문에 아래와 같이 사용해야 한다.
// 자식 요소에 있는 요소들을 확인후 입력

list.addEventListener('click', function(e) {
  // if (e.target.tagName === 'LI')
  if (e.target.classList.contains('item')) {
    e.target.classList.toggle('done');
  }
});


# 완료한 일 체크하기
const toDoList = document.querySelector('#to-do-list');

// 1. updateToDo 함수를 완성해 주세요
function updateToDo(event) {
  if (event.target.classList.contains('item')) {
    event.target.classList.toggle('done');
  }
}

// 2. 각 li 태그가 아닌 하나의 태그에만 이벤트 핸들러를 등록해 주세요
toDoList.addEventListener('click', updateToDo);

// 테스트 코드
const newToDo = document.createElement('li');
newToDo.textContent = '가계부 정리하기';
newToDo.classList.add('item');
toDoList.append(newToDo);

toDoList.children[2].addEventListener('click', function(e) {e.stopPropagation()});




# 브라우저의 기본 동작
const link = document.querySelector('#link');
const checkbox = document.querySelector('#checkbox');
const input = document.querySelector('#input');
const text = document.querySelector('#text');

// event.preventDefault
link.addEventListener('click', function(e) {
e.preventDefault();
alert('지금은 이동할 수 없습니다. ');
});

input.addEventListener('keydown', function(e) {
if (!checkbox.checked) {
e.preventDefault();
alert('체크박스를 먼저 클릭해 주세요. ');
  }
});

document.addEventListener('contextmenu', function(e) {
e.preventDefault();
alert('마우스 오른쪽 클릭은 사용할 수 없습니다.');
});



# 이벤트 종합 정리
1. 이벤트 핸들러 등록하기
HTML의 속성이나 DOM 프로퍼티를 활용해 이벤트를 등록하는 방법 외에 Element.addEventListener('type', 'handler')를 통해서 이벤트 핸들러를 등록할 수 있습니다.

2. 이벤트 핸들러 삭제하기
addEventListener 메소드를 활용해서 이벤트 핸들러를 등록했다면, Element.removeEventListner('type', 'handler')를 통해서 이벤트 핸들러를 삭제할 수 있습니다.

3. 이벤트 객체 (Event Object)
이벤트가 발생하면 이벤트 핸들러의 첫 번째 파라미터에는 자동으로 이벤트 객체가 전달됩니다.

이벤트 객체는 이벤트 종류마다 가지고 있는 프로퍼티가 다르며, 이벤트에 대한 유용한 정보들을 프로퍼티로 가지고 있습니다.

4. 이벤트 버블링 (Event Bubbling)
이벤트는 전파가 됩니다. 
어떤 요소에서 이벤트가 발생하면 해당 요소에 등록된 이벤트 핸들러가 동작하는 것뿐만 아니라 부모 요소로 이벤트가 계속해서 전파되면서 각 요소에도 등록된 이벤트 핸들러가 있다면 차례로 이벤트 핸들러가 동작하는데요.

자식 요소에서 부모 요소로 이벤트가 전파되는 것을 이벤트 버블링(Event Bubbling)이라고 부릅니다.

참고로 이벤트 버블링은 이벤트 객체의 stopPropagation 메소드로 전파를 막을 수 있습니다.

5. 이벤트 위임 (Event Delegation)
버블링 개념을 활용하면 훨씬 효과적인 이벤트 관리를 할 수 있습니다. 예를 들어 자식 요소 각각에 이벤트 핸들러를 하나씩 등록할 필요 없이 부모 요소에서 한 번에 자식 요소들에 발생한 이벤트를 관리할 수도 있는데요.

이렇게 이벤트를 다루는 방식을 자식 요소의 이벤트를 부모 요소에 위임한다고 해서 이벤트 위임(Event Delegation)이라고 부릅니다.

이벤트 위임을 잘 활용하면 훨씬 더 효율적으로 이벤트를 다룰 수 있습니다.

6. 브라우저의 기본 동작
브라우저에는 각 태그별 혹은 상황별로 기본적으로 약속된 동작들이 있습니다.

예를 들어 마우스 오른쪽 버튼을 클릭하면 상황에 맞는 메뉴 창이 뜬다거나, input 태그에 커서를 두고 키보드 키를 누르면 해당 값이 입력된다거나..

그런데 만약 이러한 동작들을 막고 싶다면 이벤트 객체의 preventDefault 메소드를 통해 막을 수가 있습니다.

하지만 각 HTML 태그들이 가지고 있는 고유한 역할과 의미를 훼손하게 될 수도 있기 때문에 꼭 필요한 경우에만 주의해서 사용해야 한다는 점. 꼭 기억해 주세요!


# 마우스 버튼 이벤트

> MouseEvent.button
0: 마우스 왼쪽 버튼
1: 마우스 휠
2: 마우스 오른쪽 버튼

> MouseEvent.type
click: 마우스 왼쪽 버튼을 눌렀을 때
contextmenu: 마우스 오른쪽 버튼을 눌렀을 때
dblclick: 동일한 위치에서 빠르게 두번 click할 때
mousedown: 마우스 버튼을 누른 순간
mouseup: 마우스 버튼을 눌렀다 뗀 순간


# 청기 올려 백기 올려

# 해설
이번 실습에서 해결해야될 과제는 총 2가지 입니다.
마우스 버튼에 따라서 청기(flagBlue)와 백기(flagWhite)에 'up'이라는 클래스 속성값을 추가해야 하고, 마우스 오른쪽 버튼을 눌렀을 때 나타나는 옵션창을 막아야 합니다.

일단, 첫 번째부터 해결해 봅시다.
자바스크립트 파일의 마지막 테스트 코드 부분을 보면 flagUp 함수는 document 객체의 mousedown 타입의 이벤트 핸들러로 등록되어 있습니다.
다시 말해, 웹 페이지 어디서든 마우스의 어떤 버튼이 눌리는 순간 flagUp 함수가 호출된다는 의미이죠.

이런 상황에서 마우스 버튼을 구분하는 방법은 마우스 이벤트 객체의 button 프로퍼티를 활용하는 겁니다.
만약, 마우스 이벤트가 마우스 왼쪽 버튼을 눌러서 발생했다면 0, 마우스 오른쪽 버튼을 눌러서 발생했다면 2라는 값을 가지게 돼요.

그래서 이 button 프로퍼티를 조건문과 함께 다음과 같이 활용하면 생각보다 간단하게 flagUp 함수를 완성할 수 있습니다.

// 1. flagUp 함수를 완성해 주세요
function flagUp(e) {
  if (e.button === 0) {
    flagBlue.classList.add('up');
  } else if (e.button === 2) {
    flagWhite.classList.add('up');
  }

  // 500 밀리초 뒤에 reset함수를 실행
  setTimeout(reset, 500);
}
두 번째는 마우스 오른쪽 버튼을 눌렀을 때 나타나는 옵션창을 막는 거였죠? 이 부분은 지난 브라우저의 기본 동작 레슨을 잘 학습하셨다면 훨씬 더 간단하게 해결할 수 있습니다.

브라우저의 기본 동작으로써 마우스 오른쪽 버튼을 눌러서 나타나는 메뉴창은 바로, contextmenu 타입의 이벤트가 발생했을 때 나타나게 돼요.

브라우저의 기본 동작은 이벤트 객체의 preventDefault 메소드를 사용해서 막을 수 있으니 아래와 같이 코드를 작성할 수 있습니다.

document.addEventListener('contextmenu', function (event) {
  // 여기에 코드를 작성해 주세요
  event.preventDefault();
});
이렇게 코드를 작성하고 프로그램을 실행해보면, 마우스 왼쪽 버튼을 클릭했을 땐 청기(flagBlue)가 올라가고 마우스 오른쪽 버튼을 클릭했을 땐 백기(flagWhite)가 올라가는 모습을 확인할 수 있습니다.

# 모범 답안
const flagBlue = document.querySelector('.flag-blue');
const flagWhite = document.querySelector('.flag-white');

function reset() {
  document.querySelector('.up').classList.remove('up');
}

// 1. flagUp 함수를 완성해 주세요
function flagUp(e) {
  if (e.button === 0) {
    flagBlue.classList.add('up');
  } else if (e.button === 2) {
    flagWhite.classList.add('up');
  }

  // 500 밀리초 뒤에 reset함수를 실행
  setTimeout(reset, 500);
}

// 2. 마우스 오른쪽 버튼 클릭시 나타나는 메뉴창을 막아주세요
document.addEventListener('contextmenu', function (event) {
  event.preventDefault();
});

// 테스트 코드
document.addEventListener('mousedown', flagUp);


# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
  <title>청기 백기</title>
</head>
<body>
  <div class="container">
    <img src="imgs/flag-blue.png" alt="flag" class="flag flag-blue">
    <img src="imgs/flag-white.png" alt="flag" class="flag flag-white">
  </div>
  <script src="index.js"></script>
</body>
</html>

# style.css
* {
  box-sizing: border-box;
}

body {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  margin: 0;
  background-size: cover;
  background-position: center;
  background-image: url('imgs/bg.png');
  background-repeat: no-repeat;
}

body::before {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #333333;
  opacity: 0.5;
  content: '';
}

.container {
  display: flex;
  justify-content: space-around;
  align-items: center;
  width: 80%;
  height: 500px;
  max-width: 1000px;
}

.flag {
  width: 35%;
  transition-duration: .3s;
}

.flag-blue {
  transform: rotate(25deg);
}

.flag-white {
  transform: rotate(-25deg) scaleX(-1);
}

.flag-blue.up {
  transform: rotate(-25deg) translateY(-40%);
}

.flag-white.up {
  transform: rotate(25deg) scaleX(-1) translateY(-40%);
}


# 마우스 이동 이벤트I

> MouseEvent.type
mousemove: 마우스 포인터가 이동할 때
mouseover: 마우스 포인터가 요소 밖에서 안으로 이동할 때
mouseout: 마우스 포인터가 요소 안에서 밖으로 이동할 때 

> MouseEvent.clientX, clientY
: 화면에 표시되는 창 기준 마우스 포인터 위치   

> MouseEvent.pageX, pageY
: 웹 문서 전체 기준 마우스 포인터 위치

> MouseEvent.offsetX, offsetY
: 이벤트가 발생한 요소 기준 마우스 포인터 위치

> MouseEvent.target
: 이벤트가 발생한 요소

> MouseEvent.relatedTarget
: 이벤트가 발생하기 직전(또는 직후)에 마우스가 위치해 있던 요소



const box1 = document.querySelector('#box1');

function onMouseMove(e) {
  console.log(`client: (${e.clientX}, ${e.clientY})`);
  console.log(`page: (${e.pageX}, ${e.pageY})`);
  console.log(`offset: (${e.offsetX}, ${e.offsetY})`);
  console.log('------------------------------------');
}

box1.addEventListener('mousemove', onMouseMove);


# client, page, offset 차이

마우스 이벤트를 다룰 때 자주 사용되는 이벤트 객체의 프로퍼티인 clientXY, pageXY, offsetXY에 대해서 한 번 더 짚고 넘어갑시다!

1. clientX, clientY
client 프로퍼티는 말 그대로 클라이언트 영역 내에서 마우스의 좌표 정보를 담고있는데요. 클라이언트 영역이란 이벤트가 발생한 순간에 브라우저가 콘텐츠를 표시할 수 있는 영역을 뜻합니다.

clientX : 브라우저가 표시하는 화면 내에서 마우스의 X좌표 위치를 담고 있습니다.
clientY : 브라우저가 표시하는 화면 내에서 마우스의 Y좌표 위치를 담고 있습니다.

client 값은 그 순간 보여지는 화면을 기준으로 계산하기 때문에 스크롤 위치와는 무관하게 항상 보여지는 화면의 좌측 상단의 모서리 위치를 (0, 0)으로 계산합니다.

2. offsetX, offsetY
offset 프로퍼티는 이벤트가 발생한 target이 기준이 됩니다.

offsetX : 이벤트가 발생한 target 내에서 마우스의 X좌표 위치를 담고 있습니다.
offsetY : 이벤트가 발생한 target 내에서 마우스의 Y좌표 위치를 담고 있습니다.

offset 값도 이벤트가 발생한 대상을 기준으로 계산하기 때문에 스크롤 위치와는 무관하게 항상 대상의 좌측 상단의 모서리 위치를 (0, 0)으로 계산합니다.

3. pageX, pageY
page 프로퍼티는 전체 문서를 기준으로 마우스 좌표 정보를 담고 있습니다. 그렇기 때문에 스크롤로 인해서 보이지 않게된 화면의 영역까지 포함해서 측정한다는 점이 앞의 두 프로퍼티와의 차이점 입니다.

pageX : 전체 문서 내에서 마우스의 X좌표 위치를 담고 있습니다.
pageY : 전체 문서 내에서 마우스의 Y좌표 위치를 담고 있습니다.

자칫 client 값과 혼동하기 쉬우니 잘 구분해 두시는 것이 좋습니다.



# mouseenter / mouseleave
마우스 이벤트 타입에는 mouseover, mouseout과 비슷한 mouseenter와 mouseleave라는 타입이 있습니다.

# html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <title>JS with Codeit</title>
  </head>
  <body>
    <div id="box1" class="box">
      <b class="title">mouseover event count: 0</b>
    </div>

    <div id="box2" class="box">
      <b class="title">mouseenter event count: 0</b>
    </div>
    <script>
      const box1 = document.querySelector('#box1');
      const box2 = document.querySelector('#box2');

      let mouseenterCount = 0;
      let mouseoverCount = 0;

      box1.addEventListener('mouseover', function () {
        mouseenterCount++;
        const msg = `mouseover event count: ${mouseenterCount}`;
        box1.lastElementChild.textContent = msg;
      });

      box2.addEventListener('mouseenter', function () {
        mouseoverCount++;
        const msg = `mouseenter event count: ${mouseoverCount}`;
        box2.lastElementChild.textContent = msg;
      });
    </script>
  </body>
</html>

# css
.box {
  display: inline-block;
  width: 200px;
  margin: 20px;
  padding: 60px 35px;
}

#box1 {
  background-color: #B6FFAA;
}

#box2 {
  background-color: #ACFFFC;
}

.title {
  display: inline-block;
  padding: 20px;
  font-size: 18px;
  text-align: center;
  background-color: #FFFFFF;
  border: 1px solid #333333;
}


1. 버블링이 일어나지 않는다.
mouseenter와 mouseleave는 버블링이 일어나지 않습니다.

위 코드 결과에서 mouseover 타입으로 이벤트 핸들러가 등록된 div#box1요소(왼쪽)에서 마우스를 움직여 보세요.

당연히 해당 요소 바깥에서 안쪽으로 마우스 커서가 이동할 때도 이벤트가 발생하지만, 버블링과 이벤트 위임의 원리로 자식요소인 b.title 부분으로 마우스 커서가 이동할 때도 이벤트가 발생합니다.

하지만 mouseenter 타입으로 이벤트 핸들러가 등록된 div#box2요소(오른쪽)에서는 해당 요소 바깥에서 안쪽으로 마우스 커서가 이동할 때만 이벤트 핸들러가 동작하는 모습을 확인할 수 있습니다.

2. 자식 요소의 영역을 계산하지 않는다.
mouseenter와 mouseleave는 자식 요소의 영역을 계산하지 않습니다.

다시 mouseover 타입으로 이벤트 핸들러가 등록된 div#box1요소(왼쪽)에서 마우스를 움직여 봅시다.

버블링에 의해 자식 요소로 마우스 커서가 이동할 때도 이벤트 핸들러가 동작하지만, 자식 요소에서 다시 div#box1요소로 마우스 커서가 이동할 때도 이벤트 핸들러가 동작하죠? mouseover는 자식 요소의 영역을 구분하기 때문입니다.

반면, mouseenter는 자식 요소의 영역을 구분하지 않기 때문에 mouseenter 타입으로 이벤트 핸들러가 등록된 div#box2요소(오른쪽)에서는 자식 요소에서 이벤트 핸들러가 동작하지 않는 것뿐만 아니라 자식 요소의 영역에 들어갔다 나올 때도 이벤트 핸들러가 동작하지 않는 모습을 볼 수 있습니다.

정리
mouseover/mouseout과 비교하면서 mouseenter/mouseleave에 대해 살펴봤는데요.
간단하게 정리하면, 이벤트가 자식 요소에 영향끼치는지가 둘의 가장 큰 차이라고 할 수 있습니다.

그래서 이벤트 핸들러가 자식 요소에까지 영향을 끼치게 하고싶은 경우에는 mouseover/mouseout을, 자식 요소에는 영향을 끼치지 않고 해당 요소에만 이벤트 핸들러를 다루고자 한다면 mouseenter/mouseleave를 활용하면 좋겠죠?


# [키보드 이벤트]

> KeyboardEvent. type
keydown: 키보드 버튼을 누른 순간
keypress: 키보드 버튼을 누른 순간
keyup: 키보드 버튼을 눌렀다 뗀 순간

> KeyboardEvent.key
: 이벤트가 발생한 버튼의 값

> KeyboardEvent. code
: 이벤트가 발생한 버튼의 키보드에서 물리적인 위치


# 똑Talk한 Enter키!

실습 설명
코드잇 우등생 규리는 최근에 공부한 HTML/CSS, 그리고 자바스크립트를 활용해서 웹으로 간단한 채팅 앱을 만들었습니다. 
textarea 태그에 메시지를 입력하고 오른편에 있는 send 버튼을 클릭하면 화면에 입력한 메시지가 나오죠.

규리가 만든 것처럼 text 타입의 input 태그나 textarea 태그를 자바스크립트로 선택한 다음에 해당 요소 노드의 value 프로퍼티를 활용하면 해당 태그에 입력된 값을 다룰 수 있습니다.

그런데 한 가지 아쉬운 점은 키보드로 메시지를 입력하고 나면, 마우스를 움직여서 send 버튼을 눌러야 한다는 겁니다.

아쉬운 규리를 위해서 textarea 태그에서 enter 키를 누르면 sendMyText 함수가 호출되는 코드를 추가해 주세요.

코드를 완성했을 때 아래 조건들이 지켜져야 합니다.

enter 키로 메시지를 전송하고 나면 textarea 태그는 초기화가 제대로 되어야 합니다.
shift+enter 일때는 줄바꿈이 일어나야 합니다.
keypress 타입으로 이벤트 핸들러가 등록되어야 합니다.


# 참고 사항
하나의 버튼에 하나의 값이 입력되는 영어와는 다르게, 한국어의 자음과 모음의 결합처럼 여러 버튼을 눌러서 하나의 입력 값을 만들 수 있는 언어들은 입력할 때 자세히 살펴보면, 화면에 입력중인 문자 바로 아래에 작은 밑줄이 나타나는 경우를 볼 수 있습니다. 만약 keyup, keydown 타입으로 이벤트 핸들러를 등록하고, 그 밑줄이 보이는 상황에서 enter나 esc, 혹은 방향키와 같은 키보드 버튼을 누를 경우 해당 버튼에 대한 이벤트가 2번 중복해서 반응하는 이슈가 있습니다. 왜냐하면 글자가 조합 중인지, 조합이 완료된 것인지 쉽게 파악하기 어렵기 때문인데요. 그래서 이렇게 특별한 상황에 따라서는 keypress가 필요할 수도 있다는 점. 참고해 두시면 좋을 것 같습니다!

# 해설
키보드 이벤트를 활용해서 enter 키를 눌렀을 때 이벤트 핸들러가 동작하도록 코드를 작성해 봅시다.

일단은 이벤트 핸들러를 만들어 볼 텐데요. 이번 이벤트 핸들러의 가장 중요한 부분은 바로 enter키를 눌렀을 때죠?
키보드 이벤트가 발생할 때 이벤트 객체에서는 key와 code 프로퍼티가 자주 사용되죠.

key는 사용자가 누른 키가 가지고 있는 값을 나타내고 code는 누른 키의 물리적인 위치를 나타냅니다.

일반적으로 작은 노트북이나 키보드 오른쪽에 숫자판이 없는 짧은 텐키리스 키보드는 엔터키가 하나 밖에 없습니다.

그래서 두 프로퍼티 중 아무거나 사용해도 상관 없을 것 같지만 키보드 오른쪽에 숫자판이 있는 키보드의 경우에는 오른쪽 아랫부분에 enter키가 하나 더 있죠?
그 숫자판의 enter키를 누르면 key 프로퍼티에는 'Enter'가, code 프로퍼티에는 'numpadEnter'라는 값이 담깁니다.

만약 하나의 엔터키에만 프로그램이 동작하도록 하려면 code 프로퍼티로 두 enter키를 구분하는 것이 좋고 두 엔터키 모두 동작하도록 하면 key 프로퍼티를 활용하는 것이 좋겠죠?

우리는 좀 더 확장성 있는 key 프로퍼티를 활용해 봅시다.

그럼 if문을 통해 key 프로퍼티로 enter키를 구분해서 enter키가 눌렸을 때 sendMyText 함수를 호출하면 되겠죠?

그리고 실습 과제의 세 번째 조건에서 keypress 타입을 사용하라고 했으니 다음과 같이 이벤트 핸들러를 등록해 볼 수 있습니다.

function sendMyTextByEnter (e) {
  if (e.key === 'Enter') {
    sendMyText();
  }
}

input.addEventListener('keypress', sendMyTextByEnter);
생각보다 간단하게 금방 해결된 것 같지만 이대로 코드를 실행해 보면 과제의 첫 번째, 두 번째 조건이 충족되지 않고 있습니다.

일단 enter키를 통해서 메시지가 보내지긴 하지만 textarea 태그가 제대로 초기화 되지 않고 shift+enter를 누를 때도 줄바꿈이 되지 않고 그냥 바로 메시지가 보내집니다.

그럼 먼저 textarea 태그가 제대로 초기화 되지 않는 것부터 해결해 봅시다.

원래 textarea 태그에 커서를 두고 enter키 버튼을 누르면 줄바꿈이 됩니다. 이건 브라우저의 기본 동작이라고 볼 수 있는데요.

그래서 enter 키를 눌렀을 때, 우리가 등록한 이벤트 핸들러로 인해서 sendMyText 함수를 호출하기도 하지만 거기서 끝이 아니라 브라우저의 기본 동작으로써 textarea 태그에 줄바꿈을 입력하기 때문에 sendMyText 함수의 동작 부분 마지막에 초기화 코드가 있더라도 textarea 태그가 제대로 초기화 되지 않는 겁니다.

하지만 우린 이전에 브라우저의 기본 동작을 막는 방법을 배웠죠?
이벤트 객체의 preventDefault 메소드를 활용하면 브라우저의 기본 동작을 막을 수 있습니다.

function sendMyTextByEnter (e) {
  if (e.key === 'Enter') {
    sendMyText();
    e.preventDefault();
  }
}

input.addEventListener('keypress', sendMyTextByEnter);
이렇게 코드를 작성하고 실행하면 이제는 enter키로 메시지를 보낸 다음 textarea 태그가 제대로 초기화 되는 모습을 확인할 수 있습니다.

이제 마지막으로 shift+enter로 줄바꿈을 허용하는 것만 정리하면 됩니다! 이 부분은 조건문을 조금만 수정하면 간단하게 해결할 수 있어요.

사실 shift+enter 키도 브라우저의 기본 동작으로 줄바꿈이 됩니다. 그런데 지금은 shift키와 enter키를 누르면 enter가 포함되기 때문에 sendMyText함수가 호출되는 것이죠.

그럼 생각을 조금만 바꿔서 shift키를 누르지 않고서 enter키만 누를 때 sendMyText 함수를 호출하면 어떨까요?

이벤트 객체의 프로퍼티에는 shiftKey라는 프로퍼티가 있습니다. 이 프로퍼티는 이름 그대로 이벤트가 발생할 때 shift키를 눌렀는지를 불린 형태로 담고 있어요.
그래서 아래와 같이 AND연산자와 NOT연산자를 활용해서 if문의 소괄호 안쪽을 조금 수정해주면 enter키를 누를 때가 아니라, enter키만 누를 때 sendMyText 함수가 호출 됩니다.

function sendMyTextByEnter (e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    sendMyText();
    e.preventDefault();
  }
}

input.addEventListener('keypress', sendMyTextByEnter);


# 모범 답안
const chatBox = document.querySelector('#chat-box');
const input = document.querySelector('#input');
const send = document.querySelector('#send');

function sendMyText() {
  const newMessage = input.value;
  if (newMessage) {
    const div = document.createElement('div');
    div.classList.add('bubble', 'my-bubble');
    div.innerText = newMessage;
    chatBox.append(div);
  } else {
    alert('메시지를 입력하세요...');
  }

  input.value = '';
}

send.addEventListener('click', sendMyText);

function sendMyTextByEnter (e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    sendMyText();
    e.preventDefault();
  }
}

input.addEventListener('keypress', sendMyTextByEnter);


# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Codeit Messenger</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <img class="background" src="imgs/background.png">  
  <div class="container">
    <div class="header">
      <button class="back-btn">
        <img src="imgs/left-arrow.png" width="30" height="30">  
      </button>
      <img class="profile-pic" src="imgs/profile.png" width="40" height="40">
      <div class="info-block">
        <p class="username">썸남</p>
        <p class="status">1시간 전에 활동</p>
      </div>
      <div class="call-box">
        <button>
          <img src="imgs/phone-call.png" width="20" height="20">
        </button>
        <button>
          <img src="imgs/video-call.png" width="20" height="20">
        </button>
      </div>
    </div>

    <div id="chat-box">
      <div class=" bubble friend-bubble">
        자니?
      </div>
      <div class=" bubble friend-bubble">
        자나보네..ㅎ
      </div>
      <div class=" bubble friend-bubble">
        잘 자 :)
      </div>
    </div>

    <div class="footer">
      <textarea id="input" placeholder="메시지를 입력하세요..." autofocus="true"></textarea>
      <button id="send">
        <img src="imgs/send.png" width="24" height="24">  
      </button>
    </div>
  </div>
  <script src="index.js"></script>
</body>
</html>

# style.css
* {
  box-sizing: border-box;
}

button {
	border: none;
	background-color: transparent;
	cursor: pointer;
}

body {
	height: 100vh;
	display: flex;
	justify-content: center;
	align-items: center;
}

.background {
	width: 100%;
	max-width: 1200px;
	position: absolute;
	top: 0;
	left: 0;
}

.container {
	position: relative;
	width: 340px;
	height: 540px;
	border-radius: 15px;
	box-shadow: 1px 1px 10px #333333;
	background-color: #ffffff;
	overflow: hidden;
}

.header {
	display: flex;
	height: 60px;
	padding: 12px 5px 8px;
	align-items: center;
	box-shadow: 0 0 4px #999999;
}

.info-block {
	margin-left: 12px;
	margin-right: 95px;
}

.username {
	margin: 0 0 3px;
	font-size: 16px;
}

.status {
	margin: 0;
	font-size: 12px;
	color: #999999;
}

.call-box {
	display: flex;
	width: 60px;
	justify-content: space-between;
}

#chat-box {
	height: 400px;
	padding: 12px 10px;
	overflow: scroll;
}

.bubble {
	margin: 5px 0;
	display: inline-block;
	max-width: 300px;
	font-size: 14px;
	position: relative;
}

.friend-bubble {
	background-color: #f3f0f5;
	border-radius: 14px 14px 14px 0;
	padding: 7px 15px 7px 15px;
	float: left;
	clear: both;
	color: #8f00fe;
}

.my-bubble {
	background-color: #8f00fe;
	border-radius: 14px 14px 14px 0;
	padding: 7px 15px 7px 15px;
	float: right;
	clear: both;
	color: #ffffff;
}

.footer {
	display: flex;
	justify-content: space-between;
	align-items: flex-end;
	width: 100%;
	height: 80px;
	padding: 10px;
	position: absolute;
	bottom: 0;
}

#input {
	width: 90%;
	height: 100%;
	padding: 10px;
	background-color: #e8e8e8;
	border: none;
	border-radius: 10px;
	resize: none;
}


# input 태그 다루기

# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
	<link rel="stylesheet" href="style.css">
  <title>JS with Codeit</title>
</head>
<body>
  <div id="form">
    <h1 class="title">Hello !</h1>
    <input type="text" id="username" class="input" placeholder="Username">
    <input type="password" id="password" class="input" placeholder="Password">
    <input type="button" id="submit" class="btn" value="Sign in">
    <input type="checkbox" id="checkbox">
    <label for="checkbox">Stay Signed in</label>
  </div>
  <script src="index.js"></script>
</body>
</html>


# index.js
/**
 * [input 태그 다루기]
 *  
 * > 포커스 이벤트
 * focusin: 요소에 포커스가 되었을 때
 * focusout: 요소에 포커스가 빠져나갈 때
 * focus: 요소에 포커스가 되었을 때 (버블링 x)
 * blur: 요소에 포커스가 빠져나갈 때 (버블링 x)
 * 
 * > 입력 이벤트
 * input: 사용자가 입력을 할 때
 * change: 요소의 값이 변했을 때
 */

const el = document.querySelector('#form');

function printEventType(e) {
  console.log('type:', e.type);
  console.log('target:', e.target);
  console.log('---------');
}

el.addEventListener('focusin', printEventType);
el.addEventListener('focusout', printEventType);
el.addEventListener('input', printEventType);
el.addEventListener('change', printEventType);


# style.css
#form {
	width: 250px;
	height: 250px;
	margin: 70px 30px;
	padding: 30px;
	box-shadow: 2px 2px 10px #bfbfbf;
	border-radius: 5px;
}

.title {
	margin: 10px 0 15px; 
	text-align: center;
	color: #6502C2;
}

.input {
	width: 100%;
	height: 35px;
	margin: 5px 0;
	padding: 5px 10px;
	box-sizing: border-box;
	cursor: pointer;
}

.btn {
	width: 100%;
	height: 40px;
	margin: 15px 0 10px;
	color: #FFFFFF;
	border: none;
	background-image: linear-gradient(276deg, #710AD2, #8E43E6);
}

# 코드잇 산성비

# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Codeit Acid Rain</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="container">
    <input id="input" type="text" placeholder="단어를 입력하세요.">
  </div>
  <script src="initializer.js"></script>
  <script src="index.js"></script>
</body>
</html>

# index.js
const input = document.querySelector('#input');

function checker() {
  const words = document.querySelectorAll('.word');
  if (words.length === 0) {
    alert('Success!👏🏻');
    if(confirm('retry?')) {
      window.location.reload();
    }
  }
}

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (word) {
    word.remove();
    checker();
  }

  input.value = '';
}

input.addEventListener('change', removeWord);

# initializer.js
const words = ['Codeit', 'JavaScript', 'DOM', 'document', 'window', 'Event', 'Bubbling', 'Delegation'];
const container = document.querySelector('#container');

function getRandomInt(minimum, maximum) {
  const min = Math.ceil(minimum);
  const max = Math.floor(maximum);
  
  return Math.floor(Math.random() * (max - min)) + min; 
}

function init() {
  const maxPositionX = container.offsetWidth - 90;
  const maxPositionY = container.offsetHeight - 100;
  
  for (let word of words) {
    const span = document.createElement('span');
    span.classList.add('word');
    span.style.top = `${getRandomInt(20, maxPositionY)}px`;
    span.style.left = `${getRandomInt(20, maxPositionX)}px`;
    span.dataset.word = word;
    span.textContent = word;
    container.append(span);
  }
}

init();

# style.css
* {
  box-sizing: border-box;
}

body {
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100vh;
	margin: 0;
	padding: 0;
	background-image: url('imgs/background.jpg');
	background-size: cover;
	background-repeat: no-repeat;
}

#container {
	position: relative;
	width: 90%;
	height: 80%;
	box-shadow: 0 0 15px 1px #3b3b41;
	background-color: rgba(10, 10, 10, 0.3);
	border-radius: 15px;
}

#input {
	width: 180px;
	height: 45px;
	position: absolute;
	bottom: 0;
	left: 50%;
	padding: 10px;
	transform: translateX(-50%);
	font-size: 16px;
	border: none;
}

.word {
	position: absolute;
	color: #ffffff;
	font-size: 20px;
	font-weight: 500;
}


# 해설
설명에도 나와 있듯 이번 실습에서는 단어 입력이 완료되면 화면에 있는 단어들이 사라지는 이벤트 핸들러를 만들고, input 태그에 적절한 타입으로 이벤트 핸들러를 등록해야 합니다.

일단 이벤트 핸들러부터 만들어 봅시다.

이벤트 핸들러가 갖추어야 할 조건은 총 3가지인데요. 1번부터 하나씩 해결해 볼게요.

가장 첫 번째는 입력값과 일치하는 단어를 가진 요소가 있으면 그 요소를 삭제하는 겁니다. 이 이벤트 핸들러에서 가장 중요한 부분이 아닐까 싶은데요. 삭제하는 건 remove 메소드로 어렵지 않게 해결할 수 있으니 이 조건은 결국 input 태그에 입력된 단어를 담고 있는 요소 노드를 어떻게 찾느냐가 관건입니다.

그래서 각 단어의 특징 중 세 번째, 각 단어들은 'data-word' 라는 속성을 가지고 값은 그 단어를 담고 있다.를 활용해 볼게요.

지난 과제에서도 봤던 것처럼 input 태그나 textarea 태그를 선택해서 value 프로퍼티에 접근하면 해당 태그에 입력된 값을 얻어낼 수 있고, 이 값으로 [속성="값"]형태로 css 선택자를 활용하면 다음과 같이 input 태그에 단어를 담고 있는 요소 노드를 찾고, remove 메소드로 삭제할 수도 있습니다.

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  word.remove();
}
그런데 이렇게 코드를 작성하면 만약 오타로 인해 화면에 존재하지 않는 단어를 입력했을 때 word 부분이 null이 될 가능성이 있습니다.

그러면 remove 메소드를 호출하는 부분이 null.remove();이 될 수 있는데, 이런 경우에는 콘솔에 Uncaught TypeError: Cannot read property 'remove' of null라는 에러가 출력됩니다.

말 그대로 null에는 remove 메소드가 없는데 remove 메소드를 호출했다는 의미죠. 그래서 다음과 같이 if문을 통해서 word가 truthy한 값을 가질 때 remove 메소드를 호출하게 수정해 주어야 합니다.

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (word) {
    word.remove();
  }
}
혹은 다음과 같이 remove 메소드를 호출하기 전에 if문을 통해서 word가 falsy한 값을 가지게 되면 return을 해서 이벤트 핸들러 자체를 종료하는 방법도 있습니다.

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (!word) { 
    return; 
  }
  word.remove();
}
그리고 두 번째 조건은 이벤트 핸들러가 호출되면 input 태그는 매번 초기화되어야 한다.인데, 이 부분은 input태그의 value 프로퍼티에 빈 문자열을 할당해 주면 간단하게 해결할 수 있습니다.

이벤트 핸들러가 호출되면 매번 초기화되어야 하는데, 만약 이벤트 핸들러가 호출 되자마자 빈 문자열을 할당하면 word 변수에 값을 할당할 때 [data-word="${input.value}"]부분에서 input.value가 빈문자가 되겠죠? 그렇기 때문에 이벤트 핸들러의 제일 마지막에 이 코드를 작성해 주어야 합니다.

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (word) {
    word.remove();
  }

  input.value = '';
}
마지막으로 단어를 삭제했다면 checker 함수가 호출되어야 한다.는 간단하게 remove 메소드가 호출된 다음 줄에 checker 함수를 호출하기만 하면 됩니다.
이번 과제 생각보다 어렵지 않죠?

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (word) {
    word.remove();
    checker();
  }

  input.value = '';
}
그러면 이제 이벤트 핸들러를 등록하는 일만 남았습니다. 지난 시간에 배웠던 이벤트 타입들을 생각해보면 입력과 관련되었으니 input과 change 타입 둘 중 하나를 고민했을 것 같아요.

input은 값이 입력되는 순간마다 발생하고 change는 입력된 값이 바뀌는 순간, 혹은 입력이 완료된 순간에 발생한다고 배웠죠?

매번 입력할 때마다 값을 확인해서 태그를 삭제할 수도 있지만, 그러면 이벤트 핸들러가 불필요하게 호출되는 경우가 많아지기도 하고 사실 이번 과제에서는 이벤트 핸들러가 호출되면 이벤트 핸들러 조건 2에 의해서 input 태그가 항상 초기화되어야 하다 보니 input 타입은 사용하기가 어렵습니다.

심지어 text 타입의 input 태그에서는 enter키를 누르는 것으로 change 이벤트를 발생시킬 수 있다는 것도 떠올려보면, 이번 실습에서는 change 타입으로 이벤트 핸들러를 등록하는 것이 과제의 조건을 떠나서라도 성능적인 부분과 UX적인 부분에서 더 좋은 것 같습니다.

그래서 이번 실습은 다음과 같이 코드를 정리해 볼 수 있습니다. 코드를 실행해서 나타나는 단어들을 모두 제거해 보세요!

# 모범 답안
const input = document.querySelector('#input');

function checker() {
  const words = document.querySelectorAll('.word');
  if (words.length === 0) {
    alert('Success!👏🏻');
    if(confirm('retry?')) {
      window.location.reload();
    }
  }
}

function removeWord() {
  const word = document.querySelector(`[data-word="${input.value}"]`);
  if (word) {
    word.remove();
    checker();
  }

  input.value = '';
}

input.addEventListener('change', removeWord);


### 스크롤 이벤트
#index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
	<link rel="stylesheet" href="style.css">
  <title>JS with Codeit</title>
</head>
<body>
  <div id="nav">
    <h2>Logo</h2>
    <ul class="menus">
      <li class="menu">menu-1</li>
      <li class="menu">menu-2</li>
      <li class="menu">menu-3</li>
      <li class="menu">menu-4</li>
    </ul>
  </div>
  <div id="content">
    <h1 class="title">
      What is Lorem Ipsum?
    </h1>
    <div class="text">
      Lorem Ipsum is simply dummy text of the printing and typesetting industry. 
      Lorem Ipsum has been the industry`s standard dummy text ever since the 1500s, 
      when an unknown printer took a galley of type and scrambled it to make a type 
      specimen book. It has survived not only five centuries, 
      but also the leap into electronic typesetting, remaining essentially unchanged. 
      It was popularised in the 1960s with the release of Letraset sheets containing 
      Lorem Ipsum passages, and more recently with desktop publishing software like
      Aldus PageMaker including versions of Lorem Ipsum. 
      Contrary to popular belief, Lorem Ipsum is not simply random text. 
      It has roots in a piece of classical Latin literature from 45 BC, making it 
      over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney 
      College in Virginia, looked up one of the more obscure Latin words,
      consectetur, from a Lorem Ipsum passage, and going through the cites of the word 
      in classical literature, discovered the undoubtable source. Lorem Ipsum comes from
      sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum" 
      (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a 
      treatise on the theory of ethics, very popular during the Renaissance. 
      The first line of Lorem Ipsum, "Lorem ipsum dolor sit amet..", 
      comes from a line in section 1.10.32.
      The standard chunk of Lorem Ipsum used since the 1500s is reproduced below for those interested. 
      Sections 1.10.32 and 1.10.33 from "de Finibus Bonorum et Malorum" by Cicero are also reproduced 
      in their exact original form, accompanied by English versions from the 1914 translation by H. Rackham.
    </div>
  </div>
  <div id="to-top">
    ▲Top
  </div>
  <script src="index.js"></script>
</body>
</html>


# index.js
// Scroll 이벤트
let lastScrollY = 0;

function onSroll() {
  const nav = document.querySelector('#nav');
  const toTop = document.querySelector('#to-top');
  const STANDARD = 30;
  
  if (window.scrollY > STANDARD) { // 스크롤이 30px을 넘었을 때
    nav.classList.add('shadow');
    toTop.classList.add('show');
  } else { // 스크롤이 30px을 넘지 않을 때
    nav.classList.remove('shadow');
    toTop.classList.remove('show');
  } 

	if (window.scrollY > lastScrollY) { // 스크롤 방향이 아랫쪽 일 때
    nav.classList.add('lift-up');
  } else { // 스크롤 방향이 윗쪽 일 때
    nav.classList.remove('lift-up');
  }

  lastScrollY = window.scrollY;
}

window.addEventListener('scroll', onSroll);


# style.css
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body {
	padding: 80px 30px;
}

#nav {
	position: fixed;
	top: 0;
	left: 0;
	display: flex;
	justify-content: space-between;
	align-items: center;
	width: 100%;
	padding: 15px;
	background-color: #ffffff;
	transition-duration: .3s;
}

.menus {
	display: flex;	
}

.menu {
	margin-right: 20px;
	list-style: none;
}

#content {
	width: 400px;
	padding: 20px 30px;
	border-radius: 10px;
	box-shadow: 2px 2px 10px #BABECC;
}

.title {
	margin: 10px 0 15px; 
}

#to-top {
	position: fixed;
	right: 50px;
	bottom: 30px;
	display: flex;
	align-items: center;
	justify-content: center;
	width: 50px;
	height: 50px;
	border-radius: 50%;
	background-color: #fefefe;
	box-shadow: 2px 2px 10px #bfbfbf;
	visibility: hidden;
	opacity: 0;
	transition-duration: .3s;
	cursor: pointer;
}

.shadow {
	box-shadow: 2px 2px 10px #bfbfbf;
}

#to-top.show {
	visibility: visible;
	opacity: 1;
}



# 이벤트 종합정리
# 1. MouseEvent.button
마우스 이벤트 객체의 버튼 프로퍼티를 활용하면, 마우스 버튼을 눌렀을 때 일어난 이벤트에 대해서 어떤 버튼을 눌러서 일어난 이벤트인지를 정확하게 알아낼 수 있습니다.

값	내용
0	마우스 왼쪽 버튼
1	마우스 휠
2	마우스 오른쪽 버튼
3	X1 (일반적으로 브라우저 뒤로 가기 버튼)
4	X2 (일반적으로 브라우저 앞으로 가기 버튼)
참고로 mouseenter, mouseleave, mouseover, mouseout, mousemove 처럼 마우스 이동과 관련된 이벤트에서는 이 값이 null이나 undefined가 아니라 0이라는 점. 꼭 기억해 주세요!

# 2. MouseEvent.type
마우스 이벤트의 타입에는 아래와 같은 타입들이 있습니다.

이벤트 타입	설명
mousedown	마우스 버튼을 누르는 순간
mouseup	마우스 버튼을 눌렀다 떼는 순간
click	왼쪽 버튼을 클릭한 순간
dblclick	왼쪽 버튼을 빠르게 두 번 클릭한 순간
contextmenu	오른쪽 버튼을 클릭한 순간
mousemove	마우스를 움직이는 순간
mouseover	마우스 포인터가 요소 위로 올라온 순간
mouseout	마우스 포인터가 요소에서 벗어나는 순간
mouseenter	마우스 포인터가 요소 위로 올라온 순간 (버블링이 일어나지 않음)
mouseleave	마우스 포인터가 요소에서 벗어나는 순간 (버블링이 일어나지 않음)

# 3. MouseEvent.위치프로퍼티
마우스 이벤트 객체에는 마우스 포인터의 위치와 관련된 다양한 프로퍼티들이 있는데요. 주로 아래와 같은 프로퍼티들이 자주 사용됩니다.

프로퍼티	설명
clientX, clientY	마우스 포인터의 브라우저 표시 영역에서의 위치
pageX, pageY	마우스 커서의 문서 영역에서의 위치
offsetX, offsetY	마우스 포인터의 이벤트 발생한 요소에서의 위치
screenX, screenY	마우스 포인터의 모니터 화면 영역에서의 위치

# 4. MouseEvent.relatedTarget
mouseenter, mouseleave, mouseover, mouseout 이벤트에는 relatedTarget이라는 프로퍼티가 존재하는데요.

target 프로퍼티가 이벤트가 발생한 요소를 담고 있다면, relatedTarget 프로퍼티는 이벤트가 발생하기 직전(또는 직후)에 마우스가 위치해 있던 요소를 담고 있습니다.

비슷하지만 서로 다른 두 프로퍼티를 잘 구분해서 기억해 두시면 좋을 것 같습니다!

# 5. KeyboardEvent.type
키보드 이벤트의 타입에는 아래와 같은 타입들이 있습니다.

이벤트 타입	설명
keydown	키보드의 버튼을 누르는 순간
keypress	키보드의 버튼을 누르는 순간 ('a', '5' 등 출력이 가능한 키에서만 동작하며, Shift, Esc 등의 키에는 반응하지 않음)
keyup	키보드의 버튼을 눌렀다 떼는 순간

# 6. KeyboardEvent.key vs KeyboardEvent.code
키보드 이벤트 객체에는 key와 code 프로퍼티가 자주 사용되는데요.

key는 사용자가 누른 키가 가지고 있는 값을 나타내고 code는 누른 키의 물리적인 위치를 나타낸다는 점! 잘 구분해서 기억해 두시면 좋을 것 같습니다.

# 7. input태그 다루기
input 태그는 말 그대로 입력의 역할을 하는 태그입니다. 타입에 따라 조금씩 차이가 있을 수 있지만, input 태그를 다룰 때는 아래와 같은 이벤트 타입들이 활용될 수 있습니다.

이벤트 타입	설명
focusin	요소에 포커스가 되는 순간
focusout	요소에 포커스가 빠져나가는 순간
focus	요소에 포커스가 되는 순간 (버블링이 일어나지 않음)
blur	요소에 포커스가 빠져나가는 순간 (버블링이 일어나지 않음)
change	입력된 값이 바뀌는 순간
input	값이 입력되는 순간
select	입력 양식의 하나가 선택되는 순간
submit	폼을 전송하는 순간

# 8. 스크롤 이벤트
scroll 이벤트는 보통 window 객체에 이벤트 핸들러를 등록하고 window 객체의 프로퍼티와 함께 자주 활용되는데요.

특히 scrollY 프로퍼티를 활용하면 스크롤된 특정한 위치를 기준으로 이벤트 핸들러가 동작하게 하거나 혹은 스크롤 방향(위로 스크롤 중인지/아래로 스크롤 중인지)을 기준으로 이벤트 핸들러가 동작하게끔 활용할 수도 있습니다.




# 여러 Promise 객체를 다루는 방법(심화)

이때까지 우리는 하나의 Promise 객체를 다루기 위해 알아야 하는 지식들을 배웠습니다. 
하지만 실무 개발에서는 여러 개의 Promise 객체를 동시에 다뤄야 하는 경우도 있는데요. 
이번 노트에서는 여러 개의 Promise 객체를 다뤄야 할 때 사용되는 Promise의 메소드들을 배워보겠습니다.

1. all 메소드
설명을 하기에 앞서 바로 코드를 보겠습니다.

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  });
지금 이 코드에는 서로 다른 3개의 URL로 리퀘스트를 보내는 fetch 함수들이 보입니다. URL을 자세히 보니 이전에 사용했던 직원 정보에 관한 학습용 URL이네요. 지금 1번, 2번, 3번 직원의 정보를 각각 요청하고 있죠?

그 다음 부분을 보면, Promise의 all이라는 메소드를 호출하고 있고, all 메소드의 아규먼트로는 배열 하나가 들어있습니다. 그 배열의 요소들은, 각 직원 정보를 요청하고 받아서 Deserialize까지 수행한 작업 성공 결과를 담고 있는 Promise 객체들인 p1, p2, p3 객체입니다.

이 all 메소드는 무슨 기능을 하는 걸까요? all 메소드도 then 메소드처럼 새로운 Promise 객체를 리턴하는데요. 
all 메소드는 이렇게 아규먼트로 들어온 배열 안에 있는 모든 Promise 객체가 pending 상태에서 fulfilled 상태가 될 때까지 기다립니다. 
그리고 모든 Promise 객체들이 fulfilled 상태가 되면, all 메소드가 리턴했던 Promise 객체는 fulfilled 상태가 되고, 
각 Promise 객체의 작업 성공 결과들로 이루어진 배열을, 그 작업 성공 결과로 갖게 됩니다.

이 코드를 직접 실행해보면,



이렇게 all 메소드가 리턴한 Promise 객체는,

(1) 각 개별 Promise 객체의 작업 성공 결과로 이루어진 배열을 
(2) 자신의 작업 성공 결과로 갖는다는 것을 알 수 있습니다.

배열의 각 요소로 각 직원 정보 객체가 잘 보이죠? 이렇게 all 메소드는 여러 Promise 객체의 작업 성공 결과를 기다렸다가 모두 한 번에 취합하기 위해서 사용합니다.

그런데 만약 p1~3 객체들 중 하나라도, rejected 상태가 되면 어떻게 될까요?

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learnnnnnn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  });
마지막 fetch 함수에 존재하지 않는 URL 주소를 적고 코드를 다시 실행해보겠습니다. 코드를 실행해보면



마지막 fetch 함수에서 문제가 발생해서 p3가 rejected 상태가 되면, 
all 메소드가 리턴한 Promise 객체는 p3 객체처럼 rejected 상태가 되고 동일한 작업 실패 정보를 갖게 됩니다. 
이렇게 all 메소드는 하나의 Promise 객체라도 rejected 상태가 되면, 전체 작업이 실패한 것으로 간주해야 할 때 사용합니다. 
그리고 이렇게 Promise 객체가 하나라도 rejected 상태가 되는 경우에 대비하려면 
이전에 배웠던 것처럼

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learnnnnnn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  })
  .catch((error) => {
    console.log(error);
  });
그냥 이렇게 catch 메소드를 붙여주면 됩니다. 어차피 all 메소드도 Promise 객체를 리턴하니까 특별히 새로울 건 없겠죠?

2. race 메소드
race 메소드도 all 메소드와 마찬가지로 여러 Promise 객체들이 있는 배열을 아규먼트로 받습니다. 그리고 race 메소드도 all 메소드처럼 Promise 객체를 리턴하는데요. 하지만 그 적용 원리가 다릅니다.
race 메소드가 리턴한 Promise 객체는 아규먼트로 들어온 배열의 여러 Promise 객체들 중에서 
가장 먼저 fulfilled 상태 또는 rejected 상태가 된 Promise 객체와 동일한 상태와 결과를 갖게 됩니다.

예를 들어 이런 코드가 있다고 할 때,

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Success'), 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail')), 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail2')), 4000);
});

Promise
  .race([p1, p2, p3])
  .then((result) => {
    console.log(result); // hello 출력
  })
  .catch((value) => {
    console.log(value);
  });
지금 race 메소드 안의 배열에 들어있는 Promise 객체들 중에서 무엇이 가장 빨리 fulfileld 또는 rejected 상태가 될까요? 
답은 1초 후에 fulfilled 상태가 되는 p1 객체입니다.
p1 객체는 1초 후에 fulfilled 상태가 되고, 그 작업 성공 결과로 문자열 Success를 가지게 되는데요. 
p2는 2초 후에, p3는 4초 후에 rejected 상태가 됩니다.

race 메소드가 리턴한 Promise 객체는 이 중에서 가장 빨리 상태 정보가 결정된 p1 객체와 동일한 상태와 결과를 가집니다. 
말그대로 race 메소드는 여러 Promise 객체들을 레이스(race, 경쟁)시켜서 가장 빨리 상태가 결정된 Promise 객체를 선택하는 메소드입니다. 
이 코드를 실행하면

ffjn3h9v7-Untitled 2.png

p1 객체의 작업 성공 결과였던 문자열 Success가 잘 출력됩니다.

만약 setTimeout에 넣었던 밀리세컨즈를 이렇게 바꾼다면

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Success'), 6000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail')), 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail2')), 4000);
});

Promise
  .race([p1, p2, p3])
  .then((result) => {
    console.log(result); // hello 출력
  })
  .catch((value) => {
    console.log(value);
  });
이번에는 p2가 p1보다 더 빨리 상태가 결정됩니다. 그럼 결국 race 메소드가 리턴한 Promise 객체는 p2처럼 rejected 상태가 되고 동일한 작업 실패 정보를 갖게 됩니다. 이 코드를 실행해보면

hcvsx469q-Untitled 3.png

Error 객체의 정보가 잘 출력되는 것을 알 수 있습니다. 


자, all 메소드와 race 메소드 잘 이해되시나요? 실무에서는 이렇게 여러 Promise 객체들을 한꺼번에 다뤄야할 때도 있습니다. 그럴 때 각 용도에 적합한 메소드를 사용하면 되는데요.  
all 메소드나 race 메소드 말고 allSettled, any라는 메소드도 있습니다. 
이것들도 all, race 메소드처럼 Promise 객체 배열을 아규먼트로 받고 Promise 객체를 리턴하는데요.

이것들도 간단하게 설명하겠습니다.

각 메소드가 리턴한 Promise 객체가 A라고 할 때,

allSettled 메소드 : 배열 내의 모든 Promise 객체가 fulfilled 또는 rejected 상태가 되기까지 기다리고, pending 상태의 Promise 객체가 하나도 없게 되면, A의 상태값은 fulfilled 상태가 되고 그 작업 성공 결과로, 하나의 배열을 갖게 됩니다. 
이 배열에는 아규먼트로 받았던 배열 내의 각 promise 객체의

(1) 최종 상태를 status 프로퍼티, 
(2) 그 작업 성공 결과는 value 프로퍼티, 
(3) 그 작업 실패 정보는 reason 프로퍼티

에 담은 객체들이 요소로 존재합니다. 
이런 식으로 말이죠.

[
  {status: "fulfilled", value: 1},
  {status: "fulfilled", value: 2},
  {status: "fulfilled", value: 3},
  {status: "rejected",  reason: Error: an error}
]
참고로 fulfilled 상태와 rejected 상태를 묶어서 settled 상태라고 하는데요. allSettled 메소드는 말 그대로 배열 속 Promise 객체들이 settled 상태가 되기만 하면 되는 겁니다. 이에 반해 위에서 배운 all 메소드는 모든 Promise 객체들이 fulfilled 상태가 되기를 기다리는 거구요.

any 메소드 : 여러 Promise 객체들 중에서 가장 먼저 fulfilled 상태가 된 Promise 객체의 상태와 결과가 A에도 똑같이 반영됩니다. 만약 모든 Promise 객체가 rejected 상태가 되어버리면 AggregateError라고 하는 에러를 작업 실패 정보로 갖고 rejected 상태가 됩니다. any라는 단어의 뜻처럼 배열 속의 Promise 객체 중 단 하나라도 fulfilled 상태가 되면 되는 겁니다.

자, 각 메소드의 이름과 그 성질을 매칭해서 기억해보세요. 나중에 혹시 정확한 성질이 기억나지 않더라도 다시 찾아보면 되니까 지금 잘 이해해두는 것이 중요합니다. 참고로 어떤 메소드든 결국 하나의 Promise 객체를 리턴하기 때문에 그 리턴 결과를 Promise Chain에서 자유롭게 사용할 수 있다는 점을 기억해두세요.

혹시 각 메소드들의 사용법을 좀더 자세히 보고 싶은 분들은 아래 링크를 참조하세요.

# all 메소드 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
# race 메소드 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
# allSettled 메소드 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled
# any 메소드 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any


# axios
우리는 이때까지 fetch 함수를 사용해서 Promise 공부를 했습니다. 여기서 잠깐 챕터 1에서 배웠던 [그밖에 알아야 할 내용들] 노트의 내용 중 1. Ajax 부분을 다시 읽고 와봅시다.

여기서 저는 fetch 함수가 Ajax 통신을 하는 함수라고 했는데요. 그런데 오늘날 개발 실무에서는 이 fetch 함수 말고도 Ajax 통신을 할 수 있는 방법이 존재한다고 했죠? 그것은 바로 axios 라고 하는 외부 패키지를 사용하는 것입니다. 잠깐 간단하게 axios 패키지를 사용한 코드를 보겠습니다.

axios
  .get('https://jsonplaceholder.typicode.com/users')
  .then((response) => {
    console.log(response);
  })
  .catch((error) => {
    console.log(error);
  });
이 코드는 axios 패키지에서 제공하는 axios 객체를 사용해서 GET 리퀘스트를 보내고 그 리스폰스를 받는 코드인데요. 
자세히 보면 지금 코드에서 axios.get이라고 쓰여 있는 부분만 fetch로 바꾸면 fetch 함수와 사용법이 비슷하지 않나요?

네, 그렇습니다. 사실 axios 객체에서 리퀘스트를 보내는 많은 메소드들이 fetch 함수처럼 Promise 객체를 리턴합니다. 
그래서 fetch 함수의 사용법과 비슷한 점이 많은데요.

다만, axios 객체에는 fetch 함수에는 없는 다음과 같은 몇 가지 기능 및 장점들이 있습니다.

모든 리퀘스트, 리스폰스에 대한 공통 설정 및 공통된 전처리 함수 삽입 가능
serialization, deserialization을 자동으로 수행
특정 리퀘스트에 대해 얼마나 오랫동안 리스폰스가 오지 않으면 리퀘스트를 취소할지 설정 가능(request timeout)
업로드 시 진행 상태 정보를 얻을 수 있음
리퀘스트 취소 기능 지원
이 밖에도 다양한 장점들이 있지만 이 노트는 axios의 사용법 자체를 설명하는 노트는 아니기 때문에 생략하겠습니다. 
혹시 axios를 배워보고 싶은 분들은 관련 GitHub  페이지를 참조하세요. 
페이지를 자세히 읽어보면 fetch 함수와 유사한 작동 원리, 개발 실무에 특화된 추가 기능 등을 볼 수 있을 겁니다.

axios가 이렇게 fetch에 비해 다양한 기능을 지원하는 것은 맞지만 단점도 있습니다. 바로 별도의 다운로드가 필요한 패키지라는 점이죠. 
fetch 함수는 웹 브라우저에서 바로 지원되는 함수이기 때문에 별도로 패키지를 다운로드받지 않아도 되지만, 
axios는 별도로 패키지를 다운로드해줘야 합니다.

그래서 axios에서 제공하는 추가 기능이 필요한 경우에는 axios를 쓰고, 
그런 기능이 필요하지 않고 별도의 패키지 다운로드를 원하지 않는 경우에는 fetch 함수를 사용합니다.

실무에서는 fetch 이외에 axios도 많이 쓴다는 점, 
그리고 axios 또한 리퀘스트를 보내는 주요 메소드들이 Promise 객체를 리턴한다는 점을 기억하세요.

이번 챕터에서 Promise 객체를 잘 공부했다면, axios 사용법도 쉽게 익힐 수 있을 겁니다.


# async/await을 활용한 세련된 비동기 코드
# async/await이란?
# asynchronous
// await 는 fulfilled 될 때까지 기다린다. 그리고 fulfilled 된 후 다음 줄이 실행된다.

fetch('https://jsonplaceholder. typicode. com/users')
  .then ( (response) => response. text() )
  .then((result) => { console. log(result); });

async function fetchAndPrint() {
const response = await fetch('https://jsonplaceholder.typicode.com/users');
const result = await response. text();
console.log(result);
}

fetchAndPrint();

# async/await 구문의 실행 원리
// await는 async안에서 실행된다.

async function fetchAndPrint() {
console.log(2);
const response = await fetch('https://jsonplaceholder.typicode.com/users');
console.log(7);
const result = await response. text();
console.log(result);
}

console.log(1);
fetchAndPrint();
console.log(3);
console.log(4);
console.log(5);
console.log(6);


# 동기 실행 코드처럼 생긴 비동기 실행 코드
이전 영상에서는 async 함수 안의 코드들이 어떤 식으로 실행되는지 배웠습니다. 
이때 함수 안에 존재하는 await이 코드 실행 흐름에 변화를 주는 중요한 역할을 했는데요. 
코드를 다시 살펴봅시다.

/* fetch('https://www.google.com')
    .then((response) => response.text())
    .then((result) => { console.log(result); }); */

async function fetchAndPrint() {
  console.log(2);
  const response = await fetch('https://jsonplaceholder.typicode.com/users');
  console.log(7);
  const result = await response.text();
  console.log(result);
}

console.log(1);
fetchAndPrint();
console.log(3);
console.log(4);
console.log(5);
console.log(6);

사실 fetchAndPrint 함수를 언뜻 보면, 비동기 실행 함수처럼 생기지 않았습니다. 오히려 코드가 등장하는 순서대로 실행될 것처럼 생겼죠. 즉, 동기 실행되는 코드처럼 생겼는데요. 그런데 이건 의도된 것입니다.

왜냐하면 async/await 구문 자체가 기존의 Promise 객체를 사용하는 코드(Promise Chaining)를

(1) 개발자가 더 편하게 작성할 수 있도록 하고
(2) 코드의 가독성을 높이기 위해서

도입된 일종의 Syntactic sugar(기존 문법을 더 편하게 사용할 수 있도록 하는 문법적 장치)에 해당하기 때문입니다.

사실 우리에게는 이때까지 배웠던 것처럼

전통적인 형식의 비동기 실행 함수에 콜백을 바로 전달하거나,
Promise 객체 뒤에 .then 메소드를 붙이는 것보다는
그냥 코드를 차례대로 써나가는 것이 더 익숙한 방식입니다. 
그리고 바로 async/await 구문이 Promise 객체를 우리에게 이미 익숙한 동기 실행 코드 방식으로 다룰 수 있게 해주는 문법인 겁니다.

하지만 동기 실행 코드처럼 보인다고 해서 정말로 동기 실행되는 것은 아닙니다. 만약 위의 코드를 그냥 보이는 대로만 해석한다면, 그 결과가 아래처럼 출력될 것으로 생각하기 쉽습니다.

1
2
7
[리스폰스의 내용]
3
4
5
6
하지만 코드에서 async/await이 보인다면 사실 비동기 실행되는 코드가 있다는 걸 반드시 기억해야 하는데요. 
사실 위 코드의 실제 출력 결과는

1
2
3
4
5
6
7
[리스폰스의 내용]
이것이었죠? 만약 async/await 구문의 실행 원리가 아직도 이해되지 않는 분은 이 코드의 원래 모습을 떠올려보세요.

사실 위 코드의 원래 모습은 아래와 같다고 할 수 있습니다.

/* fetch('https://www.google.com')
    .then((response) => response.text())
    .then((result) => { console.log(result); }); */

function fetchAndPrint() {
  console.log(2);
  fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => {
      console.log(7);
      return response.text();
    })
    .then((result) => { console.log(result); });
}

console.log(1);
fetchAndPrint();
console.log(3);
console.log(4);
console.log(5);
console.log(6);

지금 함수 이름 앞에 있던 async 키워드를 삭제했고, await이 있던 코드들은 Promise Chaining을 하는 코드로 바꿨습니다. 이 코드를 실행해보면 역시 이전 영상과 같은 결과가 출력되는데요.



원래 모습이었을 코드를 보니까, 이제 왜 async/await가 있는 코드가 제가 말한 것처럼 실행되는지 이해되시죠?

이번 노트에서 배운 것처럼 async/await 구문을 사용하면,

(1) Promise 객체를 사용할 때, then 메소드 등을 사용하지 않고도 
(2) 마치 동기 실행 코드처럼 코드를 훨씬 더 간단하고 편하게 작성할 수 있습니다. 코드를 읽기에도 훨씬 편하구요.

하지만 이런 편안함을 얻은 대신 한 가지 주의해야 할 점이 있습니다. 바로 이 async/await 구문 중에 비동기 실행되는 부분이 있다는 사실에 유의하며 코드를 작성 및 해석해야한다는 것입니다. 아무리 async/await 구문이 동기 실행 코드처럼 생겼다고 해도 그 속에는 Promise 객체가 존재함을 절대 잊지 마세요.

자, async/await 구문의 실행 원리를 다시 한번 정리할게요.

async 함수 안의 코드가 실행되다가 await을 만나면, 일단 await 뒤의 코드가 실행되고, 코드의 실행 흐름이 async 함수 바깥으로 나가서 나머지 코드를 다 실행합니다. 물론 함수 바깥에 더 이상 실행할 코드가 없을 수도 있습니다. 
어느 경우든 그 이후로는, await 뒤에 있던 Promise 객체가 fulfilled 상태가 되기를 기다립니다. 그리고 기다리던 Promise 객체가 fulfilled 상태가 되면 await이 Promise 객체의 작업 성공 결과를 리턴하는 겁니다.

그런데 이때까지 Promise 객체가 fulfilled 상태가 되기만을 기다렸는데, await 뒤의 Promise 객체가 rejected 상태가 될 수도 있겠죠? 이런 경우는 어떻게 대비해야 하는지 다음 영상에서 배워봅시다.

# 세련된 비동기 실행 코드 작성해보기
fetch("https://jsonplaceholder.typicode.com/users")
  .then((response) => response.json())
  .then((users) => {
    const lastUser = users[users.length - 1];
    return lastUser.id;
  })
  .then((id) => fetch(`https://jsonplaceholder.typicode.com/posts?userId=${id}`))
  .then((response) => response.json())
  .then((posts) => {
    const lastPost = posts[posts.length - 1];
    console.log(lastPost);
  });

/* async function getTheLastPostOfTheLastUser() {

}

getTheLastPostOfTheLastUser().then((lastPost) => {
  console.log(lastPost);
}); */


# async / await 로 변환
async function getTheLastPostOfTheLastUser() {
  const usersJSON = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await usersJSON.json();
  const lastUser = users[users.length - 1];
  const { id } = lastUser;
  const postsJSON = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${id}`);
  const posts = await postsJSON.json();
  const lastPost = posts[posts.length - 1];
  return lastPost;
}

getTheLastPostOfTheLastUser().then((lastPost) => {
  console.log(lastPost);
});

여러분도 모범 답안처럼 잘 작성하셨나요? 
변수명 등은 여러분이 자유롭게 지으셔도 되지만 Promise 객체를 리턴하는 코드 앞에 await을 붙였는지 꼭 확인해보세요.

then 메소드 등을 사용해서 하던 기존의 Promise Chaining 코드를 async/await 구문 기반의 코드로 변환하면 우리에게 더 익숙한 동기 실행 코드의 형식으로 가독성 높은 코드를 작성할 수 있습니다. 
물론 이 경우에도 async/await 코드가 실제로는 비동기 실행된다는 점을 잊어서는 안 됩니다.


# 실습 설명
async가 앞에 붙은 함수는 그 안에 비동기적으로 실행될 내용이 있다는 뜻이고, 그 부분은 바로 함수 내부에서 await이 붙은 부분입니다. 
async 함수 안의 await은 그 뒤의 코드를 실행해놓고, 코드의 실행 흐름을 함수가 호출된 외부로 바꿉니다. 
외부의 코드를 모두 실행하고 나서는 await 뒤의 Promise 객체의 상태가 fulfilled 상태가 될 때까지 기다렸다가(또는 이미 fulfilled 상태가 된 Promise 객체에 대해서) 그 작업 성공 결과를 추출해서 리턴해요.

지금 코드잇 실행기에 있는 코드를 실행해서 각 경우에 어떤 결과가 출력되는지 확인해 봅시다.

셀프 채점
다음 항목들이 제대로 구현되었는지 확인해 보세요!

실행 버튼을 눌러서 await이 붙은 순서대로 그 결과가 출력되는 것을 확인했습니다.

해설 보기

해설
const p1 = fetch('https://jsonplaceholder.typicode.com/users?id=1')
  .then((response) => response.text());
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => { resolve('hello'); }, 2000);
});
const p3 = Promise.resolve('Success');
// const p4 = Promise.reject(new Error('Fail'));

async function test() {
  console.log(await p1);
  console.log(await p2);
  console.log(await p3);
  // console.log(await p4);
}

console.log('----Start----');
test();
console.log('-----End----');
실행기의 코드를 실행해서 잘 확인하셨나요? async/await 구문의 실행 원리를 잘 이해했다면 왜 Start 다음에 바로 End가 출력됐는지 이해하셨을 겁니다. 각 await은 각 Promise 객체의 작업 실행 결과를 아래 경우에 따라 추출해서 리턴합니다.

(1) fetch 함수의 리퀘스트에 대한 리스폰스가 왔을 때
(2) 2초(2000밀리세컨즈)가 지났을 때
(3) 즉시

이 코드를 실행기가 아닌 개발자 도구에서 실행해 보면 좀 더 실감나게 출력 시점을 체감하실 수 있을 겁니다.

그런데 지금 가장 마지막의 console.log(await p4); 부분을 보면
p4는 rejected 상태의 Promise 객체입니다. 지금까지 우리는 fulfilled 상태의 Promise 객체에 대해서만 다뤘죠. 주석 처리되어 있는 부분을 모두 주석 해제하고, 코드를 개발자 도구로 복사 붙여넣기하고 실행해보면 아래와 같은 결과가 출력됩니다.



지금 출력 결과를 보니까, 마지막에 빨간 줄로 에러 표시가 된 것을 알 수 있습니다. 실행기에서 바로 실행해 봐도 에러가 뜬다는 걸 확인할 수 있을 겁니다. 그 이유는 바로 rejected 상태의 Promise 객체를 처리하지 않고 그냥 두었기 때문이예요. async/await 구문에서 rejected 상태의 Promise 객체는 어떤 식으로 다뤄야하는지 다음 영상에서 배워 봅시다.


# catch문과 finally문
async function fetchAndPrint() {
try {
const response = await fetch('https://jsonplaceholder.typicode.com/users');
const result = await response. text();
console.log(result);
} catch (error) {
console.log(error);
} finally {
console.log('exit');
}
}

fetchAndPrint();


# async/await 퀴즈
async function test1() {
  const result = await Promise.resolve('success');
  console.log(result);
}

async function test2() {
  try {
    const p = new Promise((resolve, reject) => {
      setTimeout(() => { resolve('last'); }, 3000);
    });
    const result = await p;
    console.log(result);
  } catch (e) {
    console.log(e);
  }
}

async function test3() {
  try {
    const result = await Promise.reject('fail');
    console.log(result);
  } catch (e) {
    console.log(e);
  }
}

test1();
console.log('JavaScript');
test2();
console.log('Programming');
test3();


# JavaScript - Programming - success - fail - last
퀴즈 해설

# async 함수 안의 코드가 실행되다가 await을 만나면 await 뒤의 코드를 실행한 뒤, async 함수 외부로 코드 실행 흐름이 옮겨진다는 사실은 배웠습니다. 그런데 이 코드에서는 이전의 Promise 객체가 fulfilled 상태가 된 것을 미처 확인하기도 전에 다음 함수의 await을 만나버리죠? 이렇게 미처 그 fulfilled 상태를 확인하지 못한 여러 Promise 객체들은 나중에 그것이 fulfilled 또는 rejected 상태가 된 순서대로 그 await 문이 작업 성공 결과를 추출하거나 catch 문으로 실행 흐름이 옮겨진다고 생각하면 됩니다. 그래서 지금 setTimeout 함수를 호출해서 가장 늦게 그 상태가 fulfilled로 확정되는 p 객체의 작업 성공 결과인 문자열 last가 가장 마지막에 출력되는 겁니다. 

# Promise Chaining 기반의 코드
async function test1() {
  Promise.resolve('success')
    .then((result) => {
      console.log(result);
    });
}

async function test2() {
  const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('last'); }, 3000);
  });
  p
    .then((result) => {
      console.log(result);
    })
    .catch((e) => {
      console.log(e);
    });
}

async function test3() {
  Promise.reject('fail')
    .then((result) => {
      console.log(result);
    })
    .catch((e) => {
      console.log(e);
    });
}

test1();
console.log('JavaScript');
test2();
console.log('Programming');
test3();



# try, catch, finally문의 위치
async function showQuiz() {
  try {
    const response = await fetch('https://learn.codeit.kr/api/quiz');
    const test = await response.json();
    const yourAnswer = prompt(test.quiz);
    if (yourAnswer.toLowerCase() === test.answer) {
      alert(`Good Job, ${test.explanation} => Lets learn more with Codeit!`);
    } else {
      throw new Error('wrong');
    }
  } catch (error) {
    if (error.message === 'wrong') {
      alert('You need to learn JavaScript with Codeit!');
    } else {
      alert('Error');
    }
  } finally {
    window.open('https://codeit.kr', '_blank');
  }
}

showQuiz();


# 실습 설명

자, 코드의 빈 부분을 하나씩 채워볼까요? 어디부터 먼저 채워야할까요? 일단 Promise 객체를 리턴하는 fetch() 함수 앞이 비워져있는 걸로 보아서 그 앞에 await을 붙여주면 될 것 같네요. 그리고 그 밑의 response.text()도 Promise 객체를 리턴하니까 await을 붙여야겠죠?

그런데 await은 async  함수 안에서만 쓸 수 있으니까 함수 이름 앞에 async를 붙여줘야 합니다. 
그럼 전체 코드가 이런 상태가 되죠?

async function showQuiz() {
  /* */ {
    const response = await fetch('https://learn.codeit.kr/api/quiz');
    const test = await response.json();
    const yourAnswer = prompt(test.quiz);
    if (yourAnswer.toLowerCase() === test.answer) {
      alert(`Good Job, ${test.explanation} => Lets learn more with Codeit!`);
    } else {
      throw new Error('wrong');
    }
  } /* */ (error) {
    if (error.message === 'wrong') {
      alert('You need to learn JS with Codeit!');
    } else {
      alert('Error');
    }
  } /* */ {
    window.open('https://codeit.kr', '_blank');
  }
}

showQuiz()
여기서부터는 쉽습니다. 첫 번째 블록이 정상적인 처리를 담당하는 try문, 두 번째 블록이 에러가 발생했거나, rejected 상태의 Promise 객체가 생겼을 때에 대비한 catch문, 마지막 세 번째 블록은 어느 상황이든지 마지막에 항상 특정 코드를 실행하는 finally문입니다. 참고로 catch문의 경우 Promise 객체가 rejected 상태가 된 경우에도 대비할 수 있지만 원래 우리가 알던 try ~ catch문의 역할처럼 Promise 객체와 상관없는 지점에서 에러가 생겨도 대비할 수 있게 해줍니다. 참고로 알아두세요.

현재의 코드는 async/await 문을 사용할 때, 전형적으로 사용되는 코드의 형식입니다. 익숙해지기 위해 노력해 봅시다.


# async 함수가 리턴하는 Promise 객체

async 함수는 그 안에서 리턴하는 값에 따라 그에 맞는 Promise 객체를 리턴합니다. 
그런데 이때 적용되는 규칙은 우리가 이전에 [then 메소드 완벽하게 이해하기]노트에서 봤던 규칙들과 유사합니다.

async 함수 안에서 리턴하는 값의 종류에 따라 결국 어떤 Promise 객체를 리턴하게 되는지 아래와 같이 경우를 나누어서 살펴봅시다.

1. 어떤 값을 리턴하는 경우
(1) Promise 객체를 리턴하는 경우
async 함수 안에서 Promise 객체를 리턴하는 경우에는 해당 Promise 객체와 동일한 상태와 작업 성공 결과(또는 작업 실패 정보)를 가진 Promise 객체를 리턴합니다.(그냥 해당 Promise 객체를 리턴한다고 봐도 괜찮습니다.)

async function fetchAndPrint() {
  return new Promise((resolve, reject)=> {
    setTimeout(() => { resolve('abc'); }, 4000);
  });
}

fetchAndPrint();


이렇게 pending 상태의 Promise 객체를 리턴하기도 하고(리턴된 Promise 객체는 약 4초 후에 fulfilled 상태가 되겠죠?

async function fetchAndPrint() {
  return Promise.resolve('Success');
}

fetchAndPrint();


이미 fulfilled 상태인 Promise 객체나

async function fetchAndPrint() {
  return Promise.reject(new Error('Fail'));
}

fetchAndPrint();


이미 rejected 상태인 Promise 객체를 리턴하는 경우 전부 다 해당합니다. (위 이미지에서는 rejected 상태의 Promise 객체를 따로 처리해주지 않았기 때문에 에러가 발생한 겁니다)

(2) Promise 객체 이외의 값을 리턴하는 경우
async 함수 내부에서 Promise 객체 이외에 숫자나 문자열, 일반 객체 등을 리턴하는 경우에는, fulfilled 상태이면서, 리턴된 값을 작업 성공 결과로 가진 Promise 객체를 리턴합니다.

async function fetchAndPrint() {
  return 3;
}

fetchAndPrint();


이런 코드나

async function fetchAndPrint() {
  return 'Hello';
}

fetchAndPrint();


이런 코드,

async function fetchAndPrint() {
  const member = {
    name: 'Jerry',
    email: 'jerry@codeitmall.kr',
    department: 'sales',
  };

  return member;
}

fetchAndPrint();


이런 코드들 모두 여기에 해당합니다.

2. 아무 값도 리턴하지 않는 경우
async function fetchAndPrint() {
  console.log('Hello Programming!');
}

fetchAndPrint();
이렇게 함수에서 아무런 값도 리턴하지 않으면 자바스크립트에서 어떻게 간주한다고 했죠? undefined를 리턴한 것으로 간주한다고 했는데요. 따라서



이 경우에는 fulfilled 상태이면서, undefined를 작업 성공 결과로 가진 Promise 객체가 리턴됩니다.

3. async 함수 내부에서 에러가 발생했을 때
async function fetchAndPrint() {
  throw new Error('Fail');
}

fetchAndPrint();


async 함수 안에서 에러가 발생하면, rejected 상태이면서, 해당 에러 객체를 작업 실패 정보로 가진 Promise 객체가 리턴됩니다.

자, 이때까지 async 함수 안에서 리턴하는 값에 따라, async 함수가 결국 어떤 Promise 객체를 리턴하는지 배웠는데요. 이전에 [then 메소드 완벽하게 이해하기]에서 배운 내용과 비슷해서 별로 어렵지 않죠?

이렇게 async 함수가 결국 Promise 객체를 리턴한다는 사실은 아주 중요합니다. 왜냐하면 이 말은 곧 async 함수 안에서 다른 async 함수를 가져다가 쓸 수 있다는 뜻이기 때문입니다. 이 말이 무슨 뜻인지 다음 영상에서 알아봅시다.

https://www.codeit.kr/topics/basics-of-js-web-dev/lessons/4374



# async 함수 안의 async 함수
const applyPrivacyRule = async function (users) {
const resultWithRuleApplied = users.map((user) => {
const keys = Object.keys(user);
const userWithoutPrivateInfo = {};
keys.forEach ( (key) => {
if (key !== 'address' && key !== 'phone') {
userWithoutPrivateInfo [key] = user[key];
}
});

return userWithoutPrivateInfo;
});

const p = new Promise((resolve, reject) => {
setTimeout(() => { resolve(resultWithRuleApplied); }, 2000);
});
return p;
};

async function getUsers() {
try {
const response = await fetch('https://jsonplaceholder.typicode.com/users');
const result = await response.text();
const users = JSON.parse(result);
const resultWithPrivacyRuleApplied = await applyPrivacyRule(users);
return resultWithPrivacyRuleApplied;
} catch (error) {
console.log(error);
} finally {
console.log('exit');
}
}


# async를 붙이는 위치

자바스크립트에서 함수를 표현하는 방법에는 여러 가지가 있는데요.

1. Function Declaration(함수 선언식),
2. Function Expression(함수 표현식),
3. Arrow Function(화살표 함수)
등이 있습니다. 그리고

Function Expression의 경우에는

2-1. 함수에 이름이 붙어있는 Named Function Expression과 
2-2. 함수에 이름이 없는 Anonymous Function Expression으로 나눌 수 있고,

Arrow Function의 경우 함수 내부의 내용에 따라 더 축약(shorten)해서 나타낼 수도 있는데요.

각각의 경우에 async 키워드를 어떻게 붙이는지 살펴봅시다.

// 1) Function Declaration
async function example1(a, b) {
  return a + b;
}

// 2-1) Function Expression(Named)
const example2_1= async function add(a, b) {
  return a + b;
};

// 2-2) Function Expression(Anonymous)
const example2_2 = async function(a, b) {
  return a + b;
};

// 3-1) Arrow Function
const example3_1 = async (a, b) => {
  return a + b;
};

// 3-2) Arrow Function(shortened)
const example3_2 = async (a, b) => a + b;
각 함수 표현 방식에서 async는 이런 식으로 붙이면 되는데요. 각각의 경우에 async를 어디에 붙였는지 기억해두세요. 
참고로, 자바스크립트에는 함수를 정의하면서 동시에 실행하는 즉시실행함수(Immediately-invoked function expression, IIFE)라는 개념도 있는데요.

(function print(sentence) {
  console.log(sentence);
  return sentence;
}('I love JavaScript!'));

(function (a, b) {
  return a + b;
}(1, 2));

((a, b) => {
  return a + b; 
})(1, 2);

((a, b) => a + b)(1, 2);
이런 식으로 함수를 바로 정의와 동시에 실행하는 것을 의미합니다. 보통 초기화 코드 등에서 함수를 단 한 번만 실행하기 위한 목적으로 이 즉시실행함수를 사용하는데요. 이런 경우에도 async를 이렇게 붙일 수 있습니다.

(async function print(sentence) {
  console.log(sentence);
  return sentence;
}('I love JavaScript!'));

(async function (a, b) {
  return a + b;
}(1, 2));

(async (a, b) => {
  return a + b; 
})(1, 2);

(async (a, b) => a + b)(1, 2);
앞으로 여러분이 어떤 식으로 함수를 나타내더라도 어디에 async를 붙여야하는지 아시겠죠?


# 개선된 점심 메뉴 랜덤 선택기 코드

# 실습 설명
우리는 이전에 챕터 3의 [점심 메뉴 랜덤 선택기] 과제에서 랜덤으로 점심 메뉴를 골라주는 코드를 작성한 적이 있습니다. 그 때는 Promise 객체의 then 메소드로 Promise Chaining을 사용해서 코드를 작성했죠.

하지만 이제 우리는 async/await을 배웠으니까 기존의 코드를 async/await 구문 기반으로 바꾸려고 합니다. 템플릿에 있는 코드를 async/await을 사용하는 코드로 바꿔보고 실행해 보세요. 같은 동작을 하는 코드지만 코드의 가독성이 더 좋아지는 것을 확인할 수 있을 겁니다.

# 모범 답안
async function pick(menus) {
  console.log('Pick random menu!');
  const p = new Promise((resolve, reject) => {
    if (menus.length === 0) {
      reject(new Error('Need Candidates'));
    } else {
      setTimeout(() => {
        const randomIdx = Math.floor(Math.random() * menus.length);
        const selectedMenu = menus[randomIdx];
        resolve(selectedMenu);
      }, 1000);
    }
  });

  return p;
}

async function getRandomMenu() {
  console.log('---Please wait!---');
  try {
    const response = await fetch('https://learn.codeit.kr/api/menus');
    const menus = await response.json();
    const menu = await pick(menus);
    console.log(`Todays lunch is ${menu.name}~`);
  } catch (error) {
    console.log(error.message);
  } finally {
    console.log('Random Menu candidates change everyday');
  }
}

getRandomMenu();

#
기존의 코드는 이런 식으로 바꿔볼 수 있습니다. 여러분은 어떤 방식으로 바꾸셨나요?

기존 코드에 존재하는 각 함수의 이름 앞에 async를 붙이고, 함수의 내부 코드에 등장하는 Promise 객체 앞에 await을 붙인다면 어렵지 않게 코드를 수정할 수 있습니다. 그리고 마지막 부분에 있던 Promise Chain 부분을 없애고, getRandomMenu() 함수를 호출하기만 하면 되겠죠?

Promise 객체의 then 메소드를 사용해서 Promise Chaining을 하던 코드를 이렇게 async/await을 쓰는 방식으로 바꾸면 훨씬 더 가독성이 좋은 코드를 작성할 수 있습니다. 그리고 이렇게 쓰는 것이 요즘의 트렌드이기도 하구요. 하지만 이렇게 코드를 바꾸더라도 그 안에 숨어있는 Promise 객체의 존재와 의미를 절대 잊지는 말아 주세요!


# async 함수를 작성할 때 주의해야할 성능 문제(심화)
이때까지 async 함수에 관해서 많은 내용을 배웠는데요. 그런데 async 함수의 내부 코드를 작성할 때는 특히 주의해야 하는 경우가 있습니다. 잠깐 아래의 코드를 볼까요?

async function getResponses(urls) {
  for(const url of urls){
    const response = await fetch(url);
    console.log(await response.text());
  }
}
이 getResponses 함수는 urls라는 파라미터로, 여러 개의 URL들이 있는 배열을 받아서, 순서대로 각 URL에 리퀘스트를 보내고, 그 리스폰스의 내용을 출력하는 함수입니다. 그런데 이 코드는 하나의 문제점이 있습니다. 그건 바로 이전 URL에 리퀘스트를 보내고 리스폰스를 받아서 출력하고 나서야, 다음 URL에 대한 리퀘스트를 보낼 수 있다는 점입니다. 즉, 순차적인 작업 처리를 한다는 점인데요. 왜냐하면 이전 URL에 대해서 await 문이 붙은 Promise 객체가 fulfilled 상태가 될 때까지는 그 다음 URL에 대한 작업들이 시작될 수 없기 때문입니다.

만약 순차적인 처리를 해야 하는 경우라면 이 코드를 사용하는 게 맞겠지만, 만약 모든 리스폰스의 내용이 잘 출력되기만 하면 되고, 그 순서는 상관없는 경우라면 어떨까요? 이 코드는 성능 관점에서 아쉬운 점이 있는 코드입니다.

만약 리스폰스의 내용의 순서가 중요하지 않은 경우라면 현재 코드를 이렇게 바꿔볼 수 있는데요.

async function fetchUrls(urls){
  for(const url of urls){
    (async () => { // 추가된 부분!
      const response = await fetch(url);
      console.log(await response.text());
    })(); // 추가된 부분!
  }
}
지금 각 url에 리퀘스트를 보내고 리스폰스를 받는 코드를, 별도의 즉시실행되는 async 함수로 감싸줬는데요. 즉시실행함수는 정의와 동시에 실행되는 함수라고 [async를 붙이는 위치] 노트에서 배웠죠?

이렇게 코드를 고치면 일단 각 URL에 대해서 fetch 함수를 실행해서 리퀘스트를 보내는 것을 순서대로 바로 실행해버립니다. 이전 코드처럼 이전 URL에 대한 리스폰스가 오기까지를 기다렸다가 다음 URL에 리퀘스트를 보내는 게 아니라요. 이렇게 코드를 쓰면 일단 모든 URL에 대한 리퀘스트를 쭉 보내버리고, 먼저 리스폰스가 오는 순서대로 그 내용이 출력되죠.

리스폰스의 순서를 보장하지 않아도 되는 경우에는 이 코드가 훨씬 성능이 좋겠죠?

async 함수 안에서는 무언가를 반복 처리하는 코드를 쓸 때 유의해야 합니다. 왜냐하면 의도치 않게 순차 처리를 수행하는 비효율적인 코드를 짜는 실수를 하게 되기 쉽기 때문이죠. 만약 순차적인 처리가 필요한 경우가 아니라면 방금 본 것처럼 각 작업을 다시 async 함수로 묶어주면 된다는 사실, 기억해두세요!

이번 레슨은 어땠나요?


# 비동기 실행 관련 문법 총정리
이때까지 비동기 실행에 관해 배운 내용들을 정리해봅시다. 일단 비동기 실행의 의미에 대해서 정리해봅시다. 사실 비동기 실행의 정의는 아래와 같이 다양한 방식으로 표현될 수 있습니다.

특정 작업이 시작되고, 그 작업이 모두 완료되기 전에 바로 다음 코드가 실행되는 방식의 실행, 나머지 작업은 나중에 콜백을 통해 수행되는 방식의 실행
특정 처리를 나중으로 미루는 방식의 실행
콜백을 등록해두고, 추후에 특정 조건이 만족되면 그 콜백으로 나머지 작업을 수행하는 방식의 실행
이렇게 다양한 표현으로 그 정의를 써볼 수 있는데요. 특정 처리를 담당하는 존재(콜백)의 실행을 나중으로 미룬다는 점만 잘 기억하시면 딱히 어려울 게 없습니다.

이제 이때까지 배웠던, 비동기 실행 관련 문법 3가지인

(1) 파라미터로 바로 콜백을 전달하는 형태의 전통적인 비동기 실행 함수
(2) Promise
(3) async/await

에 대해 정리하겠습니다.

1. 파라미터로 바로 콜백을 전달하는 형태의 전통적인 비동기 실행 함수
setTimeout, setInterval 함수, DOM 객체의 addEventListener 메소드 등이 여기에 해당했습니다.

setTimeout(() => {
  console.log('asynchronously executed');
}, 2000);

button.addEventListener('click', (event) => { console.log('You Clicked'); });
이런 방식으로 함수의 파라미터로 콜백을 바로 집어넣는 코드들을 봤었죠?

이렇게 함수의 파라미터로 콜백을 바로 전달하는 방식은 여전히 많은 경우에 쓰이고 있지만, 
여러 비동기 작업의 순차적인(sequential) 처리가 필요한 경우에 이런 함수들로 코드를 작성하면,

fs.readFile('file1.txt', 'utf8', (error1, data1) => {
  if (error1) {
    console.log(error1);
  } else {
    console.log(data1);
    fs.readFile('file2.txt', 'utf8', (error2, data2) => {
      if (error2) {
        console.log(error2);
      } else {
        console.log(data2);
        fs.readFile('file3.txt', 'utf8', (error3, data3) => {
          if (error3) {
            console.log(error3);
          } else {
            console.log(data3);
          }
        });
      }
    });
  }
});
위와 같이 코드의 가독성이 급격하게 떨어지는 콜백 헬(callback hell) 문제가 발생할 가능성이 높다고 했습니다.

2. Promise
fetch('https://www.google.com')
  .then((response) => response.text())
  .then((result) => { console.log(result); })
  .catch((error) => { console.log(error); })
  .finally(() => { console.log('exit'); });
Promise 객체를 사용하면 콜백 헬 문제를 방지하면서, 여러 비동기 작업을 순차적으로 처리할 수 있다고 배웠습니다.

그리고 기존의 1.과 같은 전통적인 비동기 실행 함수들 중에서도 그 콜백이 단 한 번만 실행되는 함수들은

function readFile_promisified(filename) {
  const p = new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (error, data) => {
      if (error) {
        reject(error); // 에러 발생 시 -> rejected
      } else {
        resolve(data); // 파일 내용 읽기 완료 -> fulfilled
      }
    });
  });
  return p;
}
이런 식으로 Promisify해서 콜백 헬의 가능성을 없애고, Promise Chain 안에서 그 콜백의 리턴값을 사용할 수 있다는 것도 배웠었죠?

그리고 rejected 상태의 Promise 객체에 대비하기 위한 catch 메소드, 어느 상황이든 항상 마지막에 실행해야 할 코드가 있을 때 사용하는 finally 메소드도 배웠습니다.

3. async / await 구문
async function fetchAndPrint() {
  try {
    const response = await fetch('https://www.google.www');
    const result = await response.text();
    console.log(result);
  } catch(error) {
    console.log(error);
  } finally {
    console.log('exit');
  }
}

fetchAndPrint();
async/await 구문은 Promise 객체를 다루는 코드(Promise Chaining 코드 등)를 사람들이 좀더 익숙하게 느끼는 동기 실행 스타일의 코드로 작성할 수 있게 해주는 Syntactic sugar라고 했습니다. 하지만 동기 실행 코드처럼 보인다고 실제로 코드가 보이는 순서대로 실행되는 것은 아니라고 했죠?

async 함수 안의 내용이 순차적으로 실행되다가도, await 문을 만나면 await 바로 뒤에 붙은 코드를 실행해두고, 일단은 함수 바깥으로 코드 흐름이 바뀐다고 했던 거, 반드시 기억하셔야 합니다.

이런 점만 주의하면 사실 Promise 기반의 코드들은 가능한 경우에 모두 async/await 구문으로 전환해서 작성하는 게 더 좋습니다.

참고로 async/await(ES2017, 2017년 도입)은 Promise(ES6, 2015년 도입)에 비해 보다 더 최근에 자바스크립트 표준에 도입된 문법인데요. 이렇게 같은 기능을 더 편하게 구현할 수 있도록 자바스크립트 문법은 늘 발전하고 있습니다.

자, 이때까지 자바스크립트로 비동기 실행 코드를 작성할 수 있는 방법 3가지를 살펴봤는데요.

2021년 1월을 기준으로 아직 위의 3가지 비동기 실행 관련 문법들은 서로 상호보완적인 것들이라고 할 수 있습니다. 왜냐하면 아직 아래와 같이 하나가 다른 하나를 완벽히 대체하지 못하는 측면이 있기 때문입니다.

콜백을 함수의 파라미터로 바로 전달하는 전통적인 방식의 비동기 실행 함수들 중에서도 setInterval, addEventListener처럼 그 콜백이 단 한번이 아니라 여러 번 실행되어야 하는 것들은 Promisify해서 사용하면 안 됩니다. Promise 객체는 한번 fulfilled 또는 rejected 상태가 되고나면 그 상태와 결과가 다시는 바뀌지 않기 때문입니다.
async/await 구문의 경우, await은 async 함수 안에서만 사용할 수 있고, 코드의 top-level(어떤 함수 블록 안에 포함된 것이 아닌 코드의 최상위 영역)에서는 사용될 수는 없습니다. 그래서 코드의 top-level에서 async 함수가 리턴한 Promise 객체의 작업 성공 결과를 가져오려면 await을 사용할 수는 없고, 여전히 then 메소드를 사용해야합니다.
그러니까 이 3가지 모두 잘 알아둬야겠죠? 그리고 실제 개발을 할 때는 여러분이 사용하려는 문법이 어느 웹 브라우저에서 지원을 하고 안 하는지를 체크해야 하는데요. 자바스크립트의 각 문법별 브라우저 지원 현황을 이런 사이트 등을 통해 조사하고 개발을 시작하는 게 좋습니다. 다행히 이때까지 우리가 배운 3가지 종류의 문법은 대다수의 웹 브라우저에서 지원합니다.

사실 비동기 실행에 관해서 중요한 것은 어느 문법의 코드를 작성하든 그 개념을 제대로 이해하고 코드를 작성해야 한다는 점입니다. 
콜백 헬 문제를 해결하기 위해 Promise 객체가 등장했고, Promise를 좀 더 편하게 다루기 위해서 async/await 구문이 등장했지만, 
여러분이 각 문법을 제대로 이해하지 못하고 코드를 작성한다면, 그것은 또다서 Promise hell, async/await hell이 될 뿐입니다.

하지만 각각의 문법을 제대로 이해하고 코드를 작성한다면 여러분의 개발 실력과 생산성은 한층 업그레이드될 것이구요.

이번 토픽을 통해 자바스크립트로 비동기 실행 코드를 작성하는 능력, 남이 작성한 비동기 실행 코드를 해석할 수 있는 능력을 충분히 기르셨기를 바랍니다.
정말 고생 많으셨습니다!


# 두 가지 종류의 콜백(심화)
이때까지 우리는 '비동기 실행'에 대해서 많은 것을 배웠습니다. 그런데 한 가지 짚고 넘어가야할 사실이 하나 있습니다. 이번 토픽에서는 나중에 실행될 작업을 처리하는 함수를 '콜백(callback)'이라고 했는데요. 그런데 이것은 콜백의 한 가지 종류일 뿐 원래 콜백이라는 단어는 더 넓은 의미를 갖고 있습니다.

자바스크립트에서 콜백은 어떤 함수의 파라미터로 전달되는 모든 함수를 의미하는 개념입니다. 그러니까 어떤 함수의 파라미터로 전달되기만 한다면 해당 함수는 그 함수의 콜백이 되는 것입니다. 이런 콜백은

1. 동기 실행되는 콜백과
2. 비동기 실행되는 콜백

으로 나뉘는데요. 이번 토픽에서는 비동기 실행에 대해 자세히 설명하기 위해서 2번 관점에서만 콜백을 설명했습니다. 이때까지 우리가 본 콜백들은 모두 2번에 해당하는 콜백들이었죠.

그렇다면 1번에 해당하는 콜백에는 어떤 것들이 있을까요? 예를 들어, 자바스크립트 배열의 메소드 중에서 filter라는 메소드를 생각해보겠습니다. 이 메소드는 배열의 여러 요소들 중에서 특정 조건을 만족하는 요소들만을 추려서 그 요소들로만 이루어진 새로운 배열을 리턴하는 메소드인데요.

아래 코드를 봅시다.

const arr = [1, 2, 3, 4, 5, 6];

const newArr = arr.filter(function isOdd(num) {
  return (num % 2 === 1); 
});

console.log(newArr); // [1, 3, 5]
이 코드는 arr라는 배열에서 홀수만을 추출해서 해당 홀수들만으로 이루어진 새로운 배열을 리턴합니다. filter 함수의 파라미터 부분을 보면 isOdd(홀수인가요?)라는 함수가 들어있다는 것을 알 수 있는데요. filter 함수는 arr 배열에서 각 요소를 하나씩 순회하면서 매 요소마다 isOdd 함수를 실행하고, 해당 함수가 true를 리턴하는 요소들만을 추출합니다. 여기서는 해당 숫자를 2로 나누었을 때 나머지가 1인(=홀수인) 것들만 추출한다는 뜻이겠죠?

이 코드는 Arrow Function 형식으로 이렇게 간략하게 나타낼 수도 있습니다.

const arr = [1, 2, 3, 4, 5, 6];

const newArr = arr.filter((num) => num % 2);

console.log(newArr); // [1, 3, 5]
자, 형식이 어찌되었든 이렇게 함수 안에 들어간 함수는 모두 콜백입니다. 
현재 filter 메소드 안의 콜백은 앞서 말했듯이 '동기 실행되는 콜백'인데요. 
즉, 이 콜백은 우리가 이번 토픽에서 배웠던 '비동기 실행되는 콜백'과는 달리, 아주 정직하게 순서대로 실행됩니다.

filter 함수는 파라미터로 받은 콜백을, 매 요소를 순회하면서, 매 요소를 대상으로 실행합니다. 어떤 처리를 나중에 특정 조건이 만족되었을 때 남은 작업을 처리하기 위해서 사용하는 것이 아니라요. 
만약 isOdd 콜백이 비동기 실행되는 콜백이었다면 그 뒤의 console.log(newArr);가 먼저 실행되었겠죠?

이렇게 콜백에는 동기 실행되는 콜백도 있다는 점에 유의해야합니다.

정리해보겠습니다. 사실 콜백이란 함수의 파라미터로 전달되는 함수를 의미하는 넓은 의미의 개념이고, 이때 그것이

동기 실행되는지
비동기 실행되는지
에 따라 두 종류로 나뉘는 겁니다. 이번 토픽에서는 비동기 실행에 집중된 개념 설명을 위해 2번의 경우가 마치 콜백의 전부인 것처럼 설명했지만, 사실은 동기 실행되는 콜백도 있다는 점을 기억해주세요.

그렇다면 2. 비동기 실행되는 콜백은 어떤 원리로 비동기 실행되는 걸까요? 이제 자바스크립트에서 비동기 실행되는 코드가 있다고 할 때, 각 줄의 코드가 어떤 순서로 실행되는지는 알게 되었습니다. 그렇다면 동기 실행, 비동기 실행 이런 것들은 자바스크립트 실행 환경에서 실제로 어떻게 구현되고 있는 걸까요? 이런 내용은 기회가 된다면 다른 토픽에서 다뤄보도록 합시다.


## 파이썬 개발자를 위한 자바스크립트 기초
def ticket_price(standard, student):
standard_price = 15000
student_price = 8000

total_price = standard * standard_price + student * student_price

return total_price

##
function ticketPrice(standard, student) {
  let standardPrice = 15000;
  let studentPrice = 8000;

  let totalPrice = standard * standardPrice + student * studentPrice;

  return totalPrice;
}

console.log(ticketPrice(3,2));
console.log(ticketPrice(1,3));


## settings.json에 추가할 코드 (tab키 2칸 이동으로 수정)
"[javascript]": {
    "editor.tabSize": 2,
    "editor.insertSpaces": true
},
##


# 코스버거 주문 계산기
# python
def order_price(burger, hotdog, drink):
    burger_price = 6000
    hotdog_price = 5000
    drink_price = 3000

    total_price = burger * burger_price + hotdog * hotdog_price + drink * drink_price

    return total_price

# javascript
function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;

  let totalPrice = burger * burgerPrice + hotdog * hotdogPrice + drink * drinkPrice;

  return totalPrice;
}

# 해설
먼저 함수를 정의해 봅시다. 함수를 정의할 때는 function이라는 키워드를 사용하고 함수 내용을 중괄호({}) 안에 넣어 줍니다.

function orderPrice(burger, hotdog, drink) {
}
orderPrice 함수는 위와 같이 정의할 수 있습니다.

다음에는 각 아이템의 가격을 정의해 줄 건데요. 변수를 정의할 때는 let이라는 키워드를 사용하면 됩니다.

function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;
}
자바스크립트에서는 카멜 케이스(camelCase)가 권장되니까 카멜 케이스를 사용하고 뒤에 세미콜론(;)을 붙이는 것도 잊지 맙시다.

이제 합계를 계산할 건데요. +, * 같은 사칙연산은 파이썬과 완전히 똑같습니다.

function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;

  let totalPrice = burger * burgerPrice + hotdog * hotdogPrice + drink * drinkPrice;
}
마지막으로 totalPrice를 리턴해 주면 되겠죠?

function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;

  let totalPrice = burger * burgerPrice + hotdog * hotdogPrice + drink * drinkPrice;

  return totalPrice;
}
그리고 함수 위에 간단한 설명도 코멘트로 추가해 줍시다. 한 줄 코멘트는 //, 여러 줄 코멘트는 /* ... */를 사용하면 됩니다.

/* 
주문 합계를 계산해 주는 함수
burger, hotdog, drink는 각 아이템 개수를 뜻합니다. 
*/
function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;

  let totalPrice = burger * burgerPrice + hotdog * hotdogPrice + drink * drinkPrice;

  return totalPrice;
}

# 모범 답안
/* 
주문 합계를 계산해 주는 함수
burger, hotdog, drink는 각 아이템 개수를 뜻합니다. 
*/
function orderPrice(burger, hotdog, drink) {
  let burgerPrice = 6000;
  let hotdogPrice = 5000;
  let drinkPrice = 3000;

  let totalPrice = burger * burgerPrice + hotdog * hotdogPrice + drink * drinkPrice;

  return totalPrice;
}

// 테스트 코드
console.log(orderPrice(1, 1, 2));
console.log(orderPrice(0, 2, 2));



## 파이썬 개발자를 위한 자바스크립트 기초

# 기본 자료형
기본 자료형 3가지: 숫자형(Number), 문자열(String), 불린형(Boolean)과 각 자료형에 사용하는 연산자를 소개해 드릴게요.

숫자형(Number)
정수와 소수를 숫자형이라고 합니다.

선언
let i = 1;
let j = 1.5;
let k = -3;
수학 연산
대부분의 수학 연산은 파이썬과 완전히 똑같습니다. 유일한 예외 케이스는 파이썬의 버림 나눗셈(//)인데요. 자바스크립트에는 버림 나눗셈이 따로 없습니다. //는 버림 나눗셈이 아닌 코멘트로 인식되니까 유의해 주세요.

/* 덧셈 */
console.log(1 + 8); // 9

/* 뺄셈 */
console.log(6 - 7); // -1

/* 곱셈 */
console.log(2 * 2); // 4

/* 나눗셈 */
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5

/* 나머지 */
console.log(7 % 3); // 1

/* 거듭제곱 */
console.log(2 ** 3); // 8

/* 버림 나눗셈은 없음 */
console.log(3 // 2); // //가 코멘트로 인식됨
수학 + 할당 연산자
파이썬과 마찬가지로 수학 연산과 할당 연산을 동시에 할 수 있습니다.

let i = 3;
i += 2;
console.log(i); // 5

let j = -5;
j *= 3;
console.log(j); // -15
증가, 감소 연산자
파이썬에는 없는 연산자인데요. 1을 증가하거나 감소할 때는 더 간결하게 ++와 --를 사용할 수 있습니다.

let i = 5;

i++; // i += 1과 똑같음
console.log(i); // 6

i--; // i -= 1과 똑같음
console.log(i); // 5
특히 반복문에서는 숫자를 1증가하거나 감소할 때가 많은데요. 그럴 때 사용하면 좋습니다. (반복문 문법은 다음 챕터에서 배우게 되실 겁니다.)

/* 1부터 10까지 출력하는 반복문 */
let i = 1;
while (i <= 10) {
  console.log(i);
  i++;
}
1
2
3
4
5
6
7
8
9
10
문자열(String)
글자 데이터를 문자열이라고 합니다.


# 선언
파이썬처럼 큰따옴표()를 사용해도 되고, 작은따옴표()를 사용해도 됩니다.

/* 큰따옴표 */
let str1 = "Hello World!";

/* 작은따옴표 */
let str2 = 'Hello World';
문자열 붙이기 (concatenation)
파이썬에서는 덧셈 연산(+)을 이용해서 문자열을 쉽게 붙일 수 있었는데요. 자바스크립트도 마찬가지입니다.

/* 문자열 붙이기 */
console.log('Hello ' + 'Codeit!'); // Hello Codeit!

/* 문자열 변수 붙이기 */
let x = 'Hello ';
let y = 'Codeit!';
console.log(x + y); // Hello Codeit!

/* 문자열에도 더하기 할당 연산자 사용 가능 */
x += y; 
console.log(x); // Hello Codeit!
그리고 파이썬처럼 문자열이 아닌 다른 자료형도 문자열로 바꿔서 연결해 줍니다.

let first = '치즈버거 가격은 ';
let second = 8000;
let third = '원입니다.';
console.log(first + second + third); // 치즈버거 가격은 8000원입니다.
문자열 포매팅 (템플릿 문자열)
파이썬에서는 str.format() 또는 f-string을 사용해서 문자열 사이사이에 변숫값을 넣었는데요. 자바스크립트도 비슷한 문법이 있습니다. 문자열을 백틱(`) 기호로 선언하고, 변수를 ${}로 감싸주면 됩니다.

let name = "서준"
let greeting = `안녕하세요 ${name} 님!`;
console.log(greeting); // 안녕하세요 서준 님!

let i = 8;
let j = 13;
let message = `${i} 더하기 ${j}는 ${i + j}입니다.`;
console.log(message); // 8 더하기 13은 21입니다.
특수 문자열
특정 문자들은 그대로 입력하면 안 되고 특수 문자열을 사용해야 합니다. 파이썬에서는 줄바꿈(\n), 작은따옴표(\'), 큰따옴표(\") 같은 것들이 있었는데요. 자바스크립트도 똑같은 특수 문자열을 사용합니다. 아래는 자주 사용하는 특수 문자열들입니다.

'"
'"

; \n	줄바꿈
; \t	탭
; \'	작은따옴표
; \"	큰따옴표
; \\	백슬래시

console.log('특정 문자들은 앞에\n백슬래시(\\)를 붙여줘야 합니다.');
특정 문자들은 앞에 
백슬래시(\)를 붙여줘야 합니다.
작은따옴표나 큰따옴표는 문자열에 사용한 따옴표와 다르면 특수 문자열을 사용하지 않아도 됩니다.

console.log('작은따옴표 안에서는 "를 그냥 사용할 수 있습니다.');
console.log("큰따옴표 안에서는 '를 그냥 사용할 수 있습니다.");
console.log(`백틱 안에서는 '와 "를 그냥 사용할 수 있습니다.`);
console.log('작은따옴표 안에서 '를 사용하면 문자열이 중간에 끝나기 때문에 오류가 납니다.');
작은따옴표 안에서는 "를 그냥 사용할 수 있습니다.
큰따옴표 안에서는 '를 그냥 사용할 수 있습니다.
백틱 안에서는 '와 "를 그냥 사용할 수 있습니다.
Uncaught SyntaxError: missing ) after argument list
불린형(Boolean)
불린형은 참(true)과 거짓(false) 둘 중 하나의 값을 가지는 데이터입니다.

선언
자바스크립트에서는 true와 false에 소문자를 사용합니다.

let x = true;
let y = false;
비교 연산자
파이썬과 비슷하지만 일치, 불일치는 등호 기호를 하나 더 씁니다.

파이썬: ==, !=
자바스크립트 ===, !==
/* 초과, 미만, 이상, 이하 */
console.log(2 > 1); // true
console.log(2 < 1); // false
console.log(3 >= 2); // true
console.log(3 <= 3); // true

/* 일치, 불일치 */
console.log(3 === 3); // true
console.log(3 !== 3); // false
console.log('Codeit' === 'Codeit'); // true
console.log('Codeit' === 'Codeeat'); // false
===과 ==
사실 자바스크립트에도 == 연산자가 있는데요. == 연산자는 자동으로 형 변환(type conversion)을 해줍니다.

/* == */
console.log('3' == 3); // true

/* === */
console.log('3' === 3); // false
문자열 '3'을 알아서 숫자형 3으로 바꿔서 비교한 거죠. 반면 ===는 값을 그대로 비교하기 때문에 false가 출력됩니다.

자동으로 형 변환을 해주면 편한 면도 있지만, 언제 형 변환을 해주는지, 어떻게 변환을 해주는지를 정확히 이해하고 있지 못하면 예상치 못한 결과가 나올 수 있기 때문에 ===을 사용하시는 걸 추천드립니다.

조합 연산자
파이썬에서는 불린 값을 조합할 수도 있었습니다.

# 두 값이 모두 참이어야 참
print((1 < 2) and (3 == 3)) # True
print((2 < 1) and (3 == 3)) # False

# 두 값 중 하나만 참이어도 참
print((1 < 2) or (3 == 3)) # True
print((2 < 1) or (3 == 3)) # True

# 값 부정
print(not (1 < 2)) # False
print(not (2 < 1)) # True
자바스크립트에서도 불린 값을 조합할 수 있는데, and, or, not 단어 대신 &&, ||, ! 기호를 사용합니다.

/* 두 값이 모두 참이어야 참 */
console.log((1 < 2) && (3 === 3)); // true
console.log((2 < 1) && (3 === 3)); // false

/* 두 값 중 하나만 참이어도 참 */
console.log((1 < 2) || (3 === 3)); // true
console.log((2 < 1) || (3 === 3)); // true

/* 값 부정 */
console.log(!(1 < 2)); // false
console.log(!(2 < 1)); // true



# 자바스크립트 기초 정리
자바스크립트 코드 실행하기
자바스크립트를 실행하려면 HTML 파일(.html)과 자바스크립트 파일(.js)이 필요합니다. 자바스크립트 파일에는 자바스크립트 코드를 작성하고, HTML 파일에서 자바스크립트 코드를 불러옵니다.

main.js

console.log('Hello World!');
index.html

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 연습</title>
</head>
<body>
  <script src="main.js"></script>
</body>
</html>
이번 토픽은 HTML을 배우는 과정은 아니기 때문에 HTML 코드를 깊게 이해하실 필요는 없는데요. 혹시 HTML에 대해 더 알고 싶으시다면 [HTML／CSS로 웹사이트 만들기]도 한번 들어 보세요!

코드를 실행하려면 브라우저에서 HTML 파일을 열고(윈도우: Ctrl + O, 맥: Cmd + O) 개발자 도구의 Console 탭을 확인하면 됩니다.



기본 문법
/* 
미술관 티켓 가격을 계산해 주는 함수
standard, student는 카테고리에 해당하는 티켓 개수를 뜻합니다. 
*/
function ticketPrice(standard, student) {
  let standardPrice = 15000;
  let studentPrice = 8000;

  let totalPrice = standard * standardPrice + student * studentPrice;

  return totalPrice;
}

// 테스트 코드
console.log(ticketPrice(3, 0));
console.log(ticketPrice(2, 2));
45000
46000
문법
문 구분	; 사용
함수, 변수 이름	카멜 케이스 사용
변수 선언	let
함수 선언	function { ... }
리턴 문	return
사칙연산	+, -, *, / (파이썬과 동일)
한 줄 코멘트	//
여러 줄 코멘트	/* … */
기본 자료형
자바스크립트에는 총 5가지 기본 자료형이 있습니다.

자료형	설명	예시
숫자형	정수와 소수	1, -2, 3.832
문자열	글자	'JavaScript', '*%&^$', ''
불린형	참과 거짓 둘 중 하나의 값을 가짐	true, false
null	값이 없다는 것을 의도적으로 표현	null
undefined	코드를 실행했는데 (변수에) 값이 없을 경우	undefined
연산
숫자형, 문자열, 불린형은 다양한 연산을 지원하는데요. 자세한 내용은 기본 자료형 노트를 참고하세요.

형 변환
한 자료형을 다른 자료형으로 변환할 수도 있습니다.

문법
숫자로 변환	Number()
문자열로 변환	String()
불린으로 변환	Boolean()
let x = '3';
let y = '1';
console.log(x + y); // '31'
console.log(Number(x) + Number(y)); // 4

let z = 20;
let w = 5;
console.log(z + w); // 25
console.log(String(z) + String(w)); // '205'

console.log(Boolean(0)); // false
console.log(Boolean('Hello'); // true
불린형으로 변환했을 때 true가 되는 값을 truthy하다고 하고, false가 되는 값을 falsy 하다고 하는데요. 어떤 값이 truthy 하고 어떤 값이 falsy 한지 이해하고 있는 것도 중요합니다.

truthy한 값	falsy한 값
true	false
0을 제외한 모든 숫자 (음수, 소수 포함)	0
''을 제외한 모든 문자열 (공백으로만 이루어져 있는 문자열 포함)	''
-	null
-	undefined
null vs undefined
let codeit;
console.log(codeit); // undefined

codeit = null;
console.log(codeit); // null
null: 사용자가 값이 없다는 걸 의도적으로 표기할 때 사용
undefined: 사용자가 값이 없다는 걸 표기하기보다, 코드를 실행했는데 값이 없을 경우 사용됨
변수에 undefined를 할당해도 오류가 나지는 않는데요.

let codeit = undefined;
console.log(codeit); // undefined
변수에 아무 값도 할당하지 않으면 어차피 undefined가 되기 때문에 이건 불필요한 코드고, 별로 좋지 않은 코딩 스타일입니다. 변수는 값이 없다는 걸 의도적으로 표현하기 위해서는 undefined 대신 null을 사용해 주세요.



# 조건문: if, else, else if

# Python
if 조건부분:
  # ...
else:
  # ...


#Javascript
if(조건 부분) {
  //...
} else {
  //...
}

#
let temperature = 20;

if (temperature >= 100) {
console.log('물이 끓습니다.');
} else if (temperature <= 0) {
console.log('물이 업니다. ');
} else {
console.log('물이 얼지도 끓지도 않습니다.');
}


# 실습 설명
규재는 오랜만에 동생 규원이와 놀이공원을 방문했습니다. 이것저것 놀이공원의 기구들을 즐기다가 가장 기대했던 롤러코스터에 탑승하려고 하는데, 입구에서 키 제한 검사를 하고 있었습니다. 또래 친구들 보다 키가 작은 규원이는 행여나 놀이 기구를 못 탈까 봐 차례를 기다리는 대기 줄에서 긴장의 끈을 놓지 못하고 있습니다.

이 롤러코스터는 140cm 이상만 탑승할 수 있다고 하는데요. 놀이 기구를 타고 싶은 마음은 간절하지만 안전상의 문제로 위험한 상황이 발생할 수 있으니, 만약 기준을 통과하지 못한다면 아쉽지만 다음을 기약하는 것이 좋겠죠?

그럼, 조건문을 활용해서 키 140cm를 기준으로 탑승 가능 유무를 알려주는 checkHeight() 함수를 작성해 주세요. 키가 140이 넘으면 탑승이 가능합니다., 넘지 못하면 탑승이 불가능합니다.라고 출력돼야 합니다.

코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

#실습 결과
탑승이 가능합니다.
탑승이 불가능합니다.
탑승이 가능합니다.



#해설
이번 문제는 2가지 케이스(키가 140 이상이다, 미만이다)로 나뉘기 때문에 if-else문을 사용하면 되는데요. if-else문의 구조는 아래와 같습니다.

if (조건 부분) {
  // ...
} else {
  // ...
}
조건 부분에서는 키가 140cm 이상인지를 확인하면 되겠죠?

function checkHeight(height) {
  if (height >= 140) {
    // ...
  } else {
    // ...
  }
}
140 이상이면 탑승이 가능합니다., 미만이면 탑승이 불가능합니다.라고 출력해 줍시다.

function checkHeight(height) {
  if (height >= 140) {
    console.log('탑승이 가능합니다.');
  } else {
    console.log('탑승이 불가능합니다.');
  }
}

#모범 답안
function checkHeight(height) {
  if (height >= 140) {
    console.log('탑승이 가능합니다.');
  } else {
    console.log('탑승이 불가능합니다.');
  }
}

// 테스트 코드
checkHeight(141);
checkHeight(135);
checkHeight(170);


# 실습 설명
학생들에게 최종 성적을 알려 주는 '학점 계산기'를 만들려고 합니다.

이 수업에는 50점 만점의 중간고사와 50점 만점의 기말고사가 있어요. 두 시험의 점수를 합해서 최종 성적을 내는 방식입니다. 규칙은 다음과 같습니다.

A: 90점 이상
B: 80점 이상 90점 미만
C: 70점 이상 80점 미만
D: 60점 이상 70점 미만
F: 60점 미만
실행기를 보시면 main.py 파일 안에 이미 완성된 파이썬 코드가 있는데요. 파이썬 코드를 참고해서 main.js 파일에 있는 printGrade() 함수를 완성해 주세요. printGrade() 함수는 최종 성적을 출력합니다. 코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

# 실습 결과
D
A
F
C


# 해설
먼저 중간고사 점수와 기말고사 점수의 합인 totalScore 변수를 정의해 줍시다.

function printGrade(midtermScore, finalScore) {
  let totalScore = midtermScore + finalScore;
}
그리고 파이썬의 조건문을 자바스크립트로 옮겨 쓰면 되는데요. 자바스크립트에서는 elif 대신 else if를 사용합니다.

function printGrade(midtermScore, finalScore) {
  let totalScore = midtermScore + finalScore;

  if (totalScore >= 90) {
    console.log('A');
  } else if (totalScore >= 80) {
    console.log('B');
  } else if (totalScore >= 70) {
    console.log('C');
  } else if (totalScore >= 60) {
    console.log('D');
  } else {
    console.log('F');
  }
}
자 그리고 이건 조건문에 대한 일반적인 얘기인데요. 위에 작성된 조건을 보면, B를 받기 위해서는 총 점수가 '80점 이상이면서 90점 미만'이어야 하는데 그냥 totalScore >= 80라고 써줬습니다. else if문으로 넘어왔다는 것은 앞선 if문의 조건 부분을 통과하지 않았다는 뜻입니다 (if문의 조건 부분을 통과하면 안에 코드를 실행하고 조건문 밖으로 나옵니다). 점수가 90점 미만일 수밖에 없다는 뜻이죠.

# python
def print_grade(midterm_score, final_score):
    total_score = midterm_score + final_score

    if total_score >= 90:
        print('A')
    elif total_score >= 80:
        print('B')
    elif total_score >= 70:
        print('C')
    elif total_score >= 60:
        print('D')
    else:
        print('F')

# 모범 답안
function printGrade(midtermScore, finalScore) {
  let totalScore = midtermScore + finalScore;

  if (totalScore >= 90) {
    console.log('A');
  } else if (totalScore >= 80) {
    console.log('B');
  } else if (totalScore >= 70) {
    console.log('C');
  } else if (totalScore >= 60) {
    console.log('D');
  } else {
    console.log('F');
  }
}

// 테스트 코드
printGrade(25, 35);
printGrade(50, 45);
printGrade(29, 24);
printGrade(37, 42);


# 반복문: for, while
# python
for i in range(n):
  # ...

#
for i in range(10, 0, -1):
  print(i)

#
while 조건 부분:
  #...

#
i = 10
while i >= 1:
  print(i)
  i -= 1

# javascript
for (let i = 0; i < n; i++) {
  // ...
}

# 
for (let i = 10; i >= 1; i--) {
  console.log(i);
}

# while (조건 부분) {
  // ...
}

let i = 10;
while (i >= 1) {
  console.log(i);
  i--;
}


# 홀수와 짝수
def print_odd(number):
    for i in range(1, number + 1, 2):
        print(i)

def print_even(number):
    i = 0
    while i <= number:
        print(i)
        i += 2



# 실습 설명
main.py 파일을 보시면 파이썬으로 작성된 print_odd() 함수와 print_even() 함수가 있는데요. 두 함수 모두 number라는 파라미터를 받습니다. print_odd() 함수는 0과 number 사이에 있는 모든 홀수를 출력하고 (0, number 포함) print_even() 함수는 0과 number 사이에 있는 모든 짝수를 출력합니다.

이 함수들을 자바스크립트 코드로 옮겨서 main.js 파일에 있는 printOdd() 함수와 printEven() 함수를 완성해 주세요.

예시
printOdd(8);
1
3
5
7
printEven(8);
0
2
4 
6 
8


# 해설
printOdd() 함수
for 문법은 아래와 같은데요.

for (초기화 부분; 조건 부분; 추가 동작 부분) {
  // ...
}

// 예시
for (let i = 0; i < 10; i++) {
  // ...
}
홀수를 모두 출력하기 위해서는 1에서 시작해서, number를 초과할 때까지 반복하고, 2씩 건너뛰면 됩니다.

이걸 코드로 쓰면 아래와 같겠죠?

function printOdd(number) {
  for (let i = 1; i <= number; i += 2) {
    console.log(i);
  } 
}
여기서 주의해야 할 점은 추가 동작 부분에서 i에 새로운 값을 할당해야 한다는 것입니다. i += 2 대신 i + 2라고 쓰면  i의 값은 바뀌지 않기 때문에 무한 루프 (반복문이 무한히 반복되는 경우)가 발생합니다.

printEven() 함수
while 문법은 아래와 같은데요.

while (조건 부분) {
  // ...
}
짝수를 모두 출력하기 위해서는, 0에서 시작해서, number를 초과할 때까지 반복하고, 2씩 건너뛰면 됩니다.

이건 아래와 같이 쓸 수 있습니다.

function printEven(number) {
  let i = 0;
  while (i <= number) {
    console.log(i);
    i += 2;
  }
}
항상 while문 안에서 조건과 관련된 변수를 업데이트해 줘야 한다는 점(i += 2) 기억해 주세요!

# 모범 답안
function printOdd(number) {
  for (let i = 1; i <= number; i += 2) {
    console.log(i);
  } 
}

function printEven(number) {
  let i = 0;
  while (i <= number) {
    console.log(i);
    i += 2;
  }
}

// 테스트 코드
printOdd(10);
printOdd(23);
printEven(31);
printEven(18);


# 실습 설명
이번 실습은 파이썬 코드의 도움 없이 자바스크립트 코드를 작성해 보는 실습입니다. 앞으로 이런 종류의 실습이 몇 개 있을 건데요. 결국 자바스크립트 코드를 처음부터 쓰는 연습도 필요하기 때문에 어려운 부분이 있어도 포기하지 마시고 토픽에서 배운 내용들, 그리고 힌트를 참고해서 천천히 풀어 보세요.

이번 실습은 아래와 같은 삼각형을 그려주는 함수를 구현하는 것입니다.

*
**
***
****
아래 요구사항에 맞게 함수를 구현해 주세요.

함수 이름은 printTriangle입니다.
함수는 삼각형 높이 height를 파라미터로 받습니다.
함수는 높이 height에 맞는 삼각형을 출력해 줍니다.
함수는 for문을 사용해야 합니다.
문자열 반복하기
i번째 행은 별이 i개 있는데요 (예: 4번째 행 = ****). 이럴 때는 문자열을 특정 횟수만큼 반복하면 됩니다. 파이썬이라면 * 연산자를 사용할 수 있을 것 같은데요.

Python

star = '*'
print(star * 4) # ****
print('*' * 4) # ****
자바스크립트에서는 * 연산자를 문자열에 사용할 수 없습니다. 대신 repeat()이라는 함수를 사용하면 됩니다.

JavaScript

let star = '*';
console.log(star.repeat(4)); // ****
console.log('*'.repeat(4)); // ****
repeat() 함수는 문자열 변수에 사용해도 되고, 문자열 자체에 사용해도 됩니다. repeat() 외에도 문자열을 다룰 때 유용하게 쓰이는 함수들이 몇 개 있는데요. 나머지는 다음 챕터에서 소개해 드릴 겁니다.

실습 결과
높이: 1
*
높이: 3
*
**
***
높이: 5
*
**
***
****
*****

힌트0/2

해설 보기

해설
먼저 함수를 정의해 줍시다.

function printTriangle(height) {
}
이제 for문을 이용해서 삼각형을 그려주면 되는데요. for문을 한 번 돌 때마다 행 하나를 그려주면 됩니다. 처음 돌 때는 *를 출력하고, 그다음 돌 때는 **를 출력하고, 마지막으로 돌 때는 *를 height개만큼 출력하면 되는 거죠. 일단 for문을 작성해 볼게요.

function printTriangle(height) {
  for (let i = 1; i <= height; i++) {
    // i번째 행 출력
  }
}
참고로 i가 0에서 시작하는 게 더 익숙하시다면 0에서 시작해서 height - 1에서 끝내도 됩니다.

function printTriangle(height) {
  for (let i = 0; i < height; i++) {
    // i + 1번째 행 출력
  }
}
지금은 1에서 시작해서 height에서 끝나는 첫 번째 버전을 사용할게요.

i번째 행은 별이 i개 있는데요 (예: 4번째 행 = ****). 문자열을 특정 횟수만큼 반복하려면 repeat() 함수를 사용하면 된다고 했죠?

function printTriangle(height) {
  for (let i = 1; i <= height; i++) {
    console.log('*'.repeat(i));
  }
}
i가 1일 때는 *이 한 번 반복돼서 *
i가 2일 때는 *이 두 번 반복돼서 **
i가 3일 때는 *이 세 번 반복돼서 ***
…
i가 height일 때는 *이 height 번 반복돼서 마지막 줄이 출력됩니다.
모범 답안
function printTriangle(height) {
  for (let i = 1; i <= height; i++) {
    console.log('*'.repeat(i));
  }
}

// 테스트 코드
console.log('높이: 1');
printTriangle(1);

console.log('높이: 3');
printTriangle(3);

console.log('높이: 5');
printTriangle(5);


# 실습 설명
정수 n의 약수는 n을 나누었을 때 나누어떨어지는 수입니다. 만약 정수 i가 정수 n의 약수라면, n을 i로 나누었을 때 나머지가 0이 나와야 하는 거죠.

while문을 활용해서 정수 n의 약수를 모두 출력하고, 총 몇 개의 약수가 있는지 출력하는 프로그램을 작성해 보세요. 코드를 잘 작성했다면 결과는 콘솔에 아래와 같이 출력되어야 합니다.

실습 결과
1
2
3
4
5
6
9
10
12
15
18
20
30
36
45
60
90
180
180의 약수는 총 18개입니다.

힌트5/5

해설 보기

해설
주어진 문제를 해결하기 위해서 천천히 단계별로 코드를 구성해 봅시다.

1. 약수 모두 출력하기
약수를 세는 것은 일단 미루어 두고, 약수를 모두 출력하는 코드부터 작성해 봅시다.

n의 약수를 모두 찾아야 하는데요. 그러면 n이 1로 나누어떨어지는지 확인하고, 2로 나누어떨어지는지 확인하고, 3으로 나누어떨어지는지 확인하고... 이런 식으로 n까지 나누어떨어지는지 확인하면 됩니다.

'나누어떨어진다'는 건 코드로 어떻게 나타낼까요?  n이 i로 나누어떨어진다면, n % i === 0은 true가 나올 것입니다. %는 나머지를 계산해 주는 나머지 연산자였습니다.

그렇다면 약수를 모두 출력하기 위해서 while문과 if문을 활용해서 다음과 같이 코드를 작성할 수 있겠죠?

let n = 180;

let i = 1;
while (i <= n) {
  if (n % i === 0) {
    console.log(i);
  }
  i += 1;
}
참고로 i += 1은 if문 밖에 있어야 하는데요. i가 약수일때만 i를 증가하는게 아니라 매번 i를 증가해야 하기 때문입니다.

2. 약수 세기
이 문제에서는 약수를 모두 출력하는 것뿐만 아니라 약수의 총개수도 출력해야 합니다. 약수를 세려면 약수의 개수를 저장해놓을 변수를 하나 만들어야겠죠? 변수 이름은 count같은 게 좋을 것 같습니다!

let n = 180;

let i = 1;
let count = 0;

while (i <= n) {
  if (n % i === 0) {
    console.log(i);
  }
  i += 1;
}
이 count 변수는 어떻게 활용해야 할까요? 약수를 발견했을 때마다 1씩 늘려주면 되겠죠?

let n = 180;

let i = 1;
let count = 0;

while (i <= n) {
  if (n % i === 0) {
    console.log(i);
        count++;
  }
  i += 1;
}
if문 안쪽에서 count를 1씩 늘려주면 됩니다.

3. 문장 출력하기
끝으로 마지막 문장을 출력해야 합니다. 마지막 문장은 템플릿 문자열을 활용하면 깔끔하게 코드를 작성할 수 있습니다.

# 모범 답안
let n = 180;

let i = 1;
let count = 0;

while (i <= n) {
  if (n % i === 0) {
    console.log(i);
        count++;
  }
  i += 1;
}

console.log(`${n}의 약수는 총 ${count}개입니다.`);


# 제어문 정리
조건문 (if, else, else if)
if, else, else if를 사용하면 조건에 따라 코드의 흐름을 제어할 수 있습니다.

문법

if (조건 부분 1) {
  // ...
} else if (조건 부분 2) {
  // ...
} else {
  // ...
}
조건은 소괄호 ()로 감싸주고 조건을 만족했을 시 실행할 코드는 중괄호 {}로 감싸줍니다. 필요에 따라 else if, else는 생략할 수 있습니다.

if 예시

let temperature = 20;

if (temperature >= 100) {
  console.log('물이 끓습니다.');
}

if-else 예시

let temperature = 20;

if (temperature >= 100) {
  console.log('물이 끓습니다.');
} else {
  console.log('물이 끓지 않습니다.');
}
물이 끓지 않습니다.
if-else if 예시

let temperature = 20;

if (temperature >= 100) {
  console.log('물이 끓습니다.');
} else if (temperature <= 0) {
  console.log('물이 업니다.');
}

if-else if-else 예시

let temperature = 20;

if (temperature >= 100) {
  console.log('물이 끓습니다.');
} else if (temperature <= 0) {
  console.log('물이 업니다.');
} else {
  console.log('물이 얼지도 끓지도 않습니다.');
}
물이 얼지도 끓지도 않습니다.
반복문 (for, while)
특정 동작을 여러 번 반복해야 할 경우 반복문을 사용합니다. 반복문은 for, while 두 종류가 있습니다.

for문
문법

for (초기화 부분; 조건 부분; 추가 동작 부분) {
  // ...
}
예시

for (let i = 0; i < 10; i++) {
  console.log('Hello Codeit!');
}
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
Hello Codeit!
초기화 부분: for문을 돌 때 처음 한 번 실행되는 코드입니다.
조건 부분: 조건 부분이 참이면 for문 안에 있는 코드를 실행합니다. (거짓이 될 때까지 for문을 반복합니다.)
추가 동작 부분: for문 안에 있는 코드가 다 실행된 이후 실행됩니다.
while문
문법

while (조건 부분) {
  // ...
}
예시

let i = 10;
while (i >= 1) {
  console.log(i);
  i--;
}
10
9
8
7
6
5
4
3
2
1
while문 안에서 조건과 관련된 변수를 업데이트해 주는 것(i-—)을 깜빡하는 경우가 많은데요. 그러면 조건이 계속 참이어서 while문 안에 있는 코드가 무한 반복되고 오류가 나니까 업데이트 문을 작성하는 것도 꼭 기억해 주세요!

for문 vs while문
for문과 while문 둘 다 어떤 코드를 여러 번 반복하는데 쓰이는데요. 언제 for문을 사용하고 언제 while문을 사용하면 될까요?

정해진 숫자만큼 반복을 해야 할 때는 주로 for문을 사용하고요, 몇 번 반복을 해야 되는지는 모르고 특정 조건을 만족할 때까지 반복을 해야할 때는 주로 while문을 사용합니다.

for (let i = 0; i < 10; i++) {
  console.log('Hello Codeit!');
}
예를 들어 위의 코드는 출력문을 10번 실행하면 되기 때문에 for문이 더 어울리는데요. 또 다른 예시로 어떤 숫자의 가장 작은 약수를 계산한다고 생각해 봅시다. 아래와 같이 코드를 쓸 수 있는데요.

let n = 35;

let i = 2;
while (n % i !== 0) {
  i++;
}

console.log(`${n}의 가장 작은 약수는 ${i}입니다.`);
가장 작은 약수를 찾으려면 몇 번 반복을 해야 될지 미리 알 수가 없습니다. 그래서 조건을 ’n이 i로 나눠떨어지지 않는다'로 두고 조건이 거짓이 될 때까지 반복하는 겁니다.

물론 첫 번째 예시를 while문으로 쓸 수도 있고 두 번째 예시를 for문으로 쓸 수도 있기 때문에 특정 상황에서는 꼭 for문 또는 while문을 사용해야 되는 건 아니고요. 주로 어떤 상황에서 많이 사용하는지를 알려드리는 겁니다.
'

# 그 외의 제어문
자바스크립트에는 if, for, while 말고도 다른 제어문들이 있는데요. 자주 사용하지는 않지만, 이런 코드를 마주칠 수도 있고, 특정 경우에는 유용하게 쓰일 수 있으니까 이번 레슨에서 소개해 드릴게요.

switch문
switch문은 if문과 비슷한데, 간단한 케이스가 여러 개일 때 주로 사용합니다.

let fruit = '포도';

/* 과일 fruit에 따라 메시지를 출력해 줍니다. */
switch (fruit) {
  case '사과':
    console.log('사과는 1kg에 12,000원입니다.');
    break;
  case '바나나':
    console.log('바나나는 1kg에 6,000원입니다.');
    break;
  case '오렌지':
    console.log('오렌지는 1kg에 10,000원입니다.');
    break;
  case '포도':
    console.log('포도는 1kg에 20,000원입니다.');
    break;
  default:
    console.log('과일을 찾지 못했습니다');
}
포도는 1kg에 20,000원입니다.
과일 종류에 따라 메시지를 출력해 주는 코드인데요.

fruit의 값으로 switch(스위치)를 만들고
fruit의 값이 case에 있는 값과 일치하면 그 case문이 실행됩니다. case문이 종료되면 이어서 그다음 case에 일치하는지 확인하는데요. case문이 종료되면 바로 switch문을 나가도록 break라는 것을 사용해 줬습니다. (break문에 대한 내용은 다음 섹션을 참고해 주세요.)
만약 아무 case문도 실행이 안 됐다면 default문이 실행되는데요. else문과 비슷하게 나머지 케이스를 처리한다고 생각하시면 됩니다.
switch는 항상 값이 일치(===) 하는지를 비교하기 때문에 복잡한 연산은 사용할 수 없지만 많은 케이스를 효율적으로 처리할 수 있습니다.

switch문에 대해 더 알고 싶으시다면 아래 레슨을 참고해 보세요!

https://www.codeit.kr/topics/core-concept-of-javascript-programming/lessons/3419
https://www.codeit.kr/topics/core-concept-of-javascript-programming/lessons/3420
break문
break문은 for, while, switch문을 미리 종료하고 싶을 때 사용합니다. break문을 만나면, 그 순간 for, while 또는 switch문이 종료됩니다.

let fruit = '포도';

/* 과일 fruit에 따라 메시지를 출력해 줍니다. */
switch (fruit) {
  case '사과':
    console.log('사과는 1kg에 12,000원입니다.');
    break;
  case '바나나':
    console.log('바나나는 1kg에 6,000원입니다.');
    break;
  case '오렌지':
    console.log('오렌지는 1kg에 10,000원입니다.');
    break;
  case '포도':
    console.log('포도는 1kg에 20,000원입니다.');
    break;
  default:
    console.log('과일을 찾지 못했습니다');
}
포도는 1kg에 20,000원입니다.
이전 예시에서는 일치하는 case를 찾으면 바로 switch문을 빠져나오도록 break문을 사용했었습니다.

for나 while문에도 동일하게 사용할 수 있는데요.

for (let i = 1; i <= 10; i++) {
  console.log(i);
  if (i === 7) {
    break;
  }
}
1
2
3
4
5
6
7
let i = 1;

while (i <= 10) {
  console.log(i);
  if (i === 7) {
    break;
  }
  i++;
} 
1
2
3
4
5
6
7
원래는 1부터 10까지 반복돼야 하는데, 중간에 break를 마주치기 때문에 숫자가 7까지만 출력되고 반복문이 종료됩니다.

프로그래밍을 하다 보면 특정 조건을 만족하면 바로 반복문에서 나오고 싶을 때가 있을 텐데, 그럴 때 break문을 사용하시면 됩니다.

continue문
continue문은 반복문(for, while)에 사용하는 것인데요. break와 비슷한 면이 있습니다. break는 반복문 전체를 종료했다면, continue는 현재 반복문을 한 번 건너뛰는 겁니다. 이게 무슨 뜻인지 설명해 드릴게요.

for (let i = 1; i <= 10; i++) {
  if (i % 2 === 0) {
    continue;
  }
  console.log(i);
}
1
3
5
7
9
만약 i를 2로 나눈 나머지가 0이면, 즉 i가 짝수이면 continue문을 실행하는데요. 그러면 현재 i에 해당하는 반복문은 바로 종료되고 다음 반복문으로 넘어가기 때문에 console.log(i)가 실행되지 않습니다. i가 짝수이면 console.log(i)가 실행되지 않기 때문에 홀수만 출력되는 거죠.

for문을 while문으로 바꾸면 이렇게 쓸 수 있습니다.

let i = 1;

while(i <= 10) {
  if (i % 2 === 0) {
    i++;
    continue;
  }
  console.log(i);
  i++;
}
1
3
5
7
9
continue를 마주치면 마지막 줄의 i++를 건너뛰게 되기 때문에 if문 안에도 i++가 필요한 겁니다.

continue는 특정 조건을 만족할 경우, 현재 반복문을 한 번 건너뛰고 싶을 때 사용하시면 됩니다.

break나 continue문에 대해 더 알고 싶으시다면 아래 레슨을 참고해 보세요!

https://www.codeit.kr/topics/core-concept-of-javascript-programming/lessons/3429


# 배열과 인덱싱

// 기본 자료형: 숫자형, 문자열, 불린형, null, undefined
// 심화 자료형: 배열(array), 객체(object)

let topics = [
'프로그래밍 시작하기 in Python',
'Git',
'소프트웨어 이해하기',
'프로그래밍 시작하기 in JavaScript',
'데이터 분석과 시각화',
];

console. log(topics);
console. log(topics.length);
console. log (topics[topics.length - 1]);
console. log(topics.slice(1, 4));
console. log(topics.slice(3));
console. log(topics.slice());




# 실습 설명
main.js 파일의 _____에 들어갈 코드를 작성해 주세요. 위에서부터

'number', 'string', 'boolean', 'null', 'undefined', 'array'가 순서대로 담겨있는 배열을 생성해 주세요.

배열의 두 번째 요소를 출력해 주세요.

배열의 마지막 요소를 출력해 주세요.

기본 자료형에 속하는 처음 5개 요소를 잘라내 주세요.

# 실습 결과
string
array
[ 'number', 'string', 'boolean', 'null', 'undefined' ]


# 해설
1. 배열을 정의할 때는 대괄호 []를 사용하고 각 요소를 쉼표로 구분하면 됩니다.

let dataTypes = ['number', 'string', 'boolean', 'null', 'undefined', 'array'];
2. 파이썬 리스트와 같이 인덱스(요소의 위치)와 대괄호를 사용해서 요소에 접근하면 되는데요. 인덱스는 0에서 시작합니다. 두 번째 요소는 1번 인덱스에 있는 요소겠죠?

// 배열의 두 번째 요소를 출력해 주세요.
console.log(dataTypes[1]);
3. dataTypes의 길이가 6이기 때문에 dataTypes[5] 이렇게 가져와도 되지만 배열의 길이를 코드로 가져오는 게 더 안전합니다. 배열의 길이는 항상 바뀔 수 있기 때문이죠. 배열의 길이는 .length로 가져올 수 있습니다.

// 배열의 마지막 요소를 출력해 주세요.
console.log(dataTypes[dataTypes.length - 1]);
4. 배열을 잘라낼 때는 slice() 함수를 쓰면 되는데요. 시작 인덱스, 끝 인덱스를 파라미터로 넘겨주면 됩니다. (끝 인덱스에 있는 요소는 포함되지 않습니다.) 처음 5개 요소를 잘라내고 싶은 거니까 0과 5를 넘겨주면 되겠죠?

// 기본 자료형에 속하는 처음 5개 요소를 잘라내서 출력해 주세요.
console.log(dataTypes.slice(0, 5));

# 모범 답안
let dataTypes = ['number', 'string', 'boolean', 'null', 'undefined', 'array'];

// 배열의 두 번째 요소를 출력해 주세요
console.log(dataTypes[1]);

// 배열의 마지막 요소를 출력해 주세요
console.log(dataTypes[dataTypes.length - 1]);

// 기본 자료형에 속하는 처음 5개 요소를 잘라내서 출력해 주세요
console.log(dataTypes.slice(0, 5));



# 실습 설명
반복문을 활용해서 배열에 있는 모든 요소를 하나씩 출력해 봅시다. 여러분께 힌트를 드리기 위해 코드를 파이썬으로 main.py 파일에 작성해 놨는데요. 이걸 참고해서 코드를 작성해 보세요.

실습 결과
number
string
boolean
null
undefined
array

힌트2/2

해설 보기

해설
for문 문법은 아래와 같은데요.

for (초기화 부분; 조건 부분; 추가 동작 부분) {
  // ...
}
마지막 인덱스는 (배열 길이 - 1)이니까 인덱스 0에서 시작해서 배열 길이에 도달할 때까지 반복하면 됩니다.

for (let i = 0; i < dataTypes.length; i++) {
  console.log(dataTypes[i]);
}
배열의 길이는 .length로 가져올 수 있습니다.

참고로 while문을 사용할 수도 있는데요. while문을 사용한 코드는 아래와 같습니다.

let dataTypes = ['number', 'string', 'boolean', 'null', 'undefined', 'array'];

let i = 0;
while (i < dataTypes.length) {
  console.log(dataTypes[i]);
  i++;
}
배열은 정해진 숫자(배열 길이)만큼 반복을 하는 거기 때문에 for문을 더 많이 사용하지만 while문이 더 편하시다면 while문을 사용하셔도 크게 상관없습니다!

모범 답안
let dataTypes = ['number', 'string', 'boolean', 'null', 'undefined', 'array'];

for (let i = 0; i < dataTypes.length; i++) {
  console.log(dataTypes[i]);
}


# 배열 수정하기

// 기본 자료형: 숫자형, 문자열, 불린형, null, undefined
// 심화 자료형: 배열(array), 객체(object)

let topics = [
'프로그래밍 시작하기 in Python' ,
'Git',
'소프트웨어 이해하기',
'프로그래밍 시작하기 in JavaScript',
'데이터 분석과 시각화',
];

console.log(topics);

topics.push('머신 러닝 기본기');
console.log(topics);

topics.pop();
console.log(topics);

topic.splice(0, 0, 'React 웹 개발 시작하기');
topic.splice(2, 1, '자바스크립트');
topic.splice(2, 1, '자바스크립트', 'C++');
topic.splice(topic.length -2, 1);



# 자바스크립트 자료형 II

# 실습 결과
[
    'number', 'string',
    'false',  'true',
    'null',   'undefined',
    'array',  'object'
]
[ 'number', 'string', 'false', 'true', 'null', 'undefined', 'array' ]
[ 'number', 'string', 'null', 'undefined', 'array' ]
[ 'number', 'string', 'boolean', 'null', 'undefined', 'array' ]


# 해설
1. 배열 끝에 요소를 추가하려면 push() 함수를 사용하면 됩니다.

// 배열 끝에 'array'와 'object'를 추가해 주세요
dataTypes.push('array');
dataTypes.push('object');
console.log(dataTypes);
push() 함수는 사실 여러 요소를 추가할 수도 있는데요. 추가할 요소들을 순서대로 넘겨주면 됩니다. 이걸 이용하면 코드를 조금 더 간결하게 쓸 수 있습니다.

// 배열 끝에 'array'와 'object'를 추가해 주세요
dataTypes.push('array', 'object');
console.log(dataTypes);
2. 배열의 마지막에 요소를 제거하려면 pop() 함수를 사용하면 됩니다.

// 배열의 마지막 요소 ('object')를 제거해 주세요
dataTypes.pop();
console.log(dataTypes);
3. 배열 중간에 있는 요소를 제거하거나 중간에 요소를 추가하려면 splice() 함수를 사용해야 하는데요. splice() 함수의 문법은 아래와 같습니다.

arr.splice(start, deleteCount, item1, item2...);
start 인덱스에서 시작해서, deleteCount만큼의 요소를 지우고, 이후에 item들을 삽입합니다.

'false'와 'true'는 인덱스 2, 3에 있는 요소들인데요. 따라서 인덱스 2에서 시작해서 요소 2개를 지우면 됩니다.

// 배열 중간에 있는 'false', 'true'를 제거해 주세요
dataTypes.splice(2, 2);
console.log(dataTypes);
4. 이번에도 splice() 함수를 사용하면 되는데요. 'string' 바로 다음은 인덱스 2번 위치입니다. 그래서 인덱스 2에서 시작해서, 아무것도 안 지우고 'boolean'을 삽입하면 됩니다.

// 'string' 바로 다음에 'boolean'을 추가해 주세요
dataTypes.splice(2, 0, 'boolean');
console.log(dataTypes);
모법 답안
let dataTypes = ['number', 'string', 'false', 'true', 'null', 'undefined'];

// 배열 끝에 'array'와 'object'를 추가해 주세요
dataTypes.push('array', 'object');
console.log(dataTypes);

// 배열의 마지막 요소 ('object')를 제거해 주세요
dataTypes.pop();
console.log(dataTypes);

// 배열 중간에 있는 'false', 'true'를 제거해 주세요
dataTypes.splice(2, 2);
console.log(dataTypes);

// 'string' 바로 다음에 'boolean'을 추가해 주세요
dataTypes.splice(2, 0, 'boolean');
console.log(dataTypes);


# 온도 바꾸기

# 직접 코딩
let celsiusTemps = [27, 25, 26, 22, 28, 27, 21];
let fahrenheitTemps = []
// 여기에 코드를 작성하세요
for(let i = 0; i <= celsiusTemps.length - 1; i++) {
  let Temps = (celsiusTemps[i] * 9 / 5) + 32;
  fahrenheitTemps.push(Temps);
}
// 테스트 코드
console.log(fahrenheitTemps);

# 실습 설명
여기 이번 주 온도를 섭씨로 기록한 배열이 있습니다.

let celsiusTemps = [27, 25, 26, 22, 28, 27, 21];
그런데, 미국에서 오랫동안 살다 온 태오는 아직 섭씨온도가 익숙하지 않은데요. 불편한 태오를 위해 각각의 섭씨온도들을 화씨로 변환해 봅시다.

화씨로 변환하는 공식은 아래와 같은데요.

F = (C * 9 / 5) + 32 (F: 화씨온도, C: 섭씨온도)
반복문을 이용해서 celsiusTemps 배열의 각 요소들을 화씨로 변환한 값을 fahrenheitTemps 배열에 추가해 주세요. 코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

실습 결과
[
  80.6,   77, 78.8,
  71.6, 82.4, 80.6,
  69.8
]

# 해설
반복문을 어떻게 활용하면 될까요? 
celciusTemps 배열을 돌면서 각 요소를 화씨온도로 바꾸고, 그 값을 fahrenheitTemps에 넣어 주면 됩니다.

배열을 반복문으로 도는 방법은 이전 실습에서 배웠는데요.

let celsiusTemps = [27, 25, 26, 22, 28, 27, 21];
let fahrenheitTemps = []

for (let i = 0; i < celsiusTemps.length; i++) {
}

// 테스트 코드
console.log(fahrenheitTemps);
이렇게 할 수 있었습니다.

그럼 섭씨온도를 화씨온도로 바꿔주는 코드를 작성해 봅시다.

F = (C * 9 / 5) + 32
for (let i = 0; i < celsiusTemps.length; i++) {
  let fahrenheitTemp = (celsiusTemps[i] * 9 / 5) + 32;
}
이제 fahrenheitTemp를 fahrenheitTemps에 추가하면 되는데요. 배열 끝에 요소를 추가하는 거니까 push() 함수를 사용하면 되겠죠?

for (let i = 0; i < celsiusTemps.length; i++) {
  let fahrenheitTemp = (celsiusTemps[i] * 9 / 5) + 32;
  fahrenheitTemps.push(fahrenheitTemp);
}
중간에 변수에 값을 할당하는 과정을 생략할 수도 있는데요.

for (let i = 0; i < celsiusTemps.length; i++) {
  fahrenheitTemps.push((celsiusTemps[i] * 9 / 5) + 32);
}
이렇게 계산한 값을 바로 추가해도 됩니다. 하지만 코드가 더 짧다고 무조건 좋은 것은 아니니까 더 직관적인 방식을 사용하시면 됩니다!

# 모범 답안
let celsiusTemps = [27, 25, 26, 22, 28, 27, 21];
let fahrenheitTemps = []

for (let i = 0; i < celsiusTemps.length; i++) {
  fahrenheitTemps.push((celsiusTemps[i] * 9 / 5) + 32);
}

// 테스트 코드
console.log(fahrenheitTemps);


# 객체와 프로퍼티
// 기본 자료형: 숫자형, 문자열, 불린형, null, undefined
// 심화 자료형: 배열(array), 객체(object)

let codeit = {
'@name': '코드잇',
'born year': 2017,
founders: ['강영훈', '이윤수'],
'worst-topic': null,
bestTopic: {
title: '프로그래밍 시작하기 in JavaScript',
language: 'JavaScript',
  };
};

console.log(codeit);


# 프로퍼티 접근하기
console.log(codeit['founders']);
console.log(codeit.founders);
console.log(codeit.bestTopic.title);
console.log(codeit['bestTopic'].title);

# 
console.log('members' in codeit);
#
let propertyName = 'founders';

### console.log(codeit[propertyName]);
### console.log(codeit.propertyName);   (undefined)



# 코드댓 객체
실습 결과
코드댓
김민준
JavaScript
2022


# 해설
1. 프로퍼티에 접근하는 방법은 두 가지가 있는데요. 점 표기법과 대괄호 표기법입니다.

codethat.name; // 점 표기법
codethat['name'] // 대괄호 표기법
꼭 따옴표로 감싸 줘야 하는 프로퍼티 이름들도 있는데요 (예: my-name, #name), 이런 경우 꼭 대괄호 표기법을 사용해야 합니다. 하지만 이런 경우를 제외하고는 점 표기법이 더 간결하기 때문에 점 표기법을 권장 드립니다.

// name 프로퍼티 값을 출력해 주세요
console.log(codethat.name);
2. founder는 또 다른 객체인데요. 객체 안에 객체가 있을 때는 점 표기법을 연결해서 쓰면 됩니다.

// founder의 name 프로퍼티 값을 출력해 주세요
console.log(codethat.founder.name);
codethat의 founder 프로퍼티의 name 프로퍼티에 접근하는 겁니다. name이라는 프로퍼티가 중복되는 것처럼 보여도 하나는 codethat 객체의 프로퍼티고 하나는 founder 객체의 프로퍼티기 때문에 괜찮습니다.

3. 먼저 languages 프로퍼티는 이렇게 접근할 수 있는데요.

codethat.languages
codethat.languages는 일반 배열처럼 다루면 됩니다. 인덱싱을 통해 요소에 접근할 수 있는 거죠.

// languages 프로퍼티의 3번째 값을 출력해 주세요
console.log(codethat.languages[2]);
인덱싱외에 슬라이싱, push(), pop() 같은 것도 일반 배열에 사용하는 것처럼 사용할 수 있습니다.

4. 변수를 통해 프로퍼티에 접근할 때는 꼭 대괄호 표기법을 사용해야 합니다.

codethat[propertyName]; // Good
codethat['propertyName']; // Bad
codethat.propertyName; // Bad
2번째나 3번째 줄처럼 쓰면 'propertyName'이라는 프로퍼티를 찾게 돼서 undefined가 나올 겁니다. 문자열 변수를 활용할 때는 대괄호 표기법을 사용하고, 변수를 그대로 넣어 주면 됩니다.

// propertyName 변수를 이용해서 bornYear 프로퍼티 값을 출력해 주세요
let propertyName = 'bornYear';
console.log(codethat[propertyName]);

# 모범 답안
let codethat = {
  name: '코드댓',
  bornYear: 2022,
  founder: {
    name: '김민준',
    age: 28
  },
  languages: ['C++', 'Java', 'JavaScript', 'Python'],
};

// name 프로퍼티 값을 출력해 주세요
console.log(codethat.name);

// founder의 name 프로퍼티 값을 출력해 주세요
console.log(codethat.founder.name);

// languages 프로퍼티의 3번째 값을 출력해 주세요
console.log(codethat.languages[2]);

// propertyName 변수를 이용해서 bornYear 프로퍼티 값을 출력해 주세요
let propertyName = 'bornYear';
console.log(codethat[propertyName]);



# 객체 수정하기
let codeit = {
name: '코드잇',
bornYear: 2017,
founders: ['강영훈', '이윤수'],
worstTopic: null,
bestTopic: {
title: '프로그래밍 시작하기 in JavaScript',
language: 'JavaScript',
  };
};

console.log(codeit);

codeit.color = 'purple';
codeit.bornYear = 2016;
delete codeit.name;

console.log(codeit);


# 영어 단어장 I
# 실습 설명
이제 막 코딩을 배우기 시작한 시원이는 프로그래밍을 할 때 영어의 중요성을 새삼 느껴 다시금 영어 공부를 하기 시작했습니다. 그런데 문득 영어 공부도 하고 코딩 공부도 할 겸 자바스크립트로 영어 단어장을 만들어 보려는 아이디어가 떠올랐습니다.

아래는 오늘 시원이가 외워야 할 영어 단어들인데요.

외워야 할 단어들

function = 함수

variable = 변수

constant = 상수

default value = 기본 값

global = 세계적인

1. 영어 단어가 프로퍼티 이름, 한글 단어가 프로퍼티 값인 vocab 객체를 완성해 주세요.
2. local이라는 단어도 vocab에 추가해 주세요. local의 뜻은 ‘지역의'입니다.
3. 프로그래밍에서 global 뜻은 ‘세계적인'보다 ‘전체적인'이 더 어울릴 것 같은데요. global 프로퍼티의 값을 ‘전체적인'으로 바꿔 주세요.
4. default value 프로퍼티를 삭제해 주세요.

main.js 파일에 // 여기에 코드를 작성하세요 부분을 차례대로 채워 넣으시면 됩니다.

# 실습 결과
{
  function: '함수',
  variable: '변수',
  constant: '상수',
  'default value': '기본 값',
  global: '세계적인',
  local: '지역의'
}
{
  function: '함수',
  variable: '변수',
  constant: '상수',
  'default value': '기본 값',
  global: '전체적인',
  local: '지역의'
}
{
  function: '함수',
  variable: '변수',
  constant: '상수',
  global: '전체적인',
  local: '지역의'
}


# 해설
1. 프로퍼티는 프로퍼티 이름: 프로퍼티 값 이런 식으로 써 주면 되는데요. 영어 단어가 프로퍼티 이름이고 한글 단어가 프로퍼티 값입니다.

let myVocab = {
  function: '함수',
  variable: '변수',
  constant: '상수',
  'default value': '기본 값',
  global: '세계적인',
};
프로퍼티 이름은 항상 문자열이기 때문에 따옴표를 굳이 써 주지 않아도 되는데요. default value는 중간에 공백이 있기 때문에 꼭 따옴표로 감싸 줘야 합니다. 그리고 프로퍼티 값에는 아무 자료형이나 들어갈 수 있는데, 우리는 단어를 넣는 거니까 문자열 형태로 넣어 줬습니다.

2. 객체에 새로운 프로퍼티를 추가하려면 프로퍼티에 값을 할당해 주면 됩니다. 우리는 local이라는 프로퍼티에 '지역의'라는 값을 할당해 주면 되겠죠?

// '지역의'라는 뜻을 가진 local 프로퍼티를 추가해 주세요
myVocab.local = '지역의';
console.log(myVocab);
3. 객체의 프로퍼티 값을 변경하려면, 변경하려는 프로퍼티에 값을 다시 할당해 주면 됩니다.

// global 프로퍼티의 값을 '전체적인'으로 바꿔 주세요
myVocab.global = '전체적인';
console.log(myVocab);
4. 프로퍼티를 삭제할 때는 delete라는 키워드를 쓰면 됩니다.

// default value 프로퍼티를 삭제해 주세요
delete myVocab['default value'];
console.log(myVocab);
delete 뒤에 삭제할 프로퍼티를 써 주면 되는데요. 'default value'는 따옴표로 감싸져 있기 때문에 대괄호 표기법을 사용해야겠죠?

# 모범 답안
let myVocab = {
  function: '함수',
  variable: '변수',
  constant: '상수',
  'default value': '기본 값',
  global: '세계적인',
};

// '지역의'라는 뜻을 가진 local 프로퍼티를 추가해 주세요
myVocab.local = '지역의';
console.log(myVocab);

// global 프로퍼티의 값을 '전체적인'으로 바꿔 주세요
myVocab.global = '전체적인';
console.log(myVocab);

// default value 프로퍼티를 삭제해 주세요
delete myVocab['default value'];
console.log(myVocab);


# 메소드
let codeit = {
name: '코드잇',
bornYear: 2017,
founders: ['강영훈', '이윤수'],
worstTopic: null,
bestTopic: {
title: '프로그래밍 시작하기 in JavaScript',
language: 'JavaScript',

greet: function (name) {
console.log('코드잇에 오신걸 환영합니다 ${name}님!`);
  },
};

codeit.greet('재민');

'
# 영어단어장 II

# 실습 설명
지난번 실습에서 영어 단어장 객체를 만들었는데요. 단어장 안에 있는 단어를 출력해 주는 printVocab() 메소드를 정의해 줍시다.

printVocab이라는 이름을 가진 메소드를 객체 안에서 정의해 주세요.
printVocab() 메소드는 영어 단어 word를 파라미터로 받습니다 (예: 'function', 'local').
만약 word라는 단어가 객체에 있으면 '[word]'의 뜻은 '[뜻]'입니다.라고 출력해 주세요.
만약 word라는 단어가 객체에 없으면 단어를 찾지 못했습니다.라고 출력해 주세요. 아래 실습 결과를 참고하세요!
실습 결과
'function'의 뜻은 '함수'입니다.
'local'의 뜻은 '지역의'입니다.
단어를 찾지 못했습니다.


#해설
먼저 메소드를 정의해 줍시다. 메소드도 일반 프로퍼티처럼 정의하면 되는데요. 프로퍼티 값이 함수입니다.

let myVocab = {
  ...
  printVocab: function (word) {
  },
};
프로퍼티 이름이 결국 메소드 이름이 되기 때문에 함수를 정의할 때 이름을 안 붙여 줘도 됩니다. 그리고 word라는 파라미터를 받는다고 했죠?

그다음은 word에 해당하는 단어가 객체에 있는지 확인해야 하는데요. 프로퍼티가 객체에 있는지 확인하려면 [프로퍼티 이름] in [객체] 문법을 사용할 수 있었습니다.

let myVocab = {
  ...
  printVocab: function (word) {
    if (word in myVocab) {
      // ...
    } else {
      // ...
    }
  },
};
여기서 word는 이미 문자열 변수이기 때문에 'word'라고 쓰면 안 되고 word 그대로 써 줘야 합니다. 예를 들어 word = 'function'이라면 word in myVocab은 true가 되고 word = 'array'라면 word in myVocab은 false가 됩니다.

이제 if - else에 해당하는 출력문만 작성하면 되는데요. 단어와 뜻을 출력하려면 템플릿 문자열을 활용하면 되겠죠?

let myVocab = {
  ...
  printVocab: function (word) {
    if (word in myVocab) {
      console.log(`'${word}'의 뜻은 '${myVocab[word]}'입니다.`);
    } else {
      console.log('단어를 찾지 못했습니다.');
    }
  },
};
참고로 템플릿 문자열을 사용하면 따옴표 ', "가 그대로 출력됩니다.
'

# 모범 답안
let myVocab = {
  function: '함수',
  variable: '변수',
  constant: '상수',
  global: '전체적인',
  local: '지역의',
  printVocab: function (word) {
    if (word in myVocab) {
      console.log(`'${word}'의 뜻은 '${myVocab[word]}'입니다.`);
    } else {
      console.log('단어를 찾지 못했습니다.');
    }
  },
};

// 테스트 코드
myVocab.printVocab('function');
myVocab.printVocab('local');
myVocab.printVocab('array');


# 숫자형, 문자열 메소드

“자바스크립트의 모든 것이 다 객체다”라는 말이 있습니다. 자바스크립트라는 언어가 구현된 방식 덕분에 객체가 아닌 다른 자료형도 객체처럼 사용할 수 있는데요. 이게 무슨 말이냐 하면, 다른 자료형에도 여러 유용한 프로퍼티나 메소드를 사용할 수 있다는 겁니다.

사실 배열은 이미 여러 프로퍼티와 메소드를 사용해 봤는데요.

arr.length
arr.slice()
arr.push()
arr.pop()
arr.splice()
이런 것 모두 배열의 프로퍼티/메소드라고 할 수 있습니다. 우리는 배열 [...]을 선언하는 것 같지만, 자바스크립트는 뒤에서 이걸 객체처럼 구현하기 때문에 배열에도 다양한 프로퍼티와 메소드가 있는 겁니다.

아무튼 중요한 점은 숫자형, 문자열에도 우리가 사용할 수 있는 다양한 메소드가 있다는 건데요. 이 중에서 많이 쓰는 메소드를 이번 레슨에서 소개해 드릴게요.

# 숫자형 메소드
**.toFixed()**
.toFixed()는 소수를 다룰 때 사용하는 메소드 인데요. 파라미터로 숫자를 전달해 주면, 그 값만큼 소수점 아래 자릿수를 고정해 줍니다.

/* 숫자에 바로 사용 */
console.log(0.3.toFixed(2)); // 0.30

/* 숫자형 변수에 사용 */
let myNumber = 0.3591;
console.log(myNumber.toFixed(3)); // 0.359
소수를 포매팅할 때 유용하게 쓰입니다.

# 문자열 메소드
.length
.length는 메소드는 아니고 프로퍼티인데요. 배열의 .length처럼 문자열의 길이를 가져올 수 있습니다.

let myString = 'codeit';
console.log(myString.length); // 6


# .charAt(), []
어떻게 보면 문자열은 ‘문자의 배열이라고 생각할 수 있기 때문에 배열과 비슷한 면이 많은데요. .charAt()이나 대괄호 표기법으로 특정 위치(인덱스)에 있는 문자를 가져올 수 있습니다.

let myString = 'codeit';
console.log(myString.charAt(3)); // e
console.log(myString[0]); // c
이걸 활용해서, 예를 들어 문자열이 팰린드롬(palindrome)인지 확인할 수 있는데요. 토마토나 기러기처럼 거꾸로 읽어도 똑같은 단어를 팰린드롬이라고 부릅니다.

function isPalindrome(word) {
  // 단어 1/2지점까지 반복
  for (let i = 0; i < word.length / 2; i++) {
    // i번째 문자와 끝에서 i번째 문자와 비교
    if (word[i] !== word[word.length - 1 - i]) {
      return false;
    }
  }
  return true;
}

console.log(isPalindrome("racecar"));
console.log(isPalindrome("기러기"));
console.log(isPalindrome("123321"));
console.log(isPalindrome("hello"));
true
true
true
false


# .slice()
배열의 .slice() 메소드와 똑같은데요. 두 인덱스 사이의 문자열을 잘라내 줍니다.

let myString = 'codeit';
console.log(myString.slice(0, 4)); // code (0과 4 사이)
console.log(myString.slice(4)); // it (4부터 끝까지)
console.log(myString.slice()); // codeit (문자열 전체)


# .toUpperCase()
알파벳 문자를 모두 대문자로 만들어 줍니다.

let myString = 'CoDeIt';
console.log(myString.toUpperCase()); // CODEIT


# .toLowerCase()
알파벳 문자를 모두 소문자로 만들어 줍니다.

let myString = 'CoDeIt';
console.log(myString.toLowerCase()); // codeit


# .repeat()
이전에 봤던 함수인데요. 이 함수도 사실 메소드라고 부를 수 있습니다. 문자열을 여러 번 반복하는 데 사용했었죠?

let myStr = '123';
consol.log(myStr.repeat(5)); // 123123123123123


# .trim()
문자열 시작과 끝부분에 있는 모든 공백 문자를 제거(trim)해 줍니다. (\n은 줄바꿈 문자를 뜻하고 \t는 탭 문자를 뜻합니다.)

let myString = '   Hello Codeit!   ';
console.log(myString.trim());

let yourString = '\n\nHello Codeit!\t\t';
console.log(yourString.trim());
Hello Codeit!
Hello Codeit!
문자열 중간에 있는 공백은 제거되지 않습니다.


# for...of와 for...in

let topics = [
'프로그래밍 시작하기 in Python' ,
'Git',
' 소프트웨어 이해하기',
'프로그래밍 시작하기 in JavaScript',
'데이터 분석과 시각화',
];

for (let i = 0; i < topics. length; i++) {
console. log(topics [i]);
}

# for...of
for (let topic of topics) {
console. log(topic);
}

for (let key in codeit) {
  console.log(key);
  console.log(code[key]);
}


# 순이들의 시험 결과
# 실습 설명
혜순이와 민순이는 이번에 SQL 자격증 시험에 응시했는데요. 아래는 두 사람의 각 과목별 점수를 정리한 객체입니다.

let hyesoonScore = {
  '데이터 모델링의 이해': 10,
  '데이터 모델과 성능': 8,
  'SQL 기본': 22,
  'SQL 활용': 18,
  'SQL 최적화 기본 원리': 20,
};

let minsoonScore = {
  '데이터 모델링의 이해': 14,
  '데이터 모델과 성능': 8,
  'SQL 기본': 12,
  'SQL 활용': 4,
  'SQL 최적화 기본 원리': 16,
};
자격증 합격 기준은 총점이 60점 이상입니다. 파라미터로 scoreObject 객체를 전달받고, 각 과목들의 점수를 모두 합산해서 시험 결과를 알려 주는 passChecker() 함수를 완성해 주세요.

합격 기준을 충족할 경우 축하합니다! 합격입니다!라는 문자열을, 충족하지 못할 경우 아쉽지만 불합격입니다..라는 문자열을 출력해야 합니다. 코드를 잘 작성하셨다면, 아래와 같은 결과가 출력되어야 합니다.

# 실습 결과
축하합니다! 합격입니다!
아쉽지만 불합격입니다..


# 해설
일단 우리가 해야 될 일을 간단히 정리해 보면 두 가지 목표로 나눠 볼 수 있을 것 같은데요.

각 과목별 점수를 합산한다.
합산된 값을 가지고 합격 여부에 따라 상황에 맞는 문자열을 출력한다.
그럼 하나씩 차례대로 작성해 봅시다.

1. 점수의 합은 어떻게 계산하면 될까요? 합을 저장하는 변수를 정의하고, 점수를 하나씩 변수에 더하면 됩니다.

function passChecker(scoreObject) {
  let totalScore = 0;
}
totalScore를 0으로 초기화해 줘야 여기에 숫자를 더할 수 있습니다.

이제 객체를 돌면서 프로퍼티 값(점수)을 하나씩 더해 주면 되는데요. 객체를 돌 때는 for...in 반복문을 사용하면 됩니다.

function passChecker(scoreObject) {
  let totalScore = 0;

  for (let subject in scoreObject) {
    totalScore += scoreObject[subject];
  }
}
subject에는 프로퍼티 이름(키)이 전달되기 때문에 프로퍼티 값은 scoreObject[subject] 이렇게 가져올 수 있습니다. for...in 반복문이 헷갈리신다면 subject와 scoreObject[subject]를 한번 출력해 보세요!

2. 합격 여부를 판단할 때는 if문을 사용하면 되겠죠?

function passChecker(scoreObject) {
  let totalScore = 0;

  for (let subject in scoreObject) {
    totalScore += scoreObject[subject];
  }

  if (totalScore >= 60) {
    console.log('축하합니다! 합격입니다!');
  } else {
    console.log('아쉽지만 불합격입니다..');       
  }
}
totalScore가 60 이상이면 합격 메시지를 출력하고, 60 미만이면 불합격 메시지를 출력해 줍니다.

# 모범 답안
let hyesoonScore = {
  '데이터 모델링의 이해': 10,
  '데이터 모델과 성능': 8,
  'SQL 기본': 22,
  'SQL 활용': 18,
  'SQL 최적화 기본 원리': 20,
};

let minsoonScore = {
  '데이터 모델링의 이해': 14,
  '데이터 모델과 성능': 8,
  'SQL 기본': 12,
  'SQL 활용': 4,
  'SQL 최적화 기본 원리': 16,
};

function passChecker(scoreObject) {
  let totalScore = 0;

  for (let subject in scoreObject) {
    totalScore += scoreObject[subject];
  }

  if (totalScore >= 60) {
    console.log('축하합니다! 합격입니다!');
  } else {
    console.log('아쉽지만 불합격입니다..');
  }
}

// 테스트 코드
passChecker(hyesoonScore);
passChecker(minsoonScore);


# 투표 집계하기
# 실습 설명
태환이는 매년 학생회장 선거 때마다, 투표 집계 도우미 봉사를 하는데요. 작년까지는 표를 손수 세다가, 올해부터는 IT 시대에 더 적합한 솔루션을 개발하려고 합니다.

배열 votes에는 학생회 투표 결과가 저장되어 있습니다. 배열 votes의 정보를 토대로, 객체 voteCounter에 후보별 득표수를 정리하는 것이 목표입니다.

예를 들어서  votes가 ['장태환', '신성순', '신성순', '장태환', '장태환']라고 가정하면, voteCounter는 {'장태환': 3, '신성순': 2}가 되어야 하는 거죠.

코드를 잘 작성했다면, 다음과 같은 결과가 출력되어야 합니다.

# 실습 결과
{ '이재식': 17, '이규하': 23 }


# 해설
문제를 어떻게 접근하면 좋을까요? 일단 배열의 모든 요소를 살펴보면서 처리해 줘야 하니까 반복문을 사용하면 될 것 같습니다. 배열의 요소를 모두 돌고 싶을 때는 for...of 반복문을 사용하면 됩니다.

for (let name of votes) {
  // ...
}
변수 name에 배열의 요소가 할당됩니다.

그럼 name이 아직 votesCounter에 없는 경우와 있는 경우를 나눠서 생각해 봅시다.

votesCounter에 아직 name 프로퍼티가 없으면 name 프로퍼티를 추가하고, 값(득표수)을 1로 설정해 주고
votesCounter에 name 프로퍼티가 있으면 프로퍼티 값을 1 증가해 주면 될 것 같습니다.
프로퍼티가 객체에 존재하는지를 판단할 때는 in 연산자를 통해 확인할 수 있었죠? 이걸 모두 활용하면 다음과 같은 코드가 완성됩니다.

for (let name of votes) {
  if (name in voteCounter) {
    voteCounter[name] += 1;
  } else {
    voteCounter[name] = 1
  }
}

# 모범 답안
// 투표 결과 배열
let votes = [
  '이재식', '이재식', '이규하', '이규하', '이규하',
  '이재식', '이재식', '이규하', '이규하', '이재식',
  '이규하', '이규하', '이규하', '이규하', '이재식',
  '이재식', '이규하', '이재식', '이재식', '이재식',
  '이재식', '이재식', '이규하', '이규하', '이규하',
  '이규하', '이규하', '이재식', '이규하', '이규하',
  '이규하', '이규하', '이재식', '이규하', '이규하',
  '이규하', '이재식', '이재식', '이재식', '이규하',
]

// 후보별 득표수 객체
let voteCounter = {};

for (let name of votes) {
  if (name in voteCounter) {
    voteCounter[name] += 1;
  } else {
    voteCounter[name] = 1
  }
}

// 테스트 코드
console.log(voteCounter);


# 배열과 객체 정리
# 배열
배열(array)은 여러 값을 일렬로 저장하는 것입니다. (파이썬의 리스트와 비슷합니다.)

# 선언
대괄호로 선언합니다.

let topics = [
  '프로그래밍 시작하기 in Python',
  'Git',
  '소프트웨어 이해하기',
  '프로그래밍 시작하기 in JavaScript',
  '데이터 분석과 시각화',
];

# 인덱싱
0, 1, 2 같은 요소의 위치를 인덱스라고 하고, 인덱스로 요소를 접근하는 과정을 인덱싱이라고 합니다.

let topics = [
  '프로그래밍 시작하기 in Python',
  'Git',
  '소프트웨어 이해하기',
  '프로그래밍 시작하기 in JavaScript',
  '데이터 분석과 시각화',
];

console.log(topics[0]); // 프로그래밍 시작하기 in Python
console.log(topics[2]); // 소프트웨어 이해하기
console.log(topics[6]); // undefined
console.log(topics[-1]); // undefined
배열의 길이는 .length로 접근할 수 있습니다. 배열 길이는 마지막 요소에 접근할 때 많이 사용합니다.

console.log(topics.length); // 5
console.log(topics[topics.length-1]); // 데이터 분석과 시각화
slice() 함수를 통해 두 인덱스 사이에 있는 요소들을 잘라낼 수도 있습니다.

console.log(topics.slice(1, 4));
console.log(topics.slice(3));
console.log(topics.slice());
['Git', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript']
['프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']
['프로그래밍 시작하기 in Python', 'Git', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']
첫 번째 파라미터는 시작 인덱스, 두 번째 파라미터는 끝 인덱스인데요. (끝 인덱스에 있는 요소는 슬라이싱에 포함되지 않습니다.) 두 번째 파라미터를 생략하면 배열 끝까지 슬라이싱되고 파라미터를 전부 생략하면 배열 전체가 슬라이싱됩니다.

# 배열 수정하기
배열 끝에 요소를 추가하거나 삭제할 때는 push()와 pop(), 중간에 요소를 추가하거나 삭제할 때는 splice() 함수를 사용하면 됩니다. (물론 splice()로도 배열 끝에 추가하거나 삭제할 수 있지만 문법이 더 복잡하고 덜 직관적입니다.)

let topics = [
  '프로그래밍 시작하기 in Python',
  'Git',
  '소프트웨어 이해하기',
  '프로그래밍 시작하기 in JavaScript',
  '데이터 분석과 시각화',
];

// push(item1, item2, ...)
topics.push('머신 러닝 기본기');
console.log(topics);

// pop()
topics.pop();
console.log(topics);

// splice(start, deleteCount, item1, item2, ...);
topics.splice(2, 0, 'React 웹 개발 시작하기'); // 인덱스 2 위치에 'React 웹 개발 시작하기' 삽입
console.log(topics);

topics.splice(1, 2); // 인덱스 1에서부터 요소 2개 삭제
console.log(topics);
['프로그래밍 시작하기 in Python', 'Git', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화', '머신 러닝 기본기']
['프로그래밍 시작하기 in Python', 'Git', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']
['프로그래밍 시작하기 in Python', 'Git', 'React 웹 개발 시작하기', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']
['프로그래밍 시작하기 in Python', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']
기존 요소를 수정할 때는 그냥 인덱싱을 사용하면 됩니다.

let topics = [
  '프로그래밍 시작하기 in Python',
  'Git',
  '소프트웨어 이해하기',
  '프로그래밍 시작하기 in JavaScript',
  '데이터 분석과 시각화',
];

topics[0] = '파이썬 응용하기';
console.log(topics);
['프로그래밍 응용하기', 'Git', '소프트웨어 이해하기', '프로그래밍 시작하기 in JavaScript', '데이터 분석과 시각화']

# 배열과 반복문
let topics = [
  '프로그래밍 시작하기 in Python',
  'Git',
  '소프트웨어 이해하기',
  '프로그래밍 시작하기 in JavaScript',
  '데이터 분석과 시각화',
];

# 일반 for 반복문

for (let i = 0; i < topics.length; i++) {
  console.log(topics[i]);
}
프로그래밍 시작하기 in Python
Git
소프트웨어 이해하기
프로그래밍 시작하기 in JavaScript
데이터 분석과 시각화

# for...of 반복문

for (let topic of topics) {
  console.log(topic);
}
프로그래밍 시작하기 in Python
Git
소프트웨어 이해하기
프로그래밍 시작하기 in JavaScript
데이터 분석과 시각화
변수(topic)에 배열 요소가 하나씩 할당됩니다.

# 객체
객체(object)는 키와 값의 쌍을 저장합니다. (파이썬의 딕셔너리와 비슷합니다.)

# 선언
중괄호로 선언합니다.

let codeit = {
  name: '코드잇',
  bornYear: 2017,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript',
  },
};

# 프로퍼티
자바스크립트에서는 키와 값의 쌍 하나를 프로퍼티라고 하는데요. 따라서 키를 프로퍼티 네임(property name) 또는 프로퍼티 이름, 값을 프로퍼티 밸류(property value) 또는 프로퍼티 값이라고 부르기도 합니다.

프로퍼티 이름은 항상 문자열인데요. 일반적으로 따옴표 없이도 사용할 수 있지만 아래의 경우 꼭 따옴표를 사용해야 합니다.

프로퍼티 이름이 알파벳 문자, 언더바 기호(_), 또는 달러 기호($)로 시작하지 않음 (예: @name)
중간에 띄어쓰기나 하이픈 기호가 들어감 (예: worst course)
반면 프로퍼티 값은 아무 자료형일 수 있어요. 문자열, 숫자형, 배열, null, 심지어 객체 자체도 값이 될 수 있습니다.

# 프로퍼티 접근
let codeit = {
  name: '코드잇',
  bornYear: 2017,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript',
  },
};

# 점 표기법
console.log(codeit.name); // 코드잇

# 대괄호 표기법
console.log(codeit['name']); // 코드잇

아래 경우에는 꼭 점 표기법이 아닌 대괄호 표기법을 사용해야 합니다.

따옴표로 감싸야 하는 프로퍼티 이름일 때
변수로 프로퍼티에 접근할 때

# 변수로 프로퍼티 접근
let propertyName = 'founders';
console.log(codeit[propertyName]); // ['강영훈', '이윤수']

# 프로퍼티 연결
console.log(codeit.bestTopic.title); // 프로그래밍 시작하기 in JavaScript

# 프로퍼티가 없을 경우
console.log(codeit.members); // undefined

# 프로퍼티 존재 여부 확인
console.log('bestTopic' in codeit); // true;
console.log('members'in codeit); // false

# 프로퍼티 추가, 수정, 삭제
codeit.color = 'purple'; // color 프로퍼티 추가
codeit.bornYear = 2016; // bornYear 프로퍼티 수정
delete codeit.name; // name 프로퍼티 삭제

console.log(codeit);
{
  bornYear: 2016,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript'
  },
  color: 'purple'
}

# 메소드
프로퍼티 값이 함수일 수도 있는데요. 함수 프로퍼티는 메소드라고 부릅니다.

정의된 함수를 프로퍼티 값으로 설정해도 되고,

function welcome(name) {
  console.log(`코드잇에 오신걸 환영합니다 ${name}님!`);
}

let codeit = {
  name: '코드잇',
  bornYear: 2017,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript',
  },
  greet: welcome,
};
프로퍼티에서 바로 정의해도 됩니다. 바로 정의할 경우 프로퍼티 이름이 함수 이름이 되기 때문에 function 키워드 뒤에 함수 이름을 정의할 필요가 없습니다.

let codeit = {
  name: '코드잇',
  bornYear: 2017,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript',
  },
  greet: function (name) {
    console.log(`코드잇에 오신걸 환영합니다 ${name}님!`);
  },
};
메소드를 호출할 때는 다른 일반 프로퍼티에 접근하듯이 접근해서 괄호를 써주면 됩니다. 보통은 점 표기법을 사용하지만 대괄호 표기법도 사용할 수는 있습니다.

codeit.greet('재민'); // 코드잇에 오신걸 환영합니다 재민님!
codeit['greet']('재민'); // 코드잇에 오신걸 환영합니다 재민님!

# 객체와 반복문
객체의 모든 프로퍼티에 접근하고 싶을 때는 for...in 반복문을 사용합니다.

let codeit = {
  name: '코드잇',
  bornYear: 2017,
  founders: ['강영훈', '이윤수'],
  worstTopic: null,
  bestTopic: {
    title: '프로그래밍 시작하기 in JavaScript',
    language: 'JavaScript',
  },
};

for (let key in codeit) {
  console.log(key);
  console.log(codeit[key]);
}
name
코드잇
bornYear
2017
founders
['강영훈', '이윤수']
worstTopic
null
bestTopic
{title: '프로그래밍 시작하기 in JavaScript', language: 'JavaScript'}
변수(key)에 객체 키(프로퍼티 이름)가 하나씩 할당됩니다. 배열은 for...of, 객체는 for...in을 사용한다는 점 기억해 주세요!


# const 키워드
const PI = 3.14;

function area(radius) {
return radius * radius * PI;
}
console. log(area(5));

// const 는 배열 내용를 수정할수는 있으나 전체적인 배열을 새로운 값을 주게 되면 Assignment to constant variavle 오류가 발생한다.
const PI = ['A', 'B', 'C'];
PI[2] = 'B'; // OK

PI = ['E', 'F']; //error

// const의 변수는 대문자로 사용.



#Math와 Date 내장 객체

사용자가 따로 정의하지 않아도 자바스크립트가 미리 가지고 있는 객체들도 있는데요. 이런 객체들을 내장 객체, 영어로는 standard built-in objects라고 합니다. 개발자들이 많이 필요할 만한 기능들을 모아서 객체 형태로 저장해 놓은 건데요. 마치 파이썬의 스탠다드 라이브러리(standard library)와 비슷합니다. 이번 레슨에서는 Math라는 내장 객체와 Date라는 내장 객체를 살펴보면서 내장 객체에 대해 이해해 볼게요.

# Math
Math 내장 객체는 다양한 수학적 기능을 지원합니다. 프로그래밍을 하다 보면 기본적인 사칙연산보다 더 복잡한 수학적 기능이 필요할 때가 있는데요. 그럴 때는 Math 객체를 쓰면 됩니다. Math 객체는 자바스크립트에 내장돼있기 때문에 바로 사용할 수 있습니다.

/* PI 프로퍼티 */
console.log(Math.PI); // 3.141592653589793

/* floor() 내림 함수 */
console.log(Math.floor(3/2)); // 1

/* ceil() 올림 함수 */
console.log(Math.ceil(3/2)); // 2
PI 같은 프로퍼티도 있고, floor(), ceil() 같은 메소드도 있으니까 필요한 걸 골라 쓰면 되겠죠? Math 객체의 모든 프로퍼티와 메소드는 여기서 확인하실 수 있습니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math

# Date
프로그래밍을 하다 보면 날짜를 다뤄야 하는 일이 많습니다. 그럴 때 사용할 수 있는 것이 바로 Date 객체인데요. 날짜 생성, 포매팅, 연산 등을 지원합니다.

# 날짜 생성
먼저 날짜를 생성해 볼게요.

const date = new Date();

console.log(date);
Wed Jun 29 2022 13:00:00 GMT+0900 (Korean Standard Time)
이렇게 날짜를 생성하면 현재 날짜와 시간이 date에 저장됩니다. 참고로 시간대는 컴퓨터의 시간대 설정을 참고해서 자동으로 설정해 줍니다.

new Date() 같은 문법은 처음 만나보실 텐데요. Date는 일반적으로 날짜를 다루는 객체고, new Date()를 하면 특정 날짜를 저장하고 있는 객체를 하나 생성한다고 생각하시면 됩니다.

특정 날짜를 생성하려면 날짜 포맷을 문자열로 넘겨줘도 되고, 연도, 월, 날짜에 해당하는 숫자를 파라미터로 넘겨줘도 됩니다.

/* 문자열로 날짜 생성 YYYY-MM-DD */
const date1 = new Date('2022-06-29');

/* 문자열로 날짜 생성 YYYY-MM-DDThh:mm:ss */
const date2 = new Date('2022-06-29T13:00:00');

/* 숫자로 날짜 생성 new Date(year, month, date)
   주의: month는 월의 인덱스라서 1월은 0, 2월은 1, ..., 12월은 11입니다 */
const date3 = new Date(2022, 5, 29);

/* 숫자로 날짜 생성 new Date(year, month, date, hours, minutes, seconds)
   주의: month는 월의 인덱스라서 1월은 0, 2월은 1, ..., 12월은 11입니다 */
const date4 = new Date(2022, 5, 29, 13, 00, 00);

console.log(date1);
console.log(date2);
console.log(date3);
console.log(date4);
Wed Jun 29 2022 00:00:00 GMT+0900 (Korean Standard Time)
Wed Jun 29 2022 13:00:00 GMT+0900 (Korean Standard Time)
Wed Jun 29 2022 00:00:00 GMT+0900 (Korean Standard Time)
Wed Jun 29 2022 13:00:00 GMT+0900 (Korean Standard Time)
날짜 객체는 항상 시간까지 저장하는데요. 생성할 때 시간을 생략하면 00:00:00으로 설정되니까 유의해 주세요.

# 날짜 포매팅
저장해둔 날짜를 특정 포맷으로 보여주고 싶은 경우가 많은데요. 그럴 때는 아래 메소드들을 활용하시면 됩니다.

const date = new Date(2022, 5, 29, 13, 00, 00);

console.log(date.getFullYear());
console.log(date.getMonth()); // 주의: 0에서 시작
console.log(date.getDate());
console.log(date.getHours());
console.log(date.getMinutes());
console.log(date.getSeconds());
console.log(date.getMilliseconds());
2022
5
29
13
0
0
0
문자열 포매팅(``)을 사용하면 날짜를 원하는 대로 출력할 수 있습니다.

console.log(`오늘은 ${date.getFullYear()}년 ${date.getMonth() + 1}월 ${date.getDate()}일입니다.`);
오늘은 2022년 6월 29일입니다.

# 날짜 연산
두 날짜의 차이를 계산할 수도 있는데요. 날짜에서 다른 날짜를 빼면 차이를 밀리초로 계산해 줍니다.

const date1 = new Date(2022, 5, 29, 11, 30, 00);
const date2 = new Date(2022, 5, 29, 13, 00, 00);

const timeDifference = date2 - date1;

console.log(timeDifference);
5400000
이걸 이용해서 시간이 얼마나 흘렀는지 계산할 수도 있겠죠?

console.log(timeDifference + ' 밀리초');
console.log(timeDifference/1000 + ' 초');
console.log(timeDifference/1000/60 + ' 분');
console.log(timeDifference/1000/60/60 + ' 시간');
5400000 밀리초
5400 초
90 분
1.5 시간
Date 객체에는 다른 유용한 기능도 많은데요. Date 객체의 모든 프로퍼티와 메소드는 여기서 확인하실 수 있습니다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date


# 
# 점심 메뉴 랜덤 선택기
실습 설명
점심 메뉴를 고르는 것은 많은 이들의 고민입니다. 이번 과제에서는 여러 점심 메뉴 후보 중에서 랜덤으로 메뉴를 골라 주는 코드를 작성해 볼게요.

지금 코드잇 실행기에는 fetch() 함수를 써서, 외부로부터 메뉴 후보 리스트를 가져오고, 이 메뉴 후보들 중에 하나를 랜덤으로 골라주는 getRandomMenu() 함수가 있습니다.

메뉴 후보 리스트는 이 URL로부터 가져옵니다.

메뉴 후보 리스트 URL : https://learn.codeit.kr/api/menus
지금 getRandomMenu() 함수 안에서 실행되는 pick이라는 함수는 랜덤으로 정해진 메뉴를 작업 성공 결과로 가진 Promise 객체를 리턴하는 함수입니다. 만약 메뉴 후보 리스트의 길이가 0이라면 Need Candidates!(후보 메뉴들이 필요합니다!)라는 메시지를 가진 에러 객체를 생성하고 그것을 reject() 함수의 파라미터로 전달하고 실행하죠.


# 모범 답안

function pick(menus) {
  console.log('Pick random menu!');
  const p = new Promise((resolve, reject) => {
    if (menus.length === 0) {
      reject(new Error('Need Candidates'));
    } else {
      setTimeout(() => {
        const randomIdx = Math.floor(Math.random() * menus.length);
        const selectedMenu = menus[randomIdx];
        resolve(selectedMenu);
      }, 1000); // 시간이 걸리는 걸 시뮬레이션하기 위한 1초입니다.
    }
  });
  return p;
}

function getRandomMenu() {
  return fetch('https://learn.codeit.kr/api/menus')
    .then((response) => response.json())
    .then((result) => {
      const menus = result;
      return pick(menus); // ! random pick function
    });
}

getRandomMenu()
  .then((menu) => {
    console.log(`Today's lunch is ${menu.name} ~`);
  })
  .catch((error) => {
    console.log(error.message);
  })
  .finally(() => {
    console.log('Random Menu candidates change everyday');
  });

'Promise 객체를 직접 만들 때, 생성된 Promise 객체를 fulfilled 상태로 만들어주는 함수는 resolve 함수입니다. 그리고 resolve 함수의 파라미터로 작어 성공 결과를 전달하면 되는데요. 여기서는 선택된 메뉴를 의미하는 selectedMenu를 넣어서 resolve(selectedMenu)라고 쓰면 되겠죠?

지금 보이는 예시 코드에는 지금까지 우리가 배운 내용들이 종합적으로 반영되어 있습니다. 코드를 처음부터 끝까지 천천히 읽어 보시고 혹시 이해가 안 되는 부분이 보인다면 이전 내용을 복습하고 돌아와 주세요.


# 여러 Promise 객체를 다루는 방법(심화)

1. all 메소드
설명을 하기에 앞서 바로 코드를 보겠습니다.

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  });
지금 이 코드에는 서로 다른 3개의 URL로 리퀘스트를 보내는 fetch 함수들이 보입니다. URL을 자세히 보니 이전에 사용했던 직원 정보에 관한 학습용 URL이네요. 지금 1번, 2번, 3번 직원의 정보를 각각 요청하고 있죠?

그 다음 부분을 보면, Promise의 all이라는 메소드를 호출하고 있고, all 메소드의 아규먼트로는 배열 하나가 들어있습니다. 그 배열의 요소들은, 각 직원 정보를 요청하고 받아서 Deserialize까지 수행한 작업 성공 결과를 담고 있는 Promise 객체들인 p1, p2, p3 객체입니다.

이 all 메소드는 무슨 기능을 하는 걸까요? all 메소드도 then 메소드처럼 새로운 Promise 객체를 리턴하는데요. 
all 메소드는 이렇게 아규먼트로 들어온 배열 안에 있는 모든 Promise 객체가 pending 상태에서 fulfilled 상태가 될 때까지 기다립니다. 
그리고 모든 Promise 객체들이 fulfilled 상태가 되면, all 메소드가 리턴했던 Promise 객체는 fulfilled 상태가 되고, 
각 Promise 객체의 작업 성공 결과들로 이루어진 배열을, 그 작업 성공 결과로 갖게 됩니다.

이 코드를 직접 실행해보면,



이렇게 all 메소드가 리턴한 Promise 객체는,

(1) 각 개별 Promise 객체의 작업 성공 결과로 이루어진 배열을 
(2) 자신의 작업 성공 결과로 갖는다는 것을 알 수 있습니다.

배열의 각 요소로 각 직원 정보 객체가 잘 보이죠? 이렇게 all 메소드는 여러 Promise 객체의 작업 성공 결과를 기다렸다가 모두 한 번에 취합하기 위해서 사용합니다.

그런데 만약 p1~3 객체들 중 하나라도, rejected 상태가 되면 어떻게 될까요?

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learnnnnnn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  });
마지막 fetch 함수에 존재하지 않는 URL 주소를 적고 코드를 다시 실행해보겠습니다. 코드를 실행해보면



마지막 fetch 함수에서 문제가 발생해서 p3가 rejected 상태가 되면, 
all 메소드가 리턴한 Promise 객체는 p3 객체처럼 rejected 상태가 되고 동일한 작업 실패 정보를 갖게 됩니다. 
이렇게 all 메소드는 하나의 Promise 객체라도 rejected 상태가 되면, 전체 작업이 실패한 것으로 간주해야 할 때 사용합니다. 
그리고 이렇게 Promise 객체가 하나라도 rejected 상태가 되는 경우에 대비하려면 
이전에 배웠던 것처럼

// 1번 직원 정보
const p1 = fetch('https://learn.codeit.kr/api/members/1').then((res) => res.json());
// 2번 직원 정보
const p2 = fetch('https://learn.codeit.kr/api/members/2').then((res) => res.json());
// 3번 직원 정보
const p3 = fetch('https://learnnnnnn.codeit.kr/api/members/3').then((res) => res.json());

Promise
  .all([p1, p2, p3])
  .then((results) => {
    console.log(results); // Array : [1번 직원 정보, 2번 직원 정보, 3번 직원 정보]
  })
  .catch((error) => {
    console.log(error);
  });
그냥 이렇게 catch 메소드를 붙여주면 됩니다. 어차피 all 메소드도 Promise 객체를 리턴하니까 특별히 새로울 건 없겠죠?

2. race 메소드
race 메소드도 all 메소드와 마찬가지로 여러 Promise 객체들이 있는 배열을 아규먼트로 받습니다. 그리고 race 메소드도 all 메소드처럼 Promise 객체를 리턴하는데요. 하지만 그 적용 원리가 다릅니다.
race 메소드가 리턴한 Promise 객체는 아규먼트로 들어온 배열의 여러 Promise 객체들 중에서 
가장 먼저 fulfilled 상태 또는 rejected 상태가 된 Promise 객체와 동일한 상태와 결과를 갖게 됩니다.

예를 들어 이런 코드가 있다고 할 때,

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Success'), 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail')), 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail2')), 4000);
});

Promise
  .race([p1, p2, p3])
  .then((result) => {
    console.log(result); // hello 출력
  })
  .catch((value) => {
    console.log(value);
  });
지금 race 메소드 안의 배열에 들어있는 Promise 객체들 중에서 무엇이 가장 빨리 fulfileld 또는 rejected 상태가 될까요? 
답은 1초 후에 fulfilled 상태가 되는 p1 객체입니다.
p1 객체는 1초 후에 fulfilled 상태가 되고, 그 작업 성공 결과로 문자열 Success를 가지게 되는데요. 
p2는 2초 후에, p3는 4초 후에 rejected 상태가 됩니다.

race 메소드가 리턴한 Promise 객체는 이 중에서 가장 빨리 상태 정보가 결정된 p1 객체와 동일한 상태와 결과를 가집니다. 
말그대로 race 메소드는 여러 Promise 객체들을 레이스(race, 경쟁)시켜서 가장 빨리 상태가 결정된 Promise 객체를 선택하는 메소드입니다. 
이 코드를 실행하면

ffjn3h9v7-Untitled 2.png

p1 객체의 작업 성공 결과였던 문자열 Success가 잘 출력됩니다.

만약 setTimeout에 넣었던 밀리세컨즈를 이렇게 바꾼다면

const p1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Success'), 6000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail')), 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail2')), 4000);
});

Promise
  .race([p1, p2, p3])
  .then((result) => {
    console.log(result); // hello 출력
  })
  .catch((value) => {
    console.log(value);
  });
이번에는 p2가 p1보다 더 빨리 상태가 결정됩니다. 그럼 결국 race 메소드가 리턴한 Promise 객체는 p2처럼 rejected 상태가 되고 동일한 작업 실패 정보를 갖게 됩니다. 이 코드를 실행해보면

hcvsx469q-Untitled 3.png

Error 객체의 정보가 잘 출력되는 것을 알 수 있습니다. 


자, all 메소드와 race 메소드 잘 이해되시나요? 실무에서는 이렇게 여러 Promise 객체들을 한꺼번에 다뤄야할 때도 있습니다. 그럴 때 각 용도에 적합한 메소드를 사용하면 되는데요.  
all 메소드나 race 메소드 말고 allSettled, any라는 메소드도 있습니다. 
이것들도 all, race 메소드처럼 Promise 객체 배열을 아규먼트로 받고 Promise 객체를 리턴하는데요.

이것들도 간단하게 설명하겠습니다.

각 메소드가 리턴한 Promise 객체가 A라고 할 때,

allSettled 메소드 : 배열 내의 모든 Promise 객체가 fulfilled 또는 rejected 상태가 되기까지 기다리고, pending 상태의 Promise 객체가 하나도 없게 되면, A의 상태값은 fulfilled 상태가 되고 그 작업 성공 결과로, 하나의 배열을 갖게 됩니다. 
이 배열에는 아규먼트로 받았던 배열 내의 각 promise 객체의

(1) 최종 상태를 status 프로퍼티, 
(2) 그 작업 성공 결과는 value 프로퍼티, 
(3) 그 작업 실패 정보는 reason 프로퍼티

에 담은 객체들이 요소로 존재합니다. 
이런 식으로 말이죠.

[
   {status: "fulfilled", value: 1},
   {status: "fulfilled", value: 2},
   {status: "fulfilled", value: 3},
   {status: "rejected",  reason: Error: an error}
]
참고로 fulfilled 상태와 rejected 상태를 묶어서 settled 상태라고 하는데요. allSettled 메소드는 말 그대로 배열 속 Promise 객체들이 settled 상태가 되기만 하면 되는 겁니다. 이에 반해 위에서 배운 all 메소드는 모든 Promise 객체들이 fulfilled 상태가 되기를 기다리는 거구요.

any 메소드 : 여러 Promise 객체들 중에서 가장 먼저 fulfilled 상태가 된 Promise 객체의 상태와 결과가 A에도 똑같이 반영됩니다. 만약 모든 Promise 객체가 rejected 상태가 되어버리면 AggregateError라고 하는 에러를 작업 실패 정보로 갖고 rejected 상태가 됩니다. any라는 단어의 뜻처럼 배열 속의 Promise 객체 중 단 하나라도 fulfilled 상태가 되면 되는 겁니다.

자, 각 메소드의 이름과 그 성질을 매칭해서 기억해보세요. 나중에 혹시 정확한 성질이 기억나지 않더라도 다시 찾아보면 되니까 지금 잘 이해해두는 것이 중요합니다. 참고로 어떤 메소드든 결국 하나의 Promise 객체를 리턴하기 때문에 그 리턴 결과를 Promise Chain에서 자유롭게 사용할 수 있다는 점을 기억해두세요.

혹시 각 메소드들의 사용법을 좀더 자세히 보고 싶은 분들은 아래 링크를 참조하세요.

all 메소드 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
race 메소드  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
allSettled 메소드  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled
any 메소드  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any


# 문장과 표현식
이번 챕터를 본격적으로 시작하기 전에, 자바스크립트의 다양한 문법들을 이해할 때 알아두면 유용한 기초 개념을 한 번 짚고 넘어가고자 합니다. 
바로, 문장과 표현식에 대한 개념인데요. 영어로는 각각 statements와 expressions라고 부릅니다.

문장 (statements)
우리가 작성하는 모든 자바스크립트 코드는 모두 문장과 표현식으로 구성되어 있습니다. 
먼저, 자바스크립트에서 문장은 어떤 동작이 일어나도록 작성된 최소한의 코드 덩어리를 가리킵니다.

예를 들어서

let x; 
x = 3;

if (x < 5) {
  console.log('x는 5보다 작다');
} else {
  console.log('x는 5와 같거나 크다');
}

for (let i = 0; i < 5; i++) {
  console.log(i);
}
이 코드의 첫 번째 줄도 x라는 변수를 선언하는 동작이 일어나는 하나의 문장이고, 두 번째 줄도 x에 3이라는 값을 할당하는 동작이 일어나는 하나의 문장입니다. 그리고 4번줄 부터 8번줄 까지도 하나의 문장이고 그리고 10번줄 부터 12번줄 까지도 반복 동작을 하는 문장의 예시라고 볼 수 있는데요.
선언문, 할당문, 조건문, 반복문 .. 이렇게 끝에 문이라고 붙은 이유가 모두 동작을 수행하는 문장이기 때문입니다.

표현식 (expressions)
표현식은 결과적으로 하나의 값이 되는 모든 코드를 가리킵니다. 이게 무슨 말이냐면,

5 // 5

'string' // string
어떤 하나의 값을 그대로 작성하는 것도 표현식이지만,

5 + 7 // 12

'I' + ' Love ' + 'Codeit' // I Love Codeit

true && null // null
이렇게 연산자를 이용한 연산식도 결국은 하나의 값이 되고,

const title = 'JavaScript';
const codeit = {
  name: 'Codeit'
};
const numbers = [1, 2, 3];

typeof codeit // object
title // JavaScript
codeit.name // Codeit
numbers[3] // undefined
위 코드의 마지막 네 줄처럼 선언된 변수를 호출하거나, 객체의 프로퍼티에 접근하는 것도 결국에는 하나의 값으로 평가되는데요. 그래서 길이와는 상관없이 결과적으로 하나의 값이 되는 코드를 모두 표현식이라고 할 수가 있습니다.

표현식이면서 문장, 문장이면서 표현식
표현식은 보통 문장의 일부로 쓰이지만, 그 자체로 문장일 수도 있습니다. 가장 대표적인 예시가 할당식과 함수 호출인데요.

// 할당 연산자는 값을 할당하는 동작도 하지만, 할당한 값을 그대로 가지는 표현식이다.
title = 'JavaScript'; // JavaScript

// 함수 호출은 함수를 실행하는 동작도 하지만, 실행한 함수의 리턴 값을 가지는 표현식이다.
sayHi(); // sayHi 함수의 리턴 값

// console.log 메소드는 콘솔에 아규먼트를 출력하는 동작도 하지만, undefined 값을 가지는 표현식이다.
console.log('hi'); // undefined
사실은 할당연산자 자체가 할당한 값을 그대로 리턴하는 특징이 있기 때문에 연산 자체로 값이 되는 표현식이기도 합니다. 그런데 할당식은 왼쪽에 있는 피연산자에 오른쪽 피연산자 값을 할당하는 동작을 하기 때문에, 문장이 되기도 하죠?
그리고 함수 호출도 함수를 호출한 자리가 결국에는 하나의 리턴하는 값을 가지기 때문에 표현식이라고 할 수도 있지만 함수 내부에 정의한 코드를 실행하는 동작이기 때문에 문장이 되기도 하는 것이죠.

표현식인 문장 vs 표현식이 아닌 문장
결과적으로 문장은 다시 표현식인 문장과, 표현식이 아닌 문장으로 나눌 수 있는데요.
이 둘을 구분하는 가장 간단한 방법은 우리가 구분하고자 하는 문장을 변수에 할당하거나, 어떤 함수의 아규먼트로 전달해보는 겁니다.

let x; 
x = 3;

console.log(if (x < 5) {
  console.log('x는 5보다 작다');
} else {
  console.log('x는 5보다 크다');
});

const someloop = for (let i = 0; i < 5; i++) {
  console.log(i);
};
console.log 메소드의 아규먼트로 if문을 전달하거나 someloop라는 변수에 for 반복문을 할당하게 되면, Error가 발생하게 되는데요.
조건문이나 반복문은 값으로 평가되지 않고 오로지 문장으로만 평가되기 때문입니다.

마무리
이번 시간에는 문장과 표현식에 대해서 살펴봤는데요. 처음 프로그래밍을 공부할 때는 여러 문법들 속에 이 둘의 개념이 코드 속에 너무나도 자연스럽게 녹아있기 때문에 별로 중요하게 생각하지 않고 그냥 넘어가는 경우가 생각보다 많이 있는데요.
다른 사람들이 작성한 코드의 맥락을 이해하는데에도 도움이 되지만, 자바스크립트의 문법을 좀 더 깊이 이해하고 능숙하게 다루기 위해서도 이 문장과 표현식에 대한 개념을 명확히 해 두는 것이 좋습니다.

참고로 자바스크립트에서 특별한 경우를 제외하면 일반적으로 표현식인 문장은 세미콜론으로, 표현식이 아닌 문장은 문장 자체의 코드 블록(중괄호)로 그 문장의 범위가 구분되는데요.

(3 + 4) * 2;
console.log('Hi!');

while(true) {
  x++;
}
그래서 다른 사람들이 작성한 코드를 볼 때도 이 세미콜론과 중괄호를 따라가 보면 좀 더 쉽게 표현식인 문장과 표현식이 아닌 문장을 구분할 수가 있는데요. 물론 우리가 코드를 작성할 때도 이런 점을 잘 구분해서 세미콜론을 사용하는 게 좋겠죠!?


# Constructor Function 생성자 함수

function User(email, birthdate) {
  this.email = email;
  this.birthdate = birthdate;
  this.buy = function (item) {
    console.log('${this.email} buys ${item.name}');
  };
}

const item = {
  name: '스웨터',
  price: 30000.
};

const user1 = new User('chris123@google.com', '1992-03-21');
console.log(user1.email);
console.log(user1.birthdate);
user1.buy(item);

# Constructor Function 사용시 // new 를 잊지 말고 넣어주자. 그리고 첫번째 글자는 대문자. new User
자바스크립트에서는 일반 함수와 달리 객체를 생성하는 용도로 사용할 함수인 Constructor function을 정의할 수 있습니다. Constructor function 앞에 new 키워드를 붙이고 실행하면 객체를 생성할 수 있습니다. 그리고 Constructor function은 보통 함수 이름의 첫 번째 알파벳을 대문자로 적어준다는 사실을 기억하세요.


## 객체 만들기 3: Class
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log('${this.email} buys ${item.name}');
  }
}


## 객체 만들기 정리
# 1. Object literal과 Factory function 사용하기
function createUser(email, birthdate) {
  const user = {
    email,
    birthdate,
    buy(item) {
      console.log(`${this.email} buys ${item.name}`);
    },
  };
  return user;
}

const user1 = createUser('chris123@google.com', '19920321');
const user2 = createUser('jerry99@google.com', '19950719');
const user3 = createUser('alice@google.com', '19931224');
객체를 생성하는 Factory function을 만들고, 그 안에서 Object literal로 객체를 생성하여 리턴하는 방법입니다.

# 2. Constructor function 사용하기
function User(email, birthdate) {
  this.email = email;
  this.birthdate = birthdate;
  this.buy = function (item) {
    console.log(`${this.email} buys ${item.name}`);
  };
}

const user1 = new User('chris123@google.com', '1992-03-21');
const user2 = new User('jerry99@google.com', '1995-07-19');
const user3 = new User('alice@google.com', '1993-12-24');
객체를 생성하는 용도로 사용하는 Constructor function을 정의하고, 그 안에서 this 키워드를 사용하여 생성될 객체의 프로퍼티와 메소드를 설정하는 방법입니다. Constructor function으로 객체를 생성하려면 그 앞에 new를 붙여서 실행해야 한다는 사실, 반드시 기억하세요.

# 3. class 키워드 사용하기
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
}

const user1 = new User('chris123@google.com', '1992-03-21');
const user2 = new User('jerry99@google.com', '1995-07-19');
const user3 = new User('alice@google.com', '1993-12-24');

class 키워드를 사용해서 객체의 틀을 정의하고, 마찬가지로 그 앞에 new를 붙여서 객체를 생성하는 방법입니다. class를 사용할 때는 보통 프로퍼티의 경우 constructor 안에 정의하고, 메소드의 경우 constructor 밖에 정의합니다.
이 밖에도 자바스크립트로 객체를 만들 수 있는 방법에는 여러 가지가 있지만 일단은 이 정도만 아셔도 충분합니다.
이제 다음 챕터에서는 객체 지향 프로그래밍을 할 때 알아야 하는 기본 개념들을 배울 건데요. 이때 위의 세 가지 방법 중에서 class 키워드를 사용하는 방법을 쓸 겁니다. Factory function이나 Constructor function을 사용해도 문제는 없지만, class는 자바스크립트 뿐만 아니라 Java 등의 다른 언어에서도 등장하는 보편적인 용어이고, 그 자체로 객체 지향의 원리를 나타내기에 적절해서 React 등의 유명 프레임워크에서도 사용하던 방식이기 때문입니다.

클래스로 객체가 생성될 때는 constructor(생성자 함수) 안의 코드가 실행됩니다. 따라서 해당 객체의 프로퍼티를 설정하는 코드를 constructor(생성자 함수) 안에 넣어주면 됩니다. 참고로 메소드는 보통 constructor 밖에 써줍니다.


## 
# 해설
class Car {
  constructor(color, speed) {
    this.color = color;
    this.speed = speed;
  }

  run() {
    console.log(`Runs at ${this.speed}`);
  }
}

const car1 = new Car('blue', '100km/h');

car1.run();
이렇게 class 뒤에 Car라는 이름을 붙이고 그 안에 constructor(생성자 함수)를 정의해 줍니다. 이때 매번 생성되는 객체를 의미하는 this 키워드를 사용해서 프로퍼티를 설정하면 됩니다. 메소드는 constructor 바깥으로 옮겨 주세요. 그리고 클래스 이름 앞에 new를 붙여서 실행하면 객체를 생성할 수 있습니다.

자바스크립트에서 객체를 생성하는 3 가지 방법

Object literal과 Factory function
Constructor function
class 키워드
이 3 가지를 잘 기억하세요.

(다른 방법들도 있지만 다른 방법들은 여러분이 좀더 많은 공부를 해야 이해할 수 있습니다.)


## 추상화
객체 지향 프로그래밍 핵심 개념 4가지 : 추상화, 캡슐화, 상속, 다형성

추상화는 어떤 구체적인 존재를 원하는 방향으로 간략화해서 나타내는 것.

User
유저 객체의 속성 - 프로퍼티
유저 객체의 행동 - 메소드

# 변수와 객체의 이름 짓기 중요

## 추상화 직접 해보기
# 해설
class BankAccount {
  constructor(name, money) {
    // 소유주
    this.holder = name;
    // 잔액
    this.balance = money;
  }

  // 입금하기
  deposit(money) {
    this.balance += money;
  }

  // 출금하기
  withdraw(money) {
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
    }
  }

  // 이체하기
  transfer(money, anotherAccount) {
    const account = anotherAccount;
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
      account.balance += money;
    }
  }
}
이렇게 프로퍼티와 메소드에 간단한 주석을 달아 보았는데요.

객체를 만들 때 중요한 것은, 누구나 쉽게 이해할 수 있는 적절한 프로퍼티 이름과 메소드 이름을 지어주는 것입니다. 이것만으로 부족하다고 느껴질 때, 이렇게 주석을 달거나 별도의 설명 문서를 남기는 것이죠.

사실 개발자들이 가장 어려워하는 것 중 하나가 바로 이렇게 프로퍼티와 메소드의 이름을 짓는 일입니다. 좋은 이름일 수록 나중에 코드를 해석할 때 드는 시간적인 비용이 줄어들기 때문입니다.

개발자는 이름을 잘 짓는 사람이 되어야한다는 사실, 잊지 맙시다!


## 캡슐화  // 특정 프로퍼티 값을 이상하게 입력했을 때 에러를 발생 시킨다.
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }

# // getter 메소드
  get email() {
  return this._email;
  // return 'Email Address is ${this._email}';
  }

# // setter 메소드
  set email(address) {
    if(address.includes('@')) {
      this._email = address;
    } else {
      throw new Error('invalid email address');
    }
  } 
}


## 캡슐화 더 알아보기
# 1. 완벽한 캡슐화를 하는 법
이전 영상에서는 다음 코드로 캡슐화를 배웠습니다.

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }

  get email() {
    return this._email;
  }

  set email(address) {
    if (address.includes('@')) {
      this._email = address;
    } else {
      throw new Error('invalid email address');
    }
  }
}

const user1 = new User('chris123@google.com', '1992-03-21');
user1.email = 'newChris123@google.com';
console.log(user1.email);
이제 이 코드를 보면 _email 프로퍼티에 직접 접근하지 말고, email이라는 getter/setter 메소드로만 접근해야 한다는 것이 눈에 잘 보입니다. 하지만 사실 완벽한 캡슐화가 된 상태는 아닙니다. 왜냐하면 보호하려는 프로퍼티 _email에

console.log(user1._email);
user1._email = 'chris robert';
이런 식으로 여전히 직접 접근할 수는 있기 때문입니다.

사실 자바스크립트에는 캡슐화를 자체적으로 지원하는 문법이 아직 없습니다.(Java는 private이라는 키워드가 있어서 언어의 문법 차원에서 캡슐화를 지원합니다.)

하지만 JavaScript에서도 다른 방식으로 우회해서 완벽한 캡슐화를 할 수는 있는데요. 클로저(Closure)라고 하는 개념을 응용해서 적용하면 됩니다. 잠깐 아래 코드를 보세요.

function createUser(email, birthdate) {
  let _email = email;

  const user = {
    birthdate,

    get email() {
      return _email;
    },

    set email(address) {
      if (address.includes('@')) {
        _email = address;
      } else {
        throw new Error('invalid email address');
      }
    },
  };

  return user;
}

const user1 = createUser('chris123@google.com', '19920321');
console.log(user1.email);
지금 이 코드를 보면 createUser라고 하는 Factory function이 보입니다. 그런데 생성하려는 user 객체 안에 _email 프로퍼티가 있는 게 아니라,

(1) createUser 함수 안에, 
(2) 그리고 user 객체 바깥에 _email이라는 변수가 있죠?

대신에 user 객체 안에는 _email 변수의 값을 읽고 쓸 수 있는 email이라는 getter/setter 메소드가 있습니다.

지금 마지막 부분에서 createUser라는 Factory function으로 user1이라는 객체를 생성하고, user1 객체의 email getter 메소드를 호출했는데요. 이 코드의 실행 결과를 확인해보면,

l352hqvzb-Untitled.png

이렇게 _email 변수의 값이 잘 출력됩니다. 함수 안의 변수의 값을 이미 리턴된 객체에서 읽은 건데요. 어떻게 이게 가능한 걸까요? 이것은 자바스크립트의 클로저(Closure)라고 하는 것 덕분에 가능합니다.

클로저란 자바스크립트에서 어떤 함수와 그 함수가 참조할 수 있는 값들로 이루어진 환경을 하나로 묶은 것을 의미하는데요. 예를 들어, 지금 createUser 함수가 실행되는 시점에 email이라는 getter/setter 메소드는 _email 이라는 변수의 값에 접근할 수 있는 상태입니다. 그리고 여기서 핵심은 이 email getter/setter 메소드들은 메소드를 갖고 있는 객체가 리턴된 이후더라도 여전히 _email에 접근하는 것이 가능하다는 점입니다. 바로 이렇게 함수가 정의된 당시에 참조할 수 있었던 변수들을 계속 참조할 수 있는 상태의 함수를 클로저라고 합니다. 이 클로저는 다른 프로그래밍 언어에서는 쉽게 찾아보기 힘든 자바스크립트만의 특징인데요.(물론 클로저 개념이 있는 다른 언어들도 있습니다)

보통 다른 프로그래밍 언어였다면 createUser 함수 내부가 실행될 때만 email getter/setter 메소드가 _email 변수에 접근할 수 있었겠지만, 자바스크립트에서는 클로저라는 개념으로 해당 환경을 함수와 함께 그대로 유지시켜주는 것입니다.

만약 클로저가 아닌 경우에는 _email 변수에 접근할 수 없습니다. 만약 이런 식으로

function createUser(email, birthdate) {
  let _email = email;

  const user = {
    birthdate,

    get email() {
      return _email;
    },

    set email(address) {
      if (address.includes('@')) {
        _email = address;
      } else {
        throw new Error('invalid email address');
      }
    },
  };

  return user;
}

const user1 = createUser('chris123@google.com', '19920321');
console.log(user1._email); // _ 추가
user1 객체의 _email 프로퍼티에 접근하려고 하면, user1 객체 자체 내에는 _email이라고 하는 프로퍼티가 없고, 바깥의 _email 변수에 현재 접근할 수도 없기 때문에

ttb9ieohb-Untitled 1.png

undefined가 출력됩니다.

이런 식으로 자바스크립트에서는 클로저를 사용해서 완벽한 캡슐화를 할 수 있습니다. 신기하죠? 사실 자바스크립트로 프로그래밍을 할 때 캡슐화가 얼마나 중요한지, 꼭 해야하는지에 관해서는 논란이 많습니다. 하지만 어떤 상황이든 이런 식으로 완벽하게 캡슐화를 할 수 있다 정도는 알아두는 게 좋습니다.

# 2. 메소드도 캡슐화할 수 있어요
이때까지 우리는 프로퍼티를 보호하기 위해 getter/setter 메소드를 활용하거나, 좀더 완벽한 캡슐화를 위해 클로저를 사용할 수 있다는 것을 배웠습니다. 그런데 사실 프로퍼티 뿐만 아니라 메소드를 캡슐화하는 것도 가능합니다. 잠깐 이 코드를 볼까요?

function createUser(email, birthdate) {
  const _email = email;
  let _point = 0;

  function increasePoint() {
    _point += 1;
  }

  const user = {
    birthdate,

    get email() {
      return _email;
    },

    get point() {
      return _point;
    },

    buy(item) {
      console.log(`${this.email} buys ${item.name}`);
      increasePoint();
    },
  };

  return user;
}

const item = {
  name: '스웨터',
  price: 30000,
};

const user1 = createUser('chris123@google.com', '19920321');
user1.buy(item);
user1.buy(item);
user1.buy(item);
console.log(user1.point);

저는 _point라는 변수를 추가했는데요. 사용자가 물건을 살 때마다 1포인트씩 적립해 줄 목적으로 만든 변수입니다. 그리고 point getter 메소드도 지금 정의해둔 상태입니다. _point 변수를 1씩 늘려주는 함수는 바로 밑에 보이는 increasePoint라는 함수입니다.

이 increasePoint 라는 함수는 유저 객체의 buy 메소드 안에서 쓰이고 있는데요. buy 메소드를 실행할 때 그 안에서 increasePoint 함수도 호출을 해주는 겁니다. 맨 마지막 부분의 코드들을 보면 user1 객체의 buy 메소드를 호출하고 point getter 메소드를 호출하고 있는데요. 이 코드를 실행해보면

dz6mags1e-Untitled 2.png

이렇게 스웨터를 3번 구매했을 때, 포인트는 총 3점이 쌓이게 됩니다.

자, 여기서 중요한 점은 지금 increasePoint라는 함수가 보호받고 있는 함수라는 점입니다. 지금 user1 객체로 바로 increasePoint 함수를 호출할 수는 없습니다. 호출하려고 하면

function createUser(email, birthdate) {
  const _email = email;
  let _point = 0;

  function increasePoint() {
    _point += 1;
  }

  const user = {
    birthdate,

    get email() {
      return _email;
    },

    get point() {
      return _point;
    },

    buy(item) {
      console.log(`${this.email} buys ${item.name}`);
      increasePoint();
    },
  };

  return user;
}

const item = {
  name: '스웨터',
  price: 30000,
};

const user1 = createUser('chris123@google.com', '19920321');
user1.buy(item);
user1.buy(item);
user1.buy(item);
console.log(user1.point);
user1.increasePoint(); // user1 객체로 increasePoint 직접 호출
uwed3yw8k-Untitled 3.png

이렇게 그런 함수가 없다는 에러가 출력됩니다. 왜냐하면 user1 객체에는 increasePoint라는 메소드가 없기 때문입니다. 
지금 저는 increasePoint가 유저 객체 안에서 적절한 곳에 사용되어야 하고, 
아무렇게나 함부로 호출해서는 안 되는 메소드라고 가정하고 이렇게 캡슐화를 한 것입니다. 
이런 식으로 메소드(정확하게 말하자면 increasePoint가 메소드는 아니니까 함수라고 할 수 있겠죠?)도 프로퍼티와 마찬가지로 
클로저를 통해 캡슐화를 해서 보호할 수 있다는 사실, 잘 기억하세요.


## 캡슐화 직접 해보기
# 실습 설명
현재 코드잇 실행기에는 '은행 계좌'를 의미하는 BankAccount 클래스가 정의되어 있습니다. 이 클래스 안의 _balance 프로퍼티는 해당 계좌의 잔액을 의미하는 프로퍼티인데요.

이 _balance 프로퍼티에 직접 접근해서 값을 수정하는 것은 매우 위험한 일입니다. 따라서 이 프로퍼티를 캡슐화하려고 하는데요. 지금 balance라는 getter 함수는 정의되어 있습니다. balance라는 setter 함수도 정의해 보세요. 그리고 해당 setter 함수 안에서 아래 내용들을 구현해 주세요.

파라미터로 전달된 금액이 0 이상일 때만 _balance 프로퍼티의 값으로 설정한다.
음수일 때 'You cannot set negative number for balance'라는 문장을 출력한다.


# 해설
class BankAccount {
  constructor(name, money) {
    this.holder = name;
    this._balance = money;
  }

  get balance() {
    return this._balance;
  }

  set balance(money) {
    if (money >= 0) {
      this._balance = money;
    } else {
      console.log('You cannot set negative number for balance');
    }
  }

  deposit(money) {
    this.balance += money;
  }

  withdraw(money) {
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
    }
  }

  transfer(money, anotherAccount) {
    const account = anotherAccount;
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
      account.balance += money;
    }
  }
}

const account1 = new BankAccount('Michael', 10000);
account1.balance = 20000;
account1.balance = -5000;
코드에 아래와 같이 balance라고 하는 setter 함수를 추가했습니다.

...  
  set balance(money) {
    console.log('You cannot set negative number for balance');
  }
...
그럼 이제 아래 형식의 코드가 실행될 때, balance라고 하는 프로퍼티에 값이 설정되는 것이 아니라 balance라고 하는 setter 함수가 실행되겠죠?

account1.balance = 값 
실제로 코드를 실행해 보면 아래 처럼, 계좌 잔액으로 음수를 설정하려고 할 때 'You cannot set negative number for balance'가 출력되는 것을 볼 수 있습니다.

https://bakey-api.codeit.kr/api/files/resource?root=static&seqId=4463&directory=Untitled.png&name=Untitled.png

자, 이런 식으로 캡슐화를 해 보았는데요. 그런데 이 답은 이전에 배운 것처럼 사실 완벽한 캡슐화라고 보기에는 좀 어려운 점이 있습니다. 왜냐하면 아래와 같은 방법으로, 언제든지 _balance에 직접 접근이 가능하기 때문입니다.

account1._balance = -5000;
자바스크립트에서 캡슐화를 위한 언어 차원에서의 문법이 없기는 하지만 클로저를 사용해서 완벽한 캡슐화를 할 수 있다고 했었죠?

이전 노트에서 배운 것처럼 클로저(Closure)를 활용하면 현재의 답안 코드보다 더 완벽한 캡슐화를 할 수 있습니다. 혹시 관심이 있는 분은 직접 클로저를 활용해서 완벽한 캡슐화를 수행해 보세요.

이번 실습에 대한 완벽한 캡슐화는 아래 코드를 참고해 주세요.

function createBankAccount(name, money) {
  const holder = name;
  let _balance = money;

  const account = {
    get balance() {
      return _balance;
    },

    set balance(money) {
      if (money >= 0) {
        _balance = money;
      } else {
        console.log('You cannot set negative number for balance');
      }
    },

    deposit(money) {
      this.balance += money;
    },

    withdraw(money) {
      if (this.balance - money < 0) {
        console.log('Insufficient balance');
      } else {
        this.balance -= money;
      }
    },

    transfer(money, anotherAccount) {
      const account = anotherAccount;
      if (this.balance - money < 0) {
        console.log('Insufficient balance');
      } else {
        this.balance -= money;
        account.balance += money;
      }
    },
  };
  return account;
}

const account1 = createBankAccount('Michael', 10000);
console.log(account1._balance); // undefined 출력
account1.balance = 20000;
account1.balance = -5000; // 'You cannot set negative number for balance' 출력
사실 객체 지향 프로그래밍을 할 때 캡슐화를 꼭 해야 하는지에 관해서는 의견이 다양합니다. 어떤 언어에서는 캡슐화를 꼭 지켜야할 것처럼 강조하는 분위기이고, 어떤 언어에서는 그렇게 꼭 필수적이지 않다는 분위기도 있기 때문입니다. 그냥 객체의 프로퍼티와 메소드를 조심스럽게만 다루면 될 걸 불필요한 코드를 추가해야 하는가 같은 시선도 있기는 하죠.

이에 관해서는 프로그래밍 언어마다, 회사마다 분위기가 다릅니다. 하지만 캡슐화는 보다 안정적인 프로그램을 만들기 위해 반드시 이해하고 넘어가야 하는 개념입니다. 따라서 필요할 때 빠르게 적용할 수 있도록 그 개념과 구현 방법만큼은 꼭 기억해 둡시다.



## 상속
# extends [User] // 중복되는 코드는 삭제. 부모 요소와 자식 요소의 동일한 코드는 부모요소에서 extends 로 상속한다.

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console. log('${this. email} buys ${item.name}');
  }
}

class PremiumUser extends User {
  constructor(email, birthdate, level) {
    //this.email = email;
    //this.birthdate = birthdate;
    super(email, birthdate);
    this.level = level;
  }

  //buy(item) {
    //console.log('${this.email} buys ${item.name}');
  //}

  streamMusicForFree() {
    console. log( Free music streaming for ${this.email} );
  }
}

const item = {
  name: '스웨터',
  price: 2000,
}


## super
# super(email, birthdate); 
// extends로 상속 했을 때는 자식 클래스의 생성자 함수 안에서 부모 클래스의 생성자 함수를 super라는 키워드로 반드시 호출해야 한다.


## 상속 직접 해보기
# 실습 설명
현재 코드에는 '은행 계좌'를 의미하는 BankAccount 클래스가 정의되어 있습니다. 그런데 이제 새로운 계좌 종류 2 개가 추가되었습니다.

한 달에 한 번씩 잔액에 일정 이자를 더해주는 '저축 계좌'(SavingsAccount)
기부할 목적으로 사용하는 '기부 계좌'(DonationAccount)
두 계좌 모두 BankAccount 클래스의 모든 프로퍼티와 메소드를 필요로 하고, 다음과 같은 추가 사항이 필요합니다.

(1) 저축 계좌(SavingsAccount)

years 프로퍼티: 해당 계좌의 보유 기간, 기본값을 0으로 설정해 주세요.
addInterest 메소드: 해당 계좌의 잔액에 매년 이자를 더해 주는 메소드, addInterest 메소드는 이렇게 생겼습니다.
  addInterest(rate) {
    this.balance *= (1 + (rate * this.years));
  }
계좌 보유 기간에 이자율을 곱해서, 가입 기간이 오래된 장기 고객일수록 더 많은 이자 혜택을 준다는 것을 알 수 있습니다.

(2) 기부 계좌(DonationAccount)

rate 프로퍼티: 계좌 잔액 중 어느 비율만큼 기부할지를 나타냄
donate 메소드: 매년 계좌 잔액의 일정 금액을 자동으로 기부하는 동작을 나타내는 메소드
  donate() {
    this.balance *= (1 - this.rate)
  }
이 설명에 부합하는 저축 계좌(SavingsAccount) 클래스와 기부 계좌(DonationAccount) 클래스를 만들어 보세요.


# 해설
class BankAccount {
  constructor(name, money) {
    this.holder = name;
    this.balance = money;
  }

  get balance() {
    return this._balance;
  }

  set balance(money) {
    if (money >= 0) {
      this._balance = money;
    } else {
      console.log('Not valid');
    }
  }

  deposit(money) {
    this.balance += money;
  }

  withdraw(money) {
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
    }
  }

  transfer(money, anotherAccount) {
    const account = anotherAccount;
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
      account.balance += money;
    }
  }
}

class SavingsAccount extends BankAccount {
  constructor(name, money){
    super(name, money);
    this.years = 0;
  }

  addInterest(rate) {
    this.balance *= (1 + (rate * this.years));
  }
}

class DonationAccount extends BankAccount {
  constructor(name, money, rate){
    super(name, money);
    this.rate = rate;
  }

  donate() {
    this.balance *= (1 - this.rate);
  }
}

const sa1 = new SavingsAccount('Kate', 50000);
const da1 = new DonationAccount('Mike', 90000, 0.05);

sa1.years +=1;
sa1.addInterest(0.02);
da1.donate();
sa1.years +=1; 
sa1.addInterest(0.05);
da1.donate();
sa1.years +=1;
sa1.addInterest(0.07);
da1.donate();

console.log(Math.floor(sa1.balance));
console.log(Math.floor(da1.balance));
문제에 제시된 조건과, 그 아래에서 SavingsAccount 클래스와 DonationAccount 클래스를 어떻게 사용했는지를 살펴보면 어렵지 않게 두 클래스를 작성할 수 있습니다.

이렇게 매년 달라지는 이자율과, 계좌의 보유 기간을 모두 고려했을 때 Kate는 저축 계좌를 가진 시점으로부터 3년 후, 67881원의 잔액을 갖게 됩니다.
그리고 3년간 꾸준히 기부를 한 Mike의 기부 계좌 잔액은 77163원이 됩니다. 참고로 Math.floor()는 내장 객체 Math가 가진 함수로, 어떤 수의 소수점 아래를 버리는 함수입니다.



## 다형성
# index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>자바스크립트 객체 지향</title>
</head>
<body>
  <script src="./index.js"></script>
</body>
</html>

# index.js
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }
  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
}

class PremiumUser extends User {
  constructor(email, birthdate, level) {
    super(email, birthdate);
    this.level = level;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name} with a 5% discount`);
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}
const item = {
  name: '스웨터',
  price: 300000,
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rache@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');

const pUser1 = new PremiumUser('tommy@google.com', '19901207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('alicekim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});


## 부모 클래스의 메소드가 필요하다면?
class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }
  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
}

class PremiumUser extends User {
  constructor(email, birthdate, level, point) {
    super(email, birthdate);
    this.level = level;
    this.point = point;
  }

  buy(item) {
    super.buy(item);  //부모 요소를 가져와서 덮어쓴다.
    this.point += item.price * 0.05;
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}
const item = {
  name: '스웨터',
  price: 300000,
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rache@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');

const pUser1 = new PremiumUser('tommy@google.com', '19901207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('alicekim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});


## 다형성 적용해보기
# 실습 설명
현재 코드에는 '은행 계좌'를 의미하는 BankAccount 클래스가 정의되어 있습니다.

그리고 이 클래스를 상속받는 두 개의 자식 클래스, SavingsAccount 클래스, DonationAccount 클래스가 있는데요.

각 클래스에서 이체를 담당하는 메소드의 이름은 아래와 같습니다.

(1) BankAccount 클래스의 경우 transfer 
(2) SavingsAccount 클래스의 경우 give
(3) DonationAccount 클래스의 경우 send

이렇게 세 클래스는 이체를 담당하는 메소드의 이름도 다르고, 이체 수수료도 다릅니다. (BankAccount 클래스의 경우 이체 수수료가 없고, SavingsAccount 클래스의 경우 0.5%의 이체 수수료, DonationAccount 클래스의 경우 0.2%의 이체 수수료가 있습니다.)

지금 코드의 아래 부분을 보면 Tom, Jerry, Kate, Alice 이 네 사람은 휴가 때 함께 여행을 가기로 했고, 필요한 공동 경비를 모으기 위해 하나의 통장에 모두 똑같이 800,000원씩을 이체하려고 합니다.

// ~
ba1.transfer(800000, accountForVacation);
sa1.give(800000, accountForVacation);
da1.send(800000, accountForVacation);
sa2.give(800000, accountForVacation);
// ~
지금 각자 가진 계좌의 종류가 달라서 이체를 하는 코드를 한 줄씩 일일이 적어 줘야만 합니다. 다형성을 활용하면 기존의 이 코드를 조금 더 짧은 코드로 바꿀 수 있을 것 같은데요. 여러분이 직접 코드를 수정해서 다형성을 활용하는 짧은 코드로 바꿔 보세요.

셀프 채점
다음 항목들이 제대로 구현되었는지 확인해 보세요!

각 클래스에서 '이체' 기능을 담당하는 메소드들의 이름을 모두 transfer로 동일하게 변경하고, for문을 사용하였습니다.

# 해설
BankAccount 클래스의 transfer 메소드, SavingsAccount 클래스의 give 메소드, DonationAccount 클래스의 send 메소드는 모두 아래와 같은 순서로 작업들을 진행함으로써 이체 기능을 수행합니다.

다른 계좌의 잔액을 이체하는 금액만큼 늘린다.
현재 계좌의 잔액을 이체하는 금액만큼 줄인다.
(SavginsAccount 와 DonationAccount의 경우) 이체 수수료만큼 현재 계좌의 잔액을 더 줄인다.
그리고 자식 클래스들은 1. 2.의 작업을 하기 위해 부모 클래스인 BankAccount 클래스의 transfer 메소드를 호출하고 있습니다. 그런데 지금 각 클래스에서 같은 기능을 하는 메소드의 이름들이 달라서 코드가 불필요하게 길어진 상황이죠?

이럴 때는 두 자식 클래스의 메소드인 give 메소드와 send 메소드도 그 이름을 부모 클래스처럼 transfer로 바꿔주면 다형성을 활용할 수 있습니다. 이런 식으로 말이죠.

class BankAccount {
  constructor(name, money) {
    this.holder = name;
    this.balance = money;
  }

  get balance() {
    return this._balance;
  }

  set balance(money) {
    if (money >= 0) {
      this._balance = money;
    } else {
      console.log('Not valid');
    }
  }

  deposit(money) {
    this.balance += money;
  }

  withdraw(money) {
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
    }
  }

  transfer(money, anotherAccount) {
    const account = anotherAccount;
    if (this.balance - money < 0) {
      console.log('Insufficient balance');
    } else {
      this.balance -= money;
      account.balance += money;
    }
  }
}

class SavingsAccount extends BankAccount {
  constructor(name, money){
    super(name, money);
    this.years = 0;
  }

  addInterest(rate) {
    this.balance *= (1 + (rate * this.years));
  }
  
  transfer(money, anotherAccount) {
    super.transfer(money, anotherAccount);
    this.balance -= money * 0.005;
  }
}

class DonationAccount extends BankAccount {
  constructor(name, money, rate) {
    super(name, money);
    this.rate = rate;
  }

  donate(rate) {
    this.balance *= (1 - this.rate);
  }

  transfer(money, anotherAccount) {
    super.transfer(money, anotherAccount);
    this.balance -= money * 0.002;
  }
}

const ba1 = new BankAccount('Tom', 20000000);
const sa1 = new SavingsAccount('Jerry', 10000000);
const da1 = new DonationAccount('Kate', 30000000);
const sa2 = new SavingsAccount('Alice', 9000000);

const accountForVacation = new BankAccount('Vacation', 0);

const accounts = [ba1, sa1, da1, sa2];

for(account of accounts) {
  account.transfer(800000, accountForVacation);
}

console.log(ba1.balance);
console.log(sa1.balance);
console.log(da1.balance);
console.log(sa2.balance);
console.log(accountForVacation.balance);
지금 모든 클래스에서 이체 기능을 담당하는 메소드의 이름을 transfer로 바꿨고, for문 안에서 account 변수가 매번 가리키는 객체의 transfer 메소드를 호출하고 있습니다. 이렇게 하면 account 변수가 어떤 클래스로 만든 객체를 가리키든 상관없이 아래 코드가 잘 실행됩니다.

account.transfer(50000, accountForVacation);
이렇게 부모 클래스와 자식 클래스들에서 동일한 기능을 하는 메소드의 이름을 모두 통일시키고, 다형성을 활용하면, 같은 작업을 조금 더 간결한 코드로 수행할 수 있습니다. 이 사실을 잘 기억하세요!


## instanceof 연산자

다형성으로 만들어진 객체를 확인 할때 사용
어떤 부모요소의 객체를 가져왔는지 확인 가능하며, false 또는 true로 나타난다.

users.forEach((user) => {
console.log(user instanceof PremiumUser);
});


## static 프로퍼티와 static 메소드
class Math {
  static PI = 3.14;

  static getCircleArea(radius) {
    return Math.PI * radius * radius;
  }
}

Math.PI = 3.141592;
Math.getRectangleArea = function (width, height) {
return width * height;
}

console.log (Math. PI);
console.log(Math.getRectangleArea(4, 5));

console.log(Date.now());  // 1970년 1월 1일부터 지금 이시점까지 경과된 밀리초


## 4개의 기둥 정리
# 1. 추상화(Abstraction)
우리가 객체를 만드는 과정은 현실 또는 가상의 존재를 프로그램 내에서 사용할 용도에 맞게 적절하게 설계하는 과정입니다. 이때 객체를 만들고 나면 그 객체를 사용하는 사람은 객체 내부에 존재하는 복잡한 원리를 모르더라도 객체 외부에 공개된 프로퍼티나 메소드만을 가지고도 객체를 문제없이 잘 사용할 수 있어야 합니다. 이를 위해서는 프로퍼티와 메소드의 이름을 누구나 이해하기 쉽게 잘 지어야하고, 필요한 경우 이렇게 주석을 달거나

class User {
  constructor(email, birthdate) {
    // 사용자의 이메일 주소
    this.email = email;
    // 사용자의 생일
    this.birthdate = birthdate;
  }

  // 물건 구매하기
  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
}
그 내용을 문서화하여 공개하기도 합니다. 이는 비단 하나의 객체 뿐만 아니라 여러 객체가 모인 라이브러리나 프레임워크의 경우에도 마찬가지입니다. 우리가 아주 세밀한 원리까지 속속들이 알고 있지 않은 유명한 라이브러리나 프레임워크를 문제없이 사용할 수 있는 것은 그것들이 적절하게 추상화되어 있기 때문입니다.

# 2. 캡슐화(Encapsulation)
캡슐화는 객체 외부에서 함부로 접근하면 안되는 프로퍼티나 메소드에 직접 접근할 수 없도록 하고, 필요한 경우 공개된 다른 메소드를 통해서만 접근할 수 있도록 하는 것을 의미합니다. 아래의 코드를 보면

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }

  get email() {
    return this._email;
  }

  set email(address) {
    if (address.includes('@')) {
      this._email = address;
    } else {
      throw new Error('invalid email address');
    }
  }
}
사용자의 이메일 주소를 나타내는 프로퍼티는 사실 _email 이고, 그 getter/setter 메소드의 이름이 email입니다. 그래서 마치 email 프로퍼티에 접근하는 것 같은 코드를 작성하더라도

const user1 = new User('charlie123@google.com', '2000-12-05');

console.log(user1.email); // email이라는 getter 메소드 실행 
user1.email = 'new123@google.com'; // email이라는 setter 메소드 실행
지금 주석에 적힌 것처럼 사실은 email이라는 getter 메소드 또는 setter 메소드가 실행되는 것이죠. 이렇게 코드를 작성하면 _email 프로퍼티가 보호받고 있는 프로퍼티라는 것을 알 수 있습니다. 하지만 이렇게 해도 완벽한 캡슐화는 아니라고 했었죠? 여전히

console.log(user1._email);
이런 식으로 보호받는 변수에 직접 접근할 수 있기 때문입니다.

사실 다른 언어에서는 해당 언어의 문법 차원에서(ex. Java에서 캡슐화하고 싶은 변수나 메소드 앞에 붙이는 private 키워드) 캡슐화를 지원하는 경우가 많지만 자바스크립트에는 그러한 문법이 없습니다. 하지만 클로저(Closure)라는 것을 사용해서 우회적으로 완벽한 캡슐화를 구현할 수는 있습니다.('캡슐화 더 알아보기' 노트) 어쨌든 중요한 것은 객체를 사용하는 입장에서는 사용하라고 공개된 것 이외에는 되도록 접근하지 말고, 객체를 만드는 입장에서도 미리 보호해야할 프로퍼티나 메소드를 캡슐화해두어야 한다는 점입니다.

# 3. 상속(Inheritance)
상속은 부모 클래스의 프로퍼티와 메소드를 자식 클래스가 그대로 물려받는 것입니다.

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
} 

class PremiumUser extends User {
  constructor(email, birthdate, level) {
    super(email, birthdate);
    this.level = level;
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}
지금 이 코드에서는 PremiumUser 클래스가 User 클래스에 있는 email, birthdate 프로퍼티와 buy 메소드를 그대로 물려받고 있습니다. 이렇게 상속을 적용하면 똑같은 코드를 또다시 작성하지 않아도 됩니다. 즉, '코드의 재사용성(reusability)'이 좋아집니다. 만약 두 클래스에 개념적으로 포함되는 관계가 성립한다고 하면 상속을 적용해보는 것도 좋습니다.

필요한 경우에는 자식 클래스에서 부모 클래스와 동일한 이름의 메소드를 재정의(오버라이딩, overriding)할 수도 있는데요. 이 오버라이딩은 바로 다음에 나오는 '다형성'과 연관이 깊습니다.

# 4. 다형성(Polymorphism)
다형성은 하나의 변수가 다양한 종류의 클래스로 만든 여러 객체를 가리킬 수 있음을 의미합니다.

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
} 

class PremiumUser extends User {
  constructor(email, birthdate, level) {
    super(email, birthdate);
    this.level = level;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name} with a 5% discount`);
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}

const item = { 
  name: '스웨터', 
  price: 30000, 
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rachel@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');
const pUser1 = new PremiumUser('niceguy@google.com', '19891207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('aliceKim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});
이 코드를 보면 지금 forEach 문 안의 user는 User 클래스로 만든 객체를 가리킬 때도 있고, PremiumUser 클래스로 만든 객체를 가리킬 때도 있습니다. 매번 user 객체의 buy 메소드가 호출된다는 점은 같지만, 구체적으로 무슨 클래스로 만든 객체의 buy 메소드가 호출되느냐에 따라 결과가 달라지는데요. 이렇게 단순한 코드로 다양한 결과를 낼 수 있는 건 다형성 덕분인 겁니다.

자, 이때까지 객체 지향 프로그래밍의 4개의 기둥을 복습해보았는데요. 모두 잘 이해하셨나요? 이것들을 잘 이해해야 자바스크립트로 객체 지향 프로그래밍을 잘 할 수 있으니까 혹시 이해가 안 되는 부분이 있다면 해당 영상을 꼭 복습하세요.


## 클래스는 파일 하나당 하나씩 넣어주는 게 좋아요

이때까지 객체 지향 프로그래밍의 4개의 기둥에 대해 배우느라 고생 많으셨습니다. 그런데 여기서 잠깐 한 가지 더 기억하고 가면 좋을 내용이 있습니다. 아래 코드를 보세요.

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
} 

class PremiumUser extends User {
  constructor(email, birthdate, level, point) {
    super(email, birthdate);
    this.level = level;
    this.point = point;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);  
    this.point += item.price * 0.05;
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}

const item = {
  name: '스웨터', 
  price: 30000, 
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rachel@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');
const pUser1 = new PremiumUser('niceguy@google.com', '19891207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('aliceKim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});
이때까지 저는 여러 개의 클래스를 하나의 파일 안에 작성했습니다. 지금 보이는 것처럼 User 클래스와 PremiumUser 클래스를 모두 하나의 파일 안에 정의하고 사용했죠.

그런데 사실 개발 실무에서는 이런 식으로 여러 개의 클래스를 하나의 파일에 정의하기보다는 파일 하나당 클래스 하나를 정의해두고 이를 메인 코드에서 가져와 사용합니다. 예를 들어 위 코드는

User.js

class User {
  constructor(email, birthdate) {
    this.email = email;
    this.birthdate = birthdate;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);
  }
}

export default User;
PremiumUser.js

import User from './User';

class PremiumUser extends User {
  constructor(email, birthdate, level, point) {
    super(email, birthdate);
    this.level = level;
    this.point = point;
  }

  buy(item) {
    console.log(`${this.email} buys ${item.name}`);  
    this.point += item.price * 0.05;
  }

  streamMusicForFree() {
    console.log(`Free music streaming for ${this.email}`);
  }
}

export default PremiumUser
main.js

import User from './User';
import PremiumUser from './PremiumUser';

const item = { 
  name: '스웨터', 
  price: 30000, 
};

const user1 = new User('chris123@google.com', '19920321');
const user2 = new User('rachel@google.com', '19880516');
const user3 = new User('brian@google.com', '20051125');
const pUser1 = new PremiumUser('niceguy@google.com', '19891207', 3);
const pUser2 = new PremiumUser('helloMike@google.com', '19900915', 2);
const pUser3 = new PremiumUser('aliceKim@google.com', '20010722', 5);

const users = [user1, pUser1, user2, pUser2, user3, pUser3];

users.forEach((user) => {
  user.buy(item);
});
이런 식으로 각 클래스와 메인 로직(main.js)을 파일별로 쪼개서 작성합니다. 혹시 모듈 내부의 것을 공개하고(export), 다른 모듈의 것을 가져오는(import) 자바스크립트 문법이 궁금하신 분들은 '모던 자바스크립트' 토픽의 [자바스크립트 모듈] 챕터를 참조하세요.

실무에서는 이렇게 파일 하나당 클래스 하나를 두고 외부에 공개하는 방식을 많이 사용합니다. 그래야 코드를 좀더 편리하게 관리할 수 있기 때문입니다.

이번 토픽에서는 한 눈에 모든 코드를 보기 위해 하나의 파일에 여러 클래스를 작성했지만 실제로는 파일 하나당 클래스 하나를 작성하고, 이를 외부에 공개해서 사용할 수 있도록 하는 방식을 주로 활용한다는 점, 잘 기억하세요.


